
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model Timeline
 * 
 */
export type Timeline = $Result.DefaultSelection<Prisma.$TimelinePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Routine
 * 
 */
export type Routine = $Result.DefaultSelection<Prisma.$RoutinePayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Ability
 * 
 */
export type Ability = $Result.DefaultSelection<Prisma.$AbilityPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Content
 * 
 */
export type Content = $Result.DefaultSelection<Prisma.$ContentPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model FileClassification
 * 
 */
export type FileClassification = $Result.DefaultSelection<Prisma.$FileClassificationPayload>
/**
 * Model FileAssociation
 * 
 */
export type FileAssociation = $Result.DefaultSelection<Prisma.$FileAssociationPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RoleAssociation
 * 
 */
export type RoleAssociation = $Result.DefaultSelection<Prisma.$RoleAssociationPayload>
/**
 * Model RoleClassification
 * 
 */
export type RoleClassification = $Result.DefaultSelection<Prisma.$RoleClassificationPayload>
/**
 * Model Space
 * 
 */
export type Space = $Result.DefaultSelection<Prisma.$SpacePayload>
/**
 * Model SpaceClassification
 * 
 */
export type SpaceClassification = $Result.DefaultSelection<Prisma.$SpaceClassificationPayload>
/**
 * Model SpaceAssociation
 * 
 */
export type SpaceAssociation = $Result.DefaultSelection<Prisma.$SpaceAssociationPayload>
/**
 * Model Ground
 * 
 */
export type Ground = $Result.DefaultSelection<Prisma.$GroundPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserClassification
 * 
 */
export type UserClassification = $Result.DefaultSelection<Prisma.$UserClassificationPayload>
/**
 * Model UserAssociation
 * 
 */
export type UserAssociation = $Result.DefaultSelection<Prisma.$UserAssociationPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SMSStatus: {
  PROGRESS: 'PROGRESS',
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type SMSStatus = (typeof SMSStatus)[keyof typeof SMSStatus]


export const ReservationStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED'
};

export type ReservationStatus = (typeof ReservationStatus)[keyof typeof ReservationStatus]


export const SessionTypes: {
  ONE_TIME: 'ONE_TIME',
  ONE_TIME_RANGE: 'ONE_TIME_RANGE',
  RECURRING: 'RECURRING'
};

export type SessionTypes = (typeof SessionTypes)[keyof typeof SessionTypes]


export const RepeatCycleTypes: {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type RepeatCycleTypes = (typeof RepeatCycleTypes)[keyof typeof RepeatCycleTypes]


export const SessionEndTypes: {
  NEVER: 'NEVER',
  ON_DATE: 'ON_DATE',
  AFTER_OCCURRENCES: 'AFTER_OCCURRENCES'
};

export type SessionEndTypes = (typeof SessionEndTypes)[keyof typeof SessionEndTypes]


export const RecurringDayOfWeek: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type RecurringDayOfWeek = (typeof RecurringDayOfWeek)[keyof typeof RecurringDayOfWeek]


export const AbilityActions: {
  CREATE: 'CREATE',
  READ: 'READ',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  ACCESS: 'ACCESS'
};

export type AbilityActions = (typeof AbilityActions)[keyof typeof AbilityActions]


export const AbilityTypes: {
  CAN: 'CAN',
  CAN_NOT: 'CAN_NOT'
};

export type AbilityTypes = (typeof AbilityTypes)[keyof typeof AbilityTypes]


export const Roles: {
  USER: 'USER',
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN'
};

export type Roles = (typeof Roles)[keyof typeof Roles]


export const TemplateNames: {
  WELCOME: 'WELCOME',
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION',
  RESET_PASSWORD: 'RESET_PASSWORD'
};

export type TemplateNames = (typeof TemplateNames)[keyof typeof TemplateNames]


export const QnaStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export type QnaStatus = (typeof QnaStatus)[keyof typeof QnaStatus]


export const TextTypes: {
  Editor: 'Editor',
  Input: 'Input',
  Textarea: 'Textarea'
};

export type TextTypes = (typeof TextTypes)[keyof typeof TextTypes]


export const CategoryTypes: {
  Role: 'Role',
  Space: 'Space',
  File: 'File',
  User: 'User'
};

export type CategoryTypes = (typeof CategoryTypes)[keyof typeof CategoryTypes]


export const GroupTypes: {
  Role: 'Role',
  Space: 'Space',
  File: 'File',
  User: 'User'
};

export type GroupTypes = (typeof GroupTypes)[keyof typeof GroupTypes]

}

export type SMSStatus = $Enums.SMSStatus

export const SMSStatus: typeof $Enums.SMSStatus

export type ReservationStatus = $Enums.ReservationStatus

export const ReservationStatus: typeof $Enums.ReservationStatus

export type SessionTypes = $Enums.SessionTypes

export const SessionTypes: typeof $Enums.SessionTypes

export type RepeatCycleTypes = $Enums.RepeatCycleTypes

export const RepeatCycleTypes: typeof $Enums.RepeatCycleTypes

export type SessionEndTypes = $Enums.SessionEndTypes

export const SessionEndTypes: typeof $Enums.SessionEndTypes

export type RecurringDayOfWeek = $Enums.RecurringDayOfWeek

export const RecurringDayOfWeek: typeof $Enums.RecurringDayOfWeek

export type AbilityActions = $Enums.AbilityActions

export const AbilityActions: typeof $Enums.AbilityActions

export type AbilityTypes = $Enums.AbilityTypes

export const AbilityTypes: typeof $Enums.AbilityTypes

export type Roles = $Enums.Roles

export const Roles: typeof $Enums.Roles

export type TemplateNames = $Enums.TemplateNames

export const TemplateNames: typeof $Enums.TemplateNames

export type QnaStatus = $Enums.QnaStatus

export const QnaStatus: typeof $Enums.QnaStatus

export type TextTypes = $Enums.TextTypes

export const TextTypes: typeof $Enums.TextTypes

export type CategoryTypes = $Enums.CategoryTypes

export const CategoryTypes: typeof $Enums.CategoryTypes

export type GroupTypes = $Enums.GroupTypes

export const GroupTypes: typeof $Enums.GroupTypes

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.category.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeline`: Exposes CRUD operations for the **Timeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timelines
    * const timelines = await prisma.timeline.findMany()
    * ```
    */
  get timeline(): Prisma.TimelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routine`: Exposes CRUD operations for the **Routine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routines
    * const routines = await prisma.routine.findMany()
    * ```
    */
  get routine(): Prisma.RoutineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ability`: Exposes CRUD operations for the **Ability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abilities
    * const abilities = await prisma.ability.findMany()
    * ```
    */
  get ability(): Prisma.AbilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.content`: Exposes CRUD operations for the **Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.ContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileClassification`: Exposes CRUD operations for the **FileClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileClassifications
    * const fileClassifications = await prisma.fileClassification.findMany()
    * ```
    */
  get fileClassification(): Prisma.FileClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileAssociation`: Exposes CRUD operations for the **FileAssociation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileAssociations
    * const fileAssociations = await prisma.fileAssociation.findMany()
    * ```
    */
  get fileAssociation(): Prisma.FileAssociationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleAssociation`: Exposes CRUD operations for the **RoleAssociation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleAssociations
    * const roleAssociations = await prisma.roleAssociation.findMany()
    * ```
    */
  get roleAssociation(): Prisma.RoleAssociationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleClassification`: Exposes CRUD operations for the **RoleClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleClassifications
    * const roleClassifications = await prisma.roleClassification.findMany()
    * ```
    */
  get roleClassification(): Prisma.RoleClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.space`: Exposes CRUD operations for the **Space** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spaces
    * const spaces = await prisma.space.findMany()
    * ```
    */
  get space(): Prisma.SpaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spaceClassification`: Exposes CRUD operations for the **SpaceClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpaceClassifications
    * const spaceClassifications = await prisma.spaceClassification.findMany()
    * ```
    */
  get spaceClassification(): Prisma.SpaceClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spaceAssociation`: Exposes CRUD operations for the **SpaceAssociation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpaceAssociations
    * const spaceAssociations = await prisma.spaceAssociation.findMany()
    * ```
    */
  get spaceAssociation(): Prisma.SpaceAssociationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ground`: Exposes CRUD operations for the **Ground** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grounds
    * const grounds = await prisma.ground.findMany()
    * ```
    */
  get ground(): Prisma.GroundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userClassification`: Exposes CRUD operations for the **UserClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserClassifications
    * const userClassifications = await prisma.userClassification.findMany()
    * ```
    */
  get userClassification(): Prisma.UserClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAssociation`: Exposes CRUD operations for the **UserAssociation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAssociations
    * const userAssociations = await prisma.userAssociation.findMany()
    * ```
    */
  get userAssociation(): Prisma.UserAssociationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Category: 'Category',
    Group: 'Group',
    Exercise: 'Exercise',
    Tenant: 'Tenant',
    Timeline: 'Timeline',
    Session: 'Session',
    Program: 'Program',
    Activity: 'Activity',
    Routine: 'Routine',
    Task: 'Task',
    Assignment: 'Assignment',
    Action: 'Action',
    Subject: 'Subject',
    Ability: 'Ability',
    Post: 'Post',
    Content: 'Content',
    File: 'File',
    FileClassification: 'FileClassification',
    FileAssociation: 'FileAssociation',
    Role: 'Role',
    RoleAssociation: 'RoleAssociation',
    RoleClassification: 'RoleClassification',
    Space: 'Space',
    SpaceClassification: 'SpaceClassification',
    SpaceAssociation: 'SpaceAssociation',
    Ground: 'Ground',
    User: 'User',
    UserClassification: 'UserClassification',
    UserAssociation: 'UserAssociation',
    Profile: 'Profile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "category" | "group" | "exercise" | "tenant" | "timeline" | "session" | "program" | "activity" | "routine" | "task" | "assignment" | "action" | "subject" | "ability" | "post" | "content" | "file" | "fileClassification" | "fileAssociation" | "role" | "roleAssociation" | "roleClassification" | "space" | "spaceClassification" | "spaceAssociation" | "ground" | "user" | "userClassification" | "userAssociation" | "profile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      Timeline: {
        payload: Prisma.$TimelinePayload<ExtArgs>
        fields: Prisma.TimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>
          }
          findFirst: {
            args: Prisma.TimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>
          }
          findMany: {
            args: Prisma.TimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>[]
          }
          create: {
            args: Prisma.TimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>
          }
          createMany: {
            args: Prisma.TimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>[]
          }
          delete: {
            args: Prisma.TimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>
          }
          update: {
            args: Prisma.TimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>
          }
          deleteMany: {
            args: Prisma.TimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimelineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>[]
          }
          upsert: {
            args: Prisma.TimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelinePayload>
          }
          aggregate: {
            args: Prisma.TimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeline>
          }
          groupBy: {
            args: Prisma.TimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimelineCountArgs<ExtArgs>
            result: $Utils.Optional<TimelineCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Routine: {
        payload: Prisma.$RoutinePayload<ExtArgs>
        fields: Prisma.RoutineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          findFirst: {
            args: Prisma.RoutineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          findMany: {
            args: Prisma.RoutineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>[]
          }
          create: {
            args: Prisma.RoutineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          createMany: {
            args: Prisma.RoutineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>[]
          }
          delete: {
            args: Prisma.RoutineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          update: {
            args: Prisma.RoutineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          deleteMany: {
            args: Prisma.RoutineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoutineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>[]
          }
          upsert: {
            args: Prisma.RoutineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          aggregate: {
            args: Prisma.RoutineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutine>
          }
          groupBy: {
            args: Prisma.RoutineGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutineGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutineCountArgs<ExtArgs>
            result: $Utils.Optional<RoutineCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Ability: {
        payload: Prisma.$AbilityPayload<ExtArgs>
        fields: Prisma.AbilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          findFirst: {
            args: Prisma.AbilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          findMany: {
            args: Prisma.AbilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>[]
          }
          create: {
            args: Prisma.AbilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          createMany: {
            args: Prisma.AbilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AbilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>[]
          }
          delete: {
            args: Prisma.AbilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          update: {
            args: Prisma.AbilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          deleteMany: {
            args: Prisma.AbilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AbilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>[]
          }
          upsert: {
            args: Prisma.AbilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          aggregate: {
            args: Prisma.AbilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbility>
          }
          groupBy: {
            args: Prisma.AbilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbilityCountArgs<ExtArgs>
            result: $Utils.Optional<AbilityCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Content: {
        payload: Prisma.$ContentPayload<ExtArgs>
        fields: Prisma.ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findFirst: {
            args: Prisma.ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findMany: {
            args: Prisma.ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          create: {
            args: Prisma.ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          createMany: {
            args: Prisma.ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          delete: {
            args: Prisma.ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          update: {
            args: Prisma.ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          deleteMany: {
            args: Prisma.ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          upsert: {
            args: Prisma.ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          aggregate: {
            args: Prisma.ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContent>
          }
          groupBy: {
            args: Prisma.ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      FileClassification: {
        payload: Prisma.$FileClassificationPayload<ExtArgs>
        fields: Prisma.FileClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>
          }
          findFirst: {
            args: Prisma.FileClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>
          }
          findMany: {
            args: Prisma.FileClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>[]
          }
          create: {
            args: Prisma.FileClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>
          }
          createMany: {
            args: Prisma.FileClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>[]
          }
          delete: {
            args: Prisma.FileClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>
          }
          update: {
            args: Prisma.FileClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>
          }
          deleteMany: {
            args: Prisma.FileClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileClassificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>[]
          }
          upsert: {
            args: Prisma.FileClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileClassificationPayload>
          }
          aggregate: {
            args: Prisma.FileClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileClassification>
          }
          groupBy: {
            args: Prisma.FileClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<FileClassificationCountAggregateOutputType> | number
          }
        }
      }
      FileAssociation: {
        payload: Prisma.$FileAssociationPayload<ExtArgs>
        fields: Prisma.FileAssociationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileAssociationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileAssociationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>
          }
          findFirst: {
            args: Prisma.FileAssociationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileAssociationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>
          }
          findMany: {
            args: Prisma.FileAssociationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>[]
          }
          create: {
            args: Prisma.FileAssociationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>
          }
          createMany: {
            args: Prisma.FileAssociationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileAssociationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>[]
          }
          delete: {
            args: Prisma.FileAssociationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>
          }
          update: {
            args: Prisma.FileAssociationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>
          }
          deleteMany: {
            args: Prisma.FileAssociationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileAssociationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileAssociationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>[]
          }
          upsert: {
            args: Prisma.FileAssociationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssociationPayload>
          }
          aggregate: {
            args: Prisma.FileAssociationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileAssociation>
          }
          groupBy: {
            args: Prisma.FileAssociationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileAssociationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileAssociationCountArgs<ExtArgs>
            result: $Utils.Optional<FileAssociationCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RoleAssociation: {
        payload: Prisma.$RoleAssociationPayload<ExtArgs>
        fields: Prisma.RoleAssociationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleAssociationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleAssociationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>
          }
          findFirst: {
            args: Prisma.RoleAssociationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleAssociationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>
          }
          findMany: {
            args: Prisma.RoleAssociationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>[]
          }
          create: {
            args: Prisma.RoleAssociationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>
          }
          createMany: {
            args: Prisma.RoleAssociationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleAssociationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>[]
          }
          delete: {
            args: Prisma.RoleAssociationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>
          }
          update: {
            args: Prisma.RoleAssociationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>
          }
          deleteMany: {
            args: Prisma.RoleAssociationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleAssociationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleAssociationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>[]
          }
          upsert: {
            args: Prisma.RoleAssociationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssociationPayload>
          }
          aggregate: {
            args: Prisma.RoleAssociationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleAssociation>
          }
          groupBy: {
            args: Prisma.RoleAssociationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleAssociationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleAssociationCountArgs<ExtArgs>
            result: $Utils.Optional<RoleAssociationCountAggregateOutputType> | number
          }
        }
      }
      RoleClassification: {
        payload: Prisma.$RoleClassificationPayload<ExtArgs>
        fields: Prisma.RoleClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>
          }
          findFirst: {
            args: Prisma.RoleClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>
          }
          findMany: {
            args: Prisma.RoleClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>[]
          }
          create: {
            args: Prisma.RoleClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>
          }
          createMany: {
            args: Prisma.RoleClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>[]
          }
          delete: {
            args: Prisma.RoleClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>
          }
          update: {
            args: Prisma.RoleClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>
          }
          deleteMany: {
            args: Prisma.RoleClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleClassificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>[]
          }
          upsert: {
            args: Prisma.RoleClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleClassificationPayload>
          }
          aggregate: {
            args: Prisma.RoleClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleClassification>
          }
          groupBy: {
            args: Prisma.RoleClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<RoleClassificationCountAggregateOutputType> | number
          }
        }
      }
      Space: {
        payload: Prisma.$SpacePayload<ExtArgs>
        fields: Prisma.SpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findFirst: {
            args: Prisma.SpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findMany: {
            args: Prisma.SpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          create: {
            args: Prisma.SpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          createMany: {
            args: Prisma.SpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          delete: {
            args: Prisma.SpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          update: {
            args: Prisma.SpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          deleteMany: {
            args: Prisma.SpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          upsert: {
            args: Prisma.SpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          aggregate: {
            args: Prisma.SpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpace>
          }
          groupBy: {
            args: Prisma.SpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceCountAggregateOutputType> | number
          }
        }
      }
      SpaceClassification: {
        payload: Prisma.$SpaceClassificationPayload<ExtArgs>
        fields: Prisma.SpaceClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>
          }
          findFirst: {
            args: Prisma.SpaceClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>
          }
          findMany: {
            args: Prisma.SpaceClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>[]
          }
          create: {
            args: Prisma.SpaceClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>
          }
          createMany: {
            args: Prisma.SpaceClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaceClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>[]
          }
          delete: {
            args: Prisma.SpaceClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>
          }
          update: {
            args: Prisma.SpaceClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>
          }
          deleteMany: {
            args: Prisma.SpaceClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpaceClassificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>[]
          }
          upsert: {
            args: Prisma.SpaceClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>
          }
          aggregate: {
            args: Prisma.SpaceClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpaceClassification>
          }
          groupBy: {
            args: Prisma.SpaceClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceClassificationCountAggregateOutputType> | number
          }
        }
      }
      SpaceAssociation: {
        payload: Prisma.$SpaceAssociationPayload<ExtArgs>
        fields: Prisma.SpaceAssociationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceAssociationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceAssociationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>
          }
          findFirst: {
            args: Prisma.SpaceAssociationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceAssociationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>
          }
          findMany: {
            args: Prisma.SpaceAssociationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>[]
          }
          create: {
            args: Prisma.SpaceAssociationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>
          }
          createMany: {
            args: Prisma.SpaceAssociationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaceAssociationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>[]
          }
          delete: {
            args: Prisma.SpaceAssociationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>
          }
          update: {
            args: Prisma.SpaceAssociationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>
          }
          deleteMany: {
            args: Prisma.SpaceAssociationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceAssociationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpaceAssociationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>[]
          }
          upsert: {
            args: Prisma.SpaceAssociationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>
          }
          aggregate: {
            args: Prisma.SpaceAssociationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpaceAssociation>
          }
          groupBy: {
            args: Prisma.SpaceAssociationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceAssociationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceAssociationCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceAssociationCountAggregateOutputType> | number
          }
        }
      }
      Ground: {
        payload: Prisma.$GroundPayload<ExtArgs>
        fields: Prisma.GroundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>
          }
          findFirst: {
            args: Prisma.GroundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>
          }
          findMany: {
            args: Prisma.GroundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>[]
          }
          create: {
            args: Prisma.GroundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>
          }
          createMany: {
            args: Prisma.GroundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>[]
          }
          delete: {
            args: Prisma.GroundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>
          }
          update: {
            args: Prisma.GroundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>
          }
          deleteMany: {
            args: Prisma.GroundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>[]
          }
          upsert: {
            args: Prisma.GroundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundPayload>
          }
          aggregate: {
            args: Prisma.GroundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGround>
          }
          groupBy: {
            args: Prisma.GroundGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroundGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroundCountArgs<ExtArgs>
            result: $Utils.Optional<GroundCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserClassification: {
        payload: Prisma.$UserClassificationPayload<ExtArgs>
        fields: Prisma.UserClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>
          }
          findFirst: {
            args: Prisma.UserClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>
          }
          findMany: {
            args: Prisma.UserClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>[]
          }
          create: {
            args: Prisma.UserClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>
          }
          createMany: {
            args: Prisma.UserClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>[]
          }
          delete: {
            args: Prisma.UserClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>
          }
          update: {
            args: Prisma.UserClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>
          }
          deleteMany: {
            args: Prisma.UserClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserClassificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>[]
          }
          upsert: {
            args: Prisma.UserClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassificationPayload>
          }
          aggregate: {
            args: Prisma.UserClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserClassification>
          }
          groupBy: {
            args: Prisma.UserClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<UserClassificationCountAggregateOutputType> | number
          }
        }
      }
      UserAssociation: {
        payload: Prisma.$UserAssociationPayload<ExtArgs>
        fields: Prisma.UserAssociationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAssociationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAssociationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>
          }
          findFirst: {
            args: Prisma.UserAssociationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAssociationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>
          }
          findMany: {
            args: Prisma.UserAssociationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>[]
          }
          create: {
            args: Prisma.UserAssociationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>
          }
          createMany: {
            args: Prisma.UserAssociationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAssociationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>[]
          }
          delete: {
            args: Prisma.UserAssociationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>
          }
          update: {
            args: Prisma.UserAssociationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>
          }
          deleteMany: {
            args: Prisma.UserAssociationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAssociationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAssociationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>[]
          }
          upsert: {
            args: Prisma.UserAssociationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssociationPayload>
          }
          aggregate: {
            args: Prisma.UserAssociationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAssociation>
          }
          groupBy: {
            args: Prisma.UserAssociationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAssociationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAssociationCountArgs<ExtArgs>
            result: $Utils.Optional<UserAssociationCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    category?: CategoryOmit
    group?: GroupOmit
    exercise?: ExerciseOmit
    tenant?: TenantOmit
    timeline?: TimelineOmit
    session?: SessionOmit
    program?: ProgramOmit
    activity?: ActivityOmit
    routine?: RoutineOmit
    task?: TaskOmit
    assignment?: AssignmentOmit
    action?: ActionOmit
    subject?: SubjectOmit
    ability?: AbilityOmit
    post?: PostOmit
    content?: ContentOmit
    file?: FileOmit
    fileClassification?: FileClassificationOmit
    fileAssociation?: FileAssociationOmit
    role?: RoleOmit
    roleAssociation?: RoleAssociationOmit
    roleClassification?: RoleClassificationOmit
    space?: SpaceOmit
    spaceClassification?: SpaceClassificationOmit
    spaceAssociation?: SpaceAssociationOmit
    ground?: GroundOmit
    user?: UserOmit
    userClassification?: UserClassificationOmit
    userAssociation?: UserAssociationOmit
    profile?: ProfileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    fileClassifications: number
    roleClassifications: number
    spaceClassifications: number
    userClassifications: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    fileClassifications?: boolean | CategoryCountOutputTypeCountFileClassificationsArgs
    roleClassifications?: boolean | CategoryCountOutputTypeCountRoleClassificationsArgs
    spaceClassifications?: boolean | CategoryCountOutputTypeCountSpaceClassificationsArgs
    userClassifications?: boolean | CategoryCountOutputTypeCountUserClassificationsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountFileClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileClassificationWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountRoleClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleClassificationWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSpaceClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceClassificationWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountUserClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClassificationWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    fileAssociations: number
    roleAssociations: number
    spaceAssociations: number
    userAssociations: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fileAssociations?: boolean | GroupCountOutputTypeCountFileAssociationsArgs
    roleAssociations?: boolean | GroupCountOutputTypeCountRoleAssociationsArgs
    spaceAssociations?: boolean | GroupCountOutputTypeCountSpaceAssociationsArgs
    userAssociations?: boolean | GroupCountOutputTypeCountUserAssociationsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountFileAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAssociationWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountRoleAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssociationWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountSpaceAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceAssociationWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountUserAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssociationWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    assignments: number
    categories: number
    contents: number
    files: number
    groups: number
    timelines: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | TenantCountOutputTypeCountAssignmentsArgs
    categories?: boolean | TenantCountOutputTypeCountCategoriesArgs
    contents?: boolean | TenantCountOutputTypeCountContentsArgs
    files?: boolean | TenantCountOutputTypeCountFilesArgs
    groups?: boolean | TenantCountOutputTypeCountGroupsArgs
    timelines?: boolean | TenantCountOutputTypeCountTimelinesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTimelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineWhereInput
  }


  /**
   * Count Type TimelineCountOutputType
   */

  export type TimelineCountOutputType = {
    sessions: number
  }

  export type TimelineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TimelineCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * TimelineCountOutputType without action
   */
  export type TimelineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineCountOutputType
     */
    select?: TimelineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimelineCountOutputType without action
   */
  export type TimelineCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    posts: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ContentCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    children: number
    associations: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FileCountOutputTypeCountChildrenArgs
    associations?: boolean | FileCountOutputTypeCountAssociationsArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAssociationWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    abilities: number
    assignments: number
    associations: number
    tenants: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilities?: boolean | RoleCountOutputTypeCountAbilitiesArgs
    assignments?: boolean | RoleCountOutputTypeCountAssignmentsArgs
    associations?: boolean | RoleCountOutputTypeCountAssociationsArgs
    tenants?: boolean | RoleCountOutputTypeCountTenantsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountAbilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbilityWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssociationWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }


  /**
   * Count Type SpaceCountOutputType
   */

  export type SpaceCountOutputType = {
    associations: number
    tenants: number
  }

  export type SpaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    associations?: boolean | SpaceCountOutputTypeCountAssociationsArgs
    tenants?: boolean | SpaceCountOutputTypeCountTenantsArgs
  }

  // Custom InputTypes
  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceCountOutputType
     */
    select?: SpaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceAssociationWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    profiles: number
    tenants: number
    associations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | UserCountOutputTypeCountProfilesArgs
    tenants?: boolean | UserCountOutputTypeCountTenantsArgs
    associations?: boolean | UserCountOutputTypeCountAssociationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssociationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    seq: number | null
  }

  export type CategorySumAggregateOutputType = {
    seq: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    type: $Enums.CategoryTypes | null
    parentId: string | null
    tenantId: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    type: $Enums.CategoryTypes | null
    parentId: string | null
    tenantId: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    type: number
    parentId: number
    tenantId: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    seq?: true
  }

  export type CategorySumAggregateInputType = {
    seq?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    type?: true
    parentId?: true
    tenantId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    type?: true
    parentId?: true
    tenantId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    type?: true
    parentId?: true
    tenantId?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: string
    type: $Enums.CategoryTypes
    parentId: string | null
    tenantId: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    tenantId?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    fileClassifications?: boolean | Category$fileClassificationsArgs<ExtArgs>
    roleClassifications?: boolean | Category$roleClassificationsArgs<ExtArgs>
    spaceClassifications?: boolean | Category$spaceClassificationsArgs<ExtArgs>
    userClassifications?: boolean | Category$userClassificationsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    tenantId?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    tenantId?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    tenantId?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name" | "type" | "parentId" | "tenantId", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    fileClassifications?: boolean | Category$fileClassificationsArgs<ExtArgs>
    roleClassifications?: boolean | Category$roleClassificationsArgs<ExtArgs>
    spaceClassifications?: boolean | Category$spaceClassificationsArgs<ExtArgs>
    userClassifications?: boolean | Category$userClassificationsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      fileClassifications: Prisma.$FileClassificationPayload<ExtArgs>[]
      roleClassifications: Prisma.$RoleClassificationPayload<ExtArgs>[]
      spaceClassifications: Prisma.$SpaceClassificationPayload<ExtArgs>[]
      userClassifications: Prisma.$UserClassificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: string
      type: $Enums.CategoryTypes
      parentId: string | null
      tenantId: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fileClassifications<T extends Category$fileClassificationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$fileClassificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleClassifications<T extends Category$roleClassificationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$roleClassificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spaceClassifications<T extends Category$spaceClassificationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$spaceClassificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userClassifications<T extends Category$userClassificationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$userClassificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly seq: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly removedAt: FieldRef<"Category", 'DateTime'>
    readonly name: FieldRef<"Category", 'String'>
    readonly type: FieldRef<"Category", 'CategoryTypes'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly tenantId: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.fileClassifications
   */
  export type Category$fileClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    where?: FileClassificationWhereInput
    orderBy?: FileClassificationOrderByWithRelationInput | FileClassificationOrderByWithRelationInput[]
    cursor?: FileClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileClassificationScalarFieldEnum | FileClassificationScalarFieldEnum[]
  }

  /**
   * Category.roleClassifications
   */
  export type Category$roleClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    where?: RoleClassificationWhereInput
    orderBy?: RoleClassificationOrderByWithRelationInput | RoleClassificationOrderByWithRelationInput[]
    cursor?: RoleClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleClassificationScalarFieldEnum | RoleClassificationScalarFieldEnum[]
  }

  /**
   * Category.spaceClassifications
   */
  export type Category$spaceClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    where?: SpaceClassificationWhereInput
    orderBy?: SpaceClassificationOrderByWithRelationInput | SpaceClassificationOrderByWithRelationInput[]
    cursor?: SpaceClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceClassificationScalarFieldEnum | SpaceClassificationScalarFieldEnum[]
  }

  /**
   * Category.userClassifications
   */
  export type Category$userClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    where?: UserClassificationWhereInput
    orderBy?: UserClassificationOrderByWithRelationInput | UserClassificationOrderByWithRelationInput[]
    cursor?: UserClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserClassificationScalarFieldEnum | UserClassificationScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    seq: number | null
  }

  export type GroupSumAggregateOutputType = {
    seq: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    type: $Enums.GroupTypes | null
    label: string | null
    tenantId: string | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    type: $Enums.GroupTypes | null
    label: string | null
    tenantId: string | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    type: number
    label: number
    tenantId: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    seq?: true
  }

  export type GroupSumAggregateInputType = {
    seq?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    type?: true
    label?: true
    tenantId?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    type?: true
    label?: true
    tenantId?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    type?: true
    label?: true
    tenantId?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: string
    type: $Enums.GroupTypes
    label: string | null
    tenantId: string
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    label?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    fileAssociations?: boolean | Group$fileAssociationsArgs<ExtArgs>
    roleAssociations?: boolean | Group$roleAssociationsArgs<ExtArgs>
    spaceAssociations?: boolean | Group$spaceAssociationsArgs<ExtArgs>
    userAssociations?: boolean | Group$userAssociationsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    label?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    label?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    type?: boolean
    label?: boolean
    tenantId?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name" | "type" | "label" | "tenantId", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    fileAssociations?: boolean | Group$fileAssociationsArgs<ExtArgs>
    roleAssociations?: boolean | Group$roleAssociationsArgs<ExtArgs>
    spaceAssociations?: boolean | Group$spaceAssociationsArgs<ExtArgs>
    userAssociations?: boolean | Group$userAssociationsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      fileAssociations: Prisma.$FileAssociationPayload<ExtArgs>[]
      roleAssociations: Prisma.$RoleAssociationPayload<ExtArgs>[]
      spaceAssociations: Prisma.$SpaceAssociationPayload<ExtArgs>[]
      userAssociations: Prisma.$UserAssociationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: string
      type: $Enums.GroupTypes
      label: string | null
      tenantId: string
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fileAssociations<T extends Group$fileAssociationsArgs<ExtArgs> = {}>(args?: Subset<T, Group$fileAssociationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleAssociations<T extends Group$roleAssociationsArgs<ExtArgs> = {}>(args?: Subset<T, Group$roleAssociationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spaceAssociations<T extends Group$spaceAssociationsArgs<ExtArgs> = {}>(args?: Subset<T, Group$spaceAssociationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userAssociations<T extends Group$userAssociationsArgs<ExtArgs> = {}>(args?: Subset<T, Group$userAssociationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly seq: FieldRef<"Group", 'Int'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
    readonly removedAt: FieldRef<"Group", 'DateTime'>
    readonly name: FieldRef<"Group", 'String'>
    readonly type: FieldRef<"Group", 'GroupTypes'>
    readonly label: FieldRef<"Group", 'String'>
    readonly tenantId: FieldRef<"Group", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.fileAssociations
   */
  export type Group$fileAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    where?: FileAssociationWhereInput
    orderBy?: FileAssociationOrderByWithRelationInput | FileAssociationOrderByWithRelationInput[]
    cursor?: FileAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileAssociationScalarFieldEnum | FileAssociationScalarFieldEnum[]
  }

  /**
   * Group.roleAssociations
   */
  export type Group$roleAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    where?: RoleAssociationWhereInput
    orderBy?: RoleAssociationOrderByWithRelationInput | RoleAssociationOrderByWithRelationInput[]
    cursor?: RoleAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleAssociationScalarFieldEnum | RoleAssociationScalarFieldEnum[]
  }

  /**
   * Group.spaceAssociations
   */
  export type Group$spaceAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    where?: SpaceAssociationWhereInput
    orderBy?: SpaceAssociationOrderByWithRelationInput | SpaceAssociationOrderByWithRelationInput[]
    cursor?: SpaceAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceAssociationScalarFieldEnum | SpaceAssociationScalarFieldEnum[]
  }

  /**
   * Group.userAssociations
   */
  export type Group$userAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    where?: UserAssociationWhereInput
    orderBy?: UserAssociationOrderByWithRelationInput | UserAssociationOrderByWithRelationInput[]
    cursor?: UserAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAssociationScalarFieldEnum | UserAssociationScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    seq: number | null
    duration: number | null
    count: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    seq: number | null
    duration: number | null
    count: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    duration: number | null
    count: number | null
    taskId: string | null
    description: string | null
    imageFileId: string | null
    videoFileId: string | null
    name: string | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    duration: number | null
    count: number | null
    taskId: string | null
    description: string | null
    imageFileId: string | null
    videoFileId: string | null
    name: string | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    duration: number
    count: number
    taskId: number
    description: number
    imageFileId: number
    videoFileId: number
    name: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    seq?: true
    duration?: true
    count?: true
  }

  export type ExerciseSumAggregateInputType = {
    seq?: true
    duration?: true
    count?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    duration?: true
    count?: true
    taskId?: true
    description?: true
    imageFileId?: true
    videoFileId?: true
    name?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    duration?: true
    count?: true
    taskId?: true
    description?: true
    imageFileId?: true
    videoFileId?: true
    name?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    duration?: true
    count?: true
    taskId?: true
    description?: true
    imageFileId?: true
    videoFileId?: true
    name?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    duration: number
    count: number
    taskId: string
    description: string | null
    imageFileId: string | null
    videoFileId: string | null
    name: string
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    duration?: boolean
    count?: boolean
    taskId?: boolean
    description?: boolean
    imageFileId?: boolean
    videoFileId?: boolean
    name?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    duration?: boolean
    count?: boolean
    taskId?: boolean
    description?: boolean
    imageFileId?: boolean
    videoFileId?: boolean
    name?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    duration?: boolean
    count?: boolean
    taskId?: boolean
    description?: boolean
    imageFileId?: boolean
    videoFileId?: boolean
    name?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    duration?: boolean
    count?: boolean
    taskId?: boolean
    description?: boolean
    imageFileId?: boolean
    videoFileId?: boolean
    name?: boolean
  }

  export type ExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "duration" | "count" | "taskId" | "description" | "imageFileId" | "videoFileId" | "name", ExtArgs["result"]["exercise"]>
  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      duration: number
      count: number
      taskId: string
      description: string | null
      imageFileId: string | null
      videoFileId: string | null
      name: string
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises and returns the data updated in the database.
     * @param {ExerciseUpdateManyAndReturnArgs} args - Arguments to update many Exercises.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
    readonly seq: FieldRef<"Exercise", 'Int'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
    readonly removedAt: FieldRef<"Exercise", 'DateTime'>
    readonly duration: FieldRef<"Exercise", 'Int'>
    readonly count: FieldRef<"Exercise", 'Int'>
    readonly taskId: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly imageFileId: FieldRef<"Exercise", 'String'>
    readonly videoFileId: FieldRef<"Exercise", 'String'>
    readonly name: FieldRef<"Exercise", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
  }

  /**
   * Exercise updateManyAndReturn
   */
  export type ExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to delete.
     */
    limit?: number
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    seq: number | null
  }

  export type TenantSumAggregateOutputType = {
    seq: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    userId: string | null
    spaceId: string | null
    roleId: string | null
    main: boolean | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    userId: string | null
    spaceId: string | null
    roleId: string | null
    main: boolean | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    userId: number
    spaceId: number
    roleId: number
    main: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    seq?: true
  }

  export type TenantSumAggregateInputType = {
    seq?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    userId?: true
    spaceId?: true
    roleId?: true
    main?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    userId?: true
    spaceId?: true
    roleId?: true
    main?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    userId?: true
    spaceId?: true
    roleId?: true
    main?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    userId: string
    spaceId: string
    roleId: string
    main: boolean
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    spaceId?: boolean
    roleId?: boolean
    main?: boolean
    assignments?: boolean | Tenant$assignmentsArgs<ExtArgs>
    categories?: boolean | Tenant$categoriesArgs<ExtArgs>
    contents?: boolean | Tenant$contentsArgs<ExtArgs>
    files?: boolean | Tenant$filesArgs<ExtArgs>
    groups?: boolean | Tenant$groupsArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    timelines?: boolean | Tenant$timelinesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    spaceId?: boolean
    roleId?: boolean
    main?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    spaceId?: boolean
    roleId?: boolean
    main?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    spaceId?: boolean
    roleId?: boolean
    main?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "userId" | "spaceId" | "roleId" | "main", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Tenant$assignmentsArgs<ExtArgs>
    categories?: boolean | Tenant$categoriesArgs<ExtArgs>
    contents?: boolean | Tenant$contentsArgs<ExtArgs>
    files?: boolean | Tenant$filesArgs<ExtArgs>
    groups?: boolean | Tenant$groupsArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    timelines?: boolean | Tenant$timelinesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      contents: Prisma.$ContentPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      groups: Prisma.$GroupPayload<ExtArgs>[]
      role: Prisma.$RolePayload<ExtArgs>
      space: Prisma.$SpacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      timelines: Prisma.$TimelinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      userId: string
      spaceId: string
      roleId: string
      main: boolean
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Tenant$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Tenant$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contents<T extends Tenant$contentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$contentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Tenant$filesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Tenant$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timelines<T extends Tenant$timelinesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$timelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly seq: FieldRef<"Tenant", 'Int'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly removedAt: FieldRef<"Tenant", 'DateTime'>
    readonly userId: FieldRef<"Tenant", 'String'>
    readonly spaceId: FieldRef<"Tenant", 'String'>
    readonly roleId: FieldRef<"Tenant", 'String'>
    readonly main: FieldRef<"Tenant", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.assignments
   */
  export type Tenant$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Tenant.categories
   */
  export type Tenant$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Tenant.contents
   */
  export type Tenant$contentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Tenant.files
   */
  export type Tenant$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Tenant.groups
   */
  export type Tenant$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Tenant.timelines
   */
  export type Tenant$timelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    where?: TimelineWhereInput
    orderBy?: TimelineOrderByWithRelationInput | TimelineOrderByWithRelationInput[]
    cursor?: TimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimelineScalarFieldEnum | TimelineScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model Timeline
   */

  export type AggregateTimeline = {
    _count: TimelineCountAggregateOutputType | null
    _avg: TimelineAvgAggregateOutputType | null
    _sum: TimelineSumAggregateOutputType | null
    _min: TimelineMinAggregateOutputType | null
    _max: TimelineMaxAggregateOutputType | null
  }

  export type TimelineAvgAggregateOutputType = {
    seq: number | null
  }

  export type TimelineSumAggregateOutputType = {
    seq: number | null
  }

  export type TimelineMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    tenantId: string | null
  }

  export type TimelineMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    tenantId: string | null
  }

  export type TimelineCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    tenantId: number
    _all: number
  }


  export type TimelineAvgAggregateInputType = {
    seq?: true
  }

  export type TimelineSumAggregateInputType = {
    seq?: true
  }

  export type TimelineMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    tenantId?: true
  }

  export type TimelineMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    tenantId?: true
  }

  export type TimelineCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    tenantId?: true
    _all?: true
  }

  export type TimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timeline to aggregate.
     */
    where?: TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timelines to fetch.
     */
    orderBy?: TimelineOrderByWithRelationInput | TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Timelines
    **/
    _count?: true | TimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimelineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimelineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimelineMaxAggregateInputType
  }

  export type GetTimelineAggregateType<T extends TimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeline[P]>
      : GetScalarType<T[P], AggregateTimeline[P]>
  }




  export type TimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineWhereInput
    orderBy?: TimelineOrderByWithAggregationInput | TimelineOrderByWithAggregationInput[]
    by: TimelineScalarFieldEnum[] | TimelineScalarFieldEnum
    having?: TimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimelineCountAggregateInputType | true
    _avg?: TimelineAvgAggregateInputType
    _sum?: TimelineSumAggregateInputType
    _min?: TimelineMinAggregateInputType
    _max?: TimelineMaxAggregateInputType
  }

  export type TimelineGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    tenantId: string
    _count: TimelineCountAggregateOutputType | null
    _avg: TimelineAvgAggregateOutputType | null
    _sum: TimelineSumAggregateOutputType | null
    _min: TimelineMinAggregateOutputType | null
    _max: TimelineMaxAggregateOutputType | null
  }

  type GetTimelineGroupByPayload<T extends TimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimelineGroupByOutputType[P]>
            : GetScalarType<T[P], TimelineGroupByOutputType[P]>
        }
      >
    >


  export type TimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
    sessions?: boolean | Timeline$sessionsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | TimelineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeline"]>

  export type TimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeline"]>

  export type TimelineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeline"]>

  export type TimelineSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
  }

  export type TimelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "tenantId", ExtArgs["result"]["timeline"]>
  export type TimelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Timeline$sessionsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | TimelineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TimelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TimelineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Timeline"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      tenantId: string
    }, ExtArgs["result"]["timeline"]>
    composites: {}
  }

  type TimelineGetPayload<S extends boolean | null | undefined | TimelineDefaultArgs> = $Result.GetResult<Prisma.$TimelinePayload, S>

  type TimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimelineCountAggregateInputType | true
    }

  export interface TimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Timeline'], meta: { name: 'Timeline' } }
    /**
     * Find zero or one Timeline that matches the filter.
     * @param {TimelineFindUniqueArgs} args - Arguments to find a Timeline
     * @example
     * // Get one Timeline
     * const timeline = await prisma.timeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimelineFindUniqueArgs>(args: SelectSubset<T, TimelineFindUniqueArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Timeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimelineFindUniqueOrThrowArgs} args - Arguments to find a Timeline
     * @example
     * // Get one Timeline
     * const timeline = await prisma.timeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, TimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineFindFirstArgs} args - Arguments to find a Timeline
     * @example
     * // Get one Timeline
     * const timeline = await prisma.timeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimelineFindFirstArgs>(args?: SelectSubset<T, TimelineFindFirstArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineFindFirstOrThrowArgs} args - Arguments to find a Timeline
     * @example
     * // Get one Timeline
     * const timeline = await prisma.timeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, TimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Timelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timelines
     * const timelines = await prisma.timeline.findMany()
     * 
     * // Get first 10 Timelines
     * const timelines = await prisma.timeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timelineWithIdOnly = await prisma.timeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimelineFindManyArgs>(args?: SelectSubset<T, TimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Timeline.
     * @param {TimelineCreateArgs} args - Arguments to create a Timeline.
     * @example
     * // Create one Timeline
     * const Timeline = await prisma.timeline.create({
     *   data: {
     *     // ... data to create a Timeline
     *   }
     * })
     * 
     */
    create<T extends TimelineCreateArgs>(args: SelectSubset<T, TimelineCreateArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Timelines.
     * @param {TimelineCreateManyArgs} args - Arguments to create many Timelines.
     * @example
     * // Create many Timelines
     * const timeline = await prisma.timeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimelineCreateManyArgs>(args?: SelectSubset<T, TimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Timelines and returns the data saved in the database.
     * @param {TimelineCreateManyAndReturnArgs} args - Arguments to create many Timelines.
     * @example
     * // Create many Timelines
     * const timeline = await prisma.timeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Timelines and only return the `id`
     * const timelineWithIdOnly = await prisma.timeline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, TimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Timeline.
     * @param {TimelineDeleteArgs} args - Arguments to delete one Timeline.
     * @example
     * // Delete one Timeline
     * const Timeline = await prisma.timeline.delete({
     *   where: {
     *     // ... filter to delete one Timeline
     *   }
     * })
     * 
     */
    delete<T extends TimelineDeleteArgs>(args: SelectSubset<T, TimelineDeleteArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Timeline.
     * @param {TimelineUpdateArgs} args - Arguments to update one Timeline.
     * @example
     * // Update one Timeline
     * const timeline = await prisma.timeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimelineUpdateArgs>(args: SelectSubset<T, TimelineUpdateArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Timelines.
     * @param {TimelineDeleteManyArgs} args - Arguments to filter Timelines to delete.
     * @example
     * // Delete a few Timelines
     * const { count } = await prisma.timeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimelineDeleteManyArgs>(args?: SelectSubset<T, TimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timelines
     * const timeline = await prisma.timeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimelineUpdateManyArgs>(args: SelectSubset<T, TimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timelines and returns the data updated in the database.
     * @param {TimelineUpdateManyAndReturnArgs} args - Arguments to update many Timelines.
     * @example
     * // Update many Timelines
     * const timeline = await prisma.timeline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Timelines and only return the `id`
     * const timelineWithIdOnly = await prisma.timeline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimelineUpdateManyAndReturnArgs>(args: SelectSubset<T, TimelineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Timeline.
     * @param {TimelineUpsertArgs} args - Arguments to update or create a Timeline.
     * @example
     * // Update or create a Timeline
     * const timeline = await prisma.timeline.upsert({
     *   create: {
     *     // ... data to create a Timeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timeline we want to update
     *   }
     * })
     */
    upsert<T extends TimelineUpsertArgs>(args: SelectSubset<T, TimelineUpsertArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Timelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineCountArgs} args - Arguments to filter Timelines to count.
     * @example
     * // Count the number of Timelines
     * const count = await prisma.timeline.count({
     *   where: {
     *     // ... the filter for the Timelines we want to count
     *   }
     * })
    **/
    count<T extends TimelineCountArgs>(
      args?: Subset<T, TimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimelineAggregateArgs>(args: Subset<T, TimelineAggregateArgs>): Prisma.PrismaPromise<GetTimelineAggregateType<T>>

    /**
     * Group by Timeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimelineGroupByArgs['orderBy'] }
        : { orderBy?: TimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Timeline model
   */
  readonly fields: TimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Timeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Timeline$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Timeline$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Timeline model
   */
  interface TimelineFieldRefs {
    readonly id: FieldRef<"Timeline", 'String'>
    readonly seq: FieldRef<"Timeline", 'Int'>
    readonly createdAt: FieldRef<"Timeline", 'DateTime'>
    readonly updatedAt: FieldRef<"Timeline", 'DateTime'>
    readonly removedAt: FieldRef<"Timeline", 'DateTime'>
    readonly tenantId: FieldRef<"Timeline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Timeline findUnique
   */
  export type TimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * Filter, which Timeline to fetch.
     */
    where: TimelineWhereUniqueInput
  }

  /**
   * Timeline findUniqueOrThrow
   */
  export type TimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * Filter, which Timeline to fetch.
     */
    where: TimelineWhereUniqueInput
  }

  /**
   * Timeline findFirst
   */
  export type TimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * Filter, which Timeline to fetch.
     */
    where?: TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timelines to fetch.
     */
    orderBy?: TimelineOrderByWithRelationInput | TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timelines.
     */
    cursor?: TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timelines.
     */
    distinct?: TimelineScalarFieldEnum | TimelineScalarFieldEnum[]
  }

  /**
   * Timeline findFirstOrThrow
   */
  export type TimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * Filter, which Timeline to fetch.
     */
    where?: TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timelines to fetch.
     */
    orderBy?: TimelineOrderByWithRelationInput | TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timelines.
     */
    cursor?: TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timelines.
     */
    distinct?: TimelineScalarFieldEnum | TimelineScalarFieldEnum[]
  }

  /**
   * Timeline findMany
   */
  export type TimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * Filter, which Timelines to fetch.
     */
    where?: TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timelines to fetch.
     */
    orderBy?: TimelineOrderByWithRelationInput | TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Timelines.
     */
    cursor?: TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timelines.
     */
    skip?: number
    distinct?: TimelineScalarFieldEnum | TimelineScalarFieldEnum[]
  }

  /**
   * Timeline create
   */
  export type TimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * The data needed to create a Timeline.
     */
    data: XOR<TimelineCreateInput, TimelineUncheckedCreateInput>
  }

  /**
   * Timeline createMany
   */
  export type TimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Timelines.
     */
    data: TimelineCreateManyInput | TimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Timeline createManyAndReturn
   */
  export type TimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * The data used to create many Timelines.
     */
    data: TimelineCreateManyInput | TimelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timeline update
   */
  export type TimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * The data needed to update a Timeline.
     */
    data: XOR<TimelineUpdateInput, TimelineUncheckedUpdateInput>
    /**
     * Choose, which Timeline to update.
     */
    where: TimelineWhereUniqueInput
  }

  /**
   * Timeline updateMany
   */
  export type TimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Timelines.
     */
    data: XOR<TimelineUpdateManyMutationInput, TimelineUncheckedUpdateManyInput>
    /**
     * Filter which Timelines to update
     */
    where?: TimelineWhereInput
    /**
     * Limit how many Timelines to update.
     */
    limit?: number
  }

  /**
   * Timeline updateManyAndReturn
   */
  export type TimelineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * The data used to update Timelines.
     */
    data: XOR<TimelineUpdateManyMutationInput, TimelineUncheckedUpdateManyInput>
    /**
     * Filter which Timelines to update
     */
    where?: TimelineWhereInput
    /**
     * Limit how many Timelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timeline upsert
   */
  export type TimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * The filter to search for the Timeline to update in case it exists.
     */
    where: TimelineWhereUniqueInput
    /**
     * In case the Timeline found by the `where` argument doesn't exist, create a new Timeline with this data.
     */
    create: XOR<TimelineCreateInput, TimelineUncheckedCreateInput>
    /**
     * In case the Timeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimelineUpdateInput, TimelineUncheckedUpdateInput>
  }

  /**
   * Timeline delete
   */
  export type TimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
    /**
     * Filter which Timeline to delete.
     */
    where: TimelineWhereUniqueInput
  }

  /**
   * Timeline deleteMany
   */
  export type TimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timelines to delete
     */
    where?: TimelineWhereInput
    /**
     * Limit how many Timelines to delete.
     */
    limit?: number
  }

  /**
   * Timeline.sessions
   */
  export type Timeline$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Timeline without action
   */
  export type TimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timeline
     */
    select?: TimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timeline
     */
    omit?: TimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    seq: number | null
    recurringMonth: number | null
  }

  export type SessionSumAggregateOutputType = {
    seq: number | null
    recurringMonth: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    type: $Enums.SessionTypes | null
    repeatCycleType: $Enums.RepeatCycleTypes | null
    startDateTime: Date | null
    endDateTime: Date | null
    recurringDayOfWeek: $Enums.RecurringDayOfWeek | null
    recurringMonth: number | null
    timelineId: string | null
    label: string | null
    name: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    type: $Enums.SessionTypes | null
    repeatCycleType: $Enums.RepeatCycleTypes | null
    startDateTime: Date | null
    endDateTime: Date | null
    recurringDayOfWeek: $Enums.RecurringDayOfWeek | null
    recurringMonth: number | null
    timelineId: string | null
    label: string | null
    name: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    type: number
    repeatCycleType: number
    startDateTime: number
    endDateTime: number
    recurringDayOfWeek: number
    recurringMonth: number
    timelineId: number
    label: number
    name: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    seq?: true
    recurringMonth?: true
  }

  export type SessionSumAggregateInputType = {
    seq?: true
    recurringMonth?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    type?: true
    repeatCycleType?: true
    startDateTime?: true
    endDateTime?: true
    recurringDayOfWeek?: true
    recurringMonth?: true
    timelineId?: true
    label?: true
    name?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    type?: true
    repeatCycleType?: true
    startDateTime?: true
    endDateTime?: true
    recurringDayOfWeek?: true
    recurringMonth?: true
    timelineId?: true
    label?: true
    name?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    type?: true
    repeatCycleType?: true
    startDateTime?: true
    endDateTime?: true
    recurringDayOfWeek?: true
    recurringMonth?: true
    timelineId?: true
    label?: true
    name?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    type: $Enums.SessionTypes
    repeatCycleType: $Enums.RepeatCycleTypes | null
    startDateTime: Date | null
    endDateTime: Date | null
    recurringDayOfWeek: $Enums.RecurringDayOfWeek | null
    recurringMonth: number | null
    timelineId: string
    label: string
    name: string
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    repeatCycleType?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    recurringDayOfWeek?: boolean
    recurringMonth?: boolean
    timelineId?: boolean
    label?: boolean
    name?: boolean
    program?: boolean | Session$programArgs<ExtArgs>
    timeline?: boolean | TimelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    repeatCycleType?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    recurringDayOfWeek?: boolean
    recurringMonth?: boolean
    timelineId?: boolean
    label?: boolean
    name?: boolean
    timeline?: boolean | TimelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    repeatCycleType?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    recurringDayOfWeek?: boolean
    recurringMonth?: boolean
    timelineId?: boolean
    label?: boolean
    name?: boolean
    timeline?: boolean | TimelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    repeatCycleType?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    recurringDayOfWeek?: boolean
    recurringMonth?: boolean
    timelineId?: boolean
    label?: boolean
    name?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "type" | "repeatCycleType" | "startDateTime" | "endDateTime" | "recurringDayOfWeek" | "recurringMonth" | "timelineId" | "label" | "name", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Session$programArgs<ExtArgs>
    timeline?: boolean | TimelineDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeline?: boolean | TimelineDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeline?: boolean | TimelineDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs> | null
      timeline: Prisma.$TimelinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      type: $Enums.SessionTypes
      repeatCycleType: $Enums.RepeatCycleTypes | null
      startDateTime: Date | null
      endDateTime: Date | null
      recurringDayOfWeek: $Enums.RecurringDayOfWeek | null
      recurringMonth: number | null
      timelineId: string
      label: string
      name: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends Session$programArgs<ExtArgs> = {}>(args?: Subset<T, Session$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    timeline<T extends TimelineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimelineDefaultArgs<ExtArgs>>): Prisma__TimelineClient<$Result.GetResult<Prisma.$TimelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly seq: FieldRef<"Session", 'Int'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly removedAt: FieldRef<"Session", 'DateTime'>
    readonly type: FieldRef<"Session", 'SessionTypes'>
    readonly repeatCycleType: FieldRef<"Session", 'RepeatCycleTypes'>
    readonly startDateTime: FieldRef<"Session", 'DateTime'>
    readonly endDateTime: FieldRef<"Session", 'DateTime'>
    readonly recurringDayOfWeek: FieldRef<"Session", 'RecurringDayOfWeek'>
    readonly recurringMonth: FieldRef<"Session", 'Int'>
    readonly timelineId: FieldRef<"Session", 'String'>
    readonly label: FieldRef<"Session", 'String'>
    readonly name: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.program
   */
  export type Session$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    seq: number | null
    capacity: number | null
  }

  export type ProgramSumAggregateOutputType = {
    seq: number | null
    capacity: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    routineId: string | null
    sessionId: string | null
    instructorId: string | null
    capacity: number | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    routineId: string | null
    sessionId: string | null
    instructorId: string | null
    capacity: number | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    routineId: number
    sessionId: number
    instructorId: number
    capacity: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    seq?: true
    capacity?: true
  }

  export type ProgramSumAggregateInputType = {
    seq?: true
    capacity?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    routineId?: true
    sessionId?: true
    instructorId?: true
    capacity?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    routineId?: true
    sessionId?: true
    instructorId?: true
    capacity?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    routineId?: true
    sessionId?: true
    instructorId?: true
    capacity?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    routineId: string
    sessionId: string
    instructorId: string
    capacity: number
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    sessionId?: boolean
    instructorId?: boolean
    capacity?: boolean
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    sessionId?: boolean
    instructorId?: boolean
    capacity?: boolean
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    sessionId?: boolean
    instructorId?: boolean
    capacity?: boolean
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    sessionId?: boolean
    instructorId?: boolean
    capacity?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "routineId" | "sessionId" | "instructorId" | "capacity", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      routine: Prisma.$RoutinePayload<ExtArgs>
      session: Prisma.$SessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      routineId: string
      sessionId: string
      instructorId: string
      capacity: number
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs and returns the data updated in the database.
     * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routine<T extends RoutineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoutineDefaultArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly seq: FieldRef<"Program", 'Int'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
    readonly removedAt: FieldRef<"Program", 'DateTime'>
    readonly routineId: FieldRef<"Program", 'String'>
    readonly sessionId: FieldRef<"Program", 'String'>
    readonly instructorId: FieldRef<"Program", 'String'>
    readonly capacity: FieldRef<"Program", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program updateManyAndReturn
   */
  export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    seq: number | null
  }

  export type ActivitySumAggregateOutputType = {
    seq: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    routineId: string | null
    taskId: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    routineId: string | null
    taskId: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    routineId: number
    taskId: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    seq?: true
  }

  export type ActivitySumAggregateInputType = {
    seq?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    routineId?: true
    taskId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    routineId?: true
    taskId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    routineId?: true
    taskId?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    routineId: string
    taskId: string
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    taskId?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    taskId?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    taskId?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    routineId?: boolean
    taskId?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "routineId" | "taskId", ExtArgs["result"]["activity"]>

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      routineId: string
      taskId: string
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly seq: FieldRef<"Activity", 'Int'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly removedAt: FieldRef<"Activity", 'DateTime'>
    readonly routineId: FieldRef<"Activity", 'String'>
    readonly taskId: FieldRef<"Activity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
  }


  /**
   * Model Routine
   */

  export type AggregateRoutine = {
    _count: RoutineCountAggregateOutputType | null
    _avg: RoutineAvgAggregateOutputType | null
    _sum: RoutineSumAggregateOutputType | null
    _min: RoutineMinAggregateOutputType | null
    _max: RoutineMaxAggregateOutputType | null
  }

  export type RoutineAvgAggregateOutputType = {
    seq: number | null
  }

  export type RoutineSumAggregateOutputType = {
    seq: number | null
  }

  export type RoutineMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    label: string | null
  }

  export type RoutineMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    label: string | null
  }

  export type RoutineCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    label: number
    _all: number
  }


  export type RoutineAvgAggregateInputType = {
    seq?: true
  }

  export type RoutineSumAggregateInputType = {
    seq?: true
  }

  export type RoutineMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    label?: true
  }

  export type RoutineMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    label?: true
  }

  export type RoutineCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    label?: true
    _all?: true
  }

  export type RoutineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routine to aggregate.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routines
    **/
    _count?: true | RoutineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoutineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoutineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutineMaxAggregateInputType
  }

  export type GetRoutineAggregateType<T extends RoutineAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutine[P]>
      : GetScalarType<T[P], AggregateRoutine[P]>
  }




  export type RoutineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineWhereInput
    orderBy?: RoutineOrderByWithAggregationInput | RoutineOrderByWithAggregationInput[]
    by: RoutineScalarFieldEnum[] | RoutineScalarFieldEnum
    having?: RoutineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutineCountAggregateInputType | true
    _avg?: RoutineAvgAggregateInputType
    _sum?: RoutineSumAggregateInputType
    _min?: RoutineMinAggregateInputType
    _max?: RoutineMaxAggregateInputType
  }

  export type RoutineGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: string
    label: string
    _count: RoutineCountAggregateOutputType | null
    _avg: RoutineAvgAggregateOutputType | null
    _sum: RoutineSumAggregateOutputType | null
    _min: RoutineMinAggregateOutputType | null
    _max: RoutineMaxAggregateOutputType | null
  }

  type GetRoutineGroupByPayload<T extends RoutineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutineGroupByOutputType[P]>
            : GetScalarType<T[P], RoutineGroupByOutputType[P]>
        }
      >
    >


  export type RoutineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
    program?: boolean | Routine$programArgs<ExtArgs>
  }, ExtArgs["result"]["routine"]>

  export type RoutineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
  }, ExtArgs["result"]["routine"]>

  export type RoutineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
  }, ExtArgs["result"]["routine"]>

  export type RoutineSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
  }

  export type RoutineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name" | "label", ExtArgs["result"]["routine"]>
  export type RoutineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Routine$programArgs<ExtArgs>
  }
  export type RoutineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoutineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoutinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Routine"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: string
      label: string
    }, ExtArgs["result"]["routine"]>
    composites: {}
  }

  type RoutineGetPayload<S extends boolean | null | undefined | RoutineDefaultArgs> = $Result.GetResult<Prisma.$RoutinePayload, S>

  type RoutineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoutineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoutineCountAggregateInputType | true
    }

  export interface RoutineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Routine'], meta: { name: 'Routine' } }
    /**
     * Find zero or one Routine that matches the filter.
     * @param {RoutineFindUniqueArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutineFindUniqueArgs>(args: SelectSubset<T, RoutineFindUniqueArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Routine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoutineFindUniqueOrThrowArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutineFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Routine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineFindFirstArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutineFindFirstArgs>(args?: SelectSubset<T, RoutineFindFirstArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Routine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineFindFirstOrThrowArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutineFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutineFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Routines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routines
     * const routines = await prisma.routine.findMany()
     * 
     * // Get first 10 Routines
     * const routines = await prisma.routine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routineWithIdOnly = await prisma.routine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoutineFindManyArgs>(args?: SelectSubset<T, RoutineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Routine.
     * @param {RoutineCreateArgs} args - Arguments to create a Routine.
     * @example
     * // Create one Routine
     * const Routine = await prisma.routine.create({
     *   data: {
     *     // ... data to create a Routine
     *   }
     * })
     * 
     */
    create<T extends RoutineCreateArgs>(args: SelectSubset<T, RoutineCreateArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Routines.
     * @param {RoutineCreateManyArgs} args - Arguments to create many Routines.
     * @example
     * // Create many Routines
     * const routine = await prisma.routine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutineCreateManyArgs>(args?: SelectSubset<T, RoutineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Routines and returns the data saved in the database.
     * @param {RoutineCreateManyAndReturnArgs} args - Arguments to create many Routines.
     * @example
     * // Create many Routines
     * const routine = await prisma.routine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Routines and only return the `id`
     * const routineWithIdOnly = await prisma.routine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutineCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Routine.
     * @param {RoutineDeleteArgs} args - Arguments to delete one Routine.
     * @example
     * // Delete one Routine
     * const Routine = await prisma.routine.delete({
     *   where: {
     *     // ... filter to delete one Routine
     *   }
     * })
     * 
     */
    delete<T extends RoutineDeleteArgs>(args: SelectSubset<T, RoutineDeleteArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Routine.
     * @param {RoutineUpdateArgs} args - Arguments to update one Routine.
     * @example
     * // Update one Routine
     * const routine = await prisma.routine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutineUpdateArgs>(args: SelectSubset<T, RoutineUpdateArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Routines.
     * @param {RoutineDeleteManyArgs} args - Arguments to filter Routines to delete.
     * @example
     * // Delete a few Routines
     * const { count } = await prisma.routine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutineDeleteManyArgs>(args?: SelectSubset<T, RoutineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routines
     * const routine = await prisma.routine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutineUpdateManyArgs>(args: SelectSubset<T, RoutineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routines and returns the data updated in the database.
     * @param {RoutineUpdateManyAndReturnArgs} args - Arguments to update many Routines.
     * @example
     * // Update many Routines
     * const routine = await prisma.routine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Routines and only return the `id`
     * const routineWithIdOnly = await prisma.routine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoutineUpdateManyAndReturnArgs>(args: SelectSubset<T, RoutineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Routine.
     * @param {RoutineUpsertArgs} args - Arguments to update or create a Routine.
     * @example
     * // Update or create a Routine
     * const routine = await prisma.routine.upsert({
     *   create: {
     *     // ... data to create a Routine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Routine we want to update
     *   }
     * })
     */
    upsert<T extends RoutineUpsertArgs>(args: SelectSubset<T, RoutineUpsertArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineCountArgs} args - Arguments to filter Routines to count.
     * @example
     * // Count the number of Routines
     * const count = await prisma.routine.count({
     *   where: {
     *     // ... the filter for the Routines we want to count
     *   }
     * })
    **/
    count<T extends RoutineCountArgs>(
      args?: Subset<T, RoutineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutineAggregateArgs>(args: Subset<T, RoutineAggregateArgs>): Prisma.PrismaPromise<GetRoutineAggregateType<T>>

    /**
     * Group by Routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutineGroupByArgs['orderBy'] }
        : { orderBy?: RoutineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Routine model
   */
  readonly fields: RoutineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Routine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends Routine$programArgs<ExtArgs> = {}>(args?: Subset<T, Routine$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Routine model
   */
  interface RoutineFieldRefs {
    readonly id: FieldRef<"Routine", 'String'>
    readonly seq: FieldRef<"Routine", 'Int'>
    readonly createdAt: FieldRef<"Routine", 'DateTime'>
    readonly updatedAt: FieldRef<"Routine", 'DateTime'>
    readonly removedAt: FieldRef<"Routine", 'DateTime'>
    readonly name: FieldRef<"Routine", 'String'>
    readonly label: FieldRef<"Routine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Routine findUnique
   */
  export type RoutineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine findUniqueOrThrow
   */
  export type RoutineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine findFirst
   */
  export type RoutineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routines.
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routines.
     */
    distinct?: RoutineScalarFieldEnum | RoutineScalarFieldEnum[]
  }

  /**
   * Routine findFirstOrThrow
   */
  export type RoutineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routines.
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routines.
     */
    distinct?: RoutineScalarFieldEnum | RoutineScalarFieldEnum[]
  }

  /**
   * Routine findMany
   */
  export type RoutineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routines to fetch.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routines.
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    distinct?: RoutineScalarFieldEnum | RoutineScalarFieldEnum[]
  }

  /**
   * Routine create
   */
  export type RoutineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * The data needed to create a Routine.
     */
    data: XOR<RoutineCreateInput, RoutineUncheckedCreateInput>
  }

  /**
   * Routine createMany
   */
  export type RoutineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routines.
     */
    data: RoutineCreateManyInput | RoutineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Routine createManyAndReturn
   */
  export type RoutineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * The data used to create many Routines.
     */
    data: RoutineCreateManyInput | RoutineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Routine update
   */
  export type RoutineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * The data needed to update a Routine.
     */
    data: XOR<RoutineUpdateInput, RoutineUncheckedUpdateInput>
    /**
     * Choose, which Routine to update.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine updateMany
   */
  export type RoutineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routines.
     */
    data: XOR<RoutineUpdateManyMutationInput, RoutineUncheckedUpdateManyInput>
    /**
     * Filter which Routines to update
     */
    where?: RoutineWhereInput
    /**
     * Limit how many Routines to update.
     */
    limit?: number
  }

  /**
   * Routine updateManyAndReturn
   */
  export type RoutineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * The data used to update Routines.
     */
    data: XOR<RoutineUpdateManyMutationInput, RoutineUncheckedUpdateManyInput>
    /**
     * Filter which Routines to update
     */
    where?: RoutineWhereInput
    /**
     * Limit how many Routines to update.
     */
    limit?: number
  }

  /**
   * Routine upsert
   */
  export type RoutineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * The filter to search for the Routine to update in case it exists.
     */
    where: RoutineWhereUniqueInput
    /**
     * In case the Routine found by the `where` argument doesn't exist, create a new Routine with this data.
     */
    create: XOR<RoutineCreateInput, RoutineUncheckedCreateInput>
    /**
     * In case the Routine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutineUpdateInput, RoutineUncheckedUpdateInput>
  }

  /**
   * Routine delete
   */
  export type RoutineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter which Routine to delete.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine deleteMany
   */
  export type RoutineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routines to delete
     */
    where?: RoutineWhereInput
    /**
     * Limit how many Routines to delete.
     */
    limit?: number
  }

  /**
   * Routine.program
   */
  export type Routine$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * Routine without action
   */
  export type RoutineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Routine
     */
    omit?: RoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    seq: number | null
  }

  export type TaskSumAggregateOutputType = {
    seq: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    tenantId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    tenantId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    tenantId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    seq?: true
  }

  export type TaskSumAggregateInputType = {
    seq?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    tenantId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    tenantId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    tenantId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    tenantId: string
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
    exercise?: boolean | Task$exerciseArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    tenantId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "tenantId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | Task$exerciseArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      tenantId: string
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends Task$exerciseArgs<ExtArgs> = {}>(args?: Subset<T, Task$exerciseArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly seq: FieldRef<"Task", 'Int'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly removedAt: FieldRef<"Task", 'DateTime'>
    readonly tenantId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.exercise
   */
  export type Task$exerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    seq: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    seq: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    roleId: string | null
    tenantId: string | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    roleId: string | null
    tenantId: string | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    roleId: number
    tenantId: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    seq?: true
  }

  export type AssignmentSumAggregateInputType = {
    seq?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    roleId?: true
    tenantId?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    roleId?: true
    tenantId?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    roleId?: true
    tenantId?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    roleId: string
    tenantId: string
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    tenantId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    tenantId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    tenantId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    tenantId?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "roleId" | "tenantId", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      roleId: string
      tenantId: string
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {AssignmentUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly seq: FieldRef<"Assignment", 'Int'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
    readonly removedAt: FieldRef<"Assignment", 'DateTime'>
    readonly roleId: FieldRef<"Assignment", 'String'>
    readonly tenantId: FieldRef<"Assignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment updateManyAndReturn
   */
  export type AssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    seq: number | null
  }

  export type ActionSumAggregateOutputType = {
    seq: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: $Enums.AbilityActions | null
    tenantId: string | null
  }

  export type ActionMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: $Enums.AbilityActions | null
    tenantId: string | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    conditions: number
    tenantId: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    seq?: true
  }

  export type ActionSumAggregateInputType = {
    seq?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    tenantId?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    tenantId?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    conditions?: true
    tenantId?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: $Enums.AbilityActions
    conditions: JsonValue | null
    tenantId: string
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    conditions?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    conditions?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    conditions?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    conditions?: boolean
    tenantId?: boolean
  }

  export type ActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name" | "conditions" | "tenantId", ExtArgs["result"]["action"]>

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: $Enums.AbilityActions
      conditions: Prisma.JsonValue | null
      tenantId: string
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions and returns the data updated in the database.
     * @param {ActionUpdateManyAndReturnArgs} args - Arguments to update many Actions.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */
  interface ActionFieldRefs {
    readonly id: FieldRef<"Action", 'String'>
    readonly seq: FieldRef<"Action", 'Int'>
    readonly createdAt: FieldRef<"Action", 'DateTime'>
    readonly updatedAt: FieldRef<"Action", 'DateTime'>
    readonly removedAt: FieldRef<"Action", 'DateTime'>
    readonly name: FieldRef<"Action", 'AbilityActions'>
    readonly conditions: FieldRef<"Action", 'Json'>
    readonly tenantId: FieldRef<"Action", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action createManyAndReturn
   */
  export type ActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action updateManyAndReturn
   */
  export type ActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to delete.
     */
    limit?: number
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    seq: number | null
  }

  export type SubjectSumAggregateOutputType = {
    seq: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    tenantId: string | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    tenantId: string | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    tenantId: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    seq?: true
  }

  export type SubjectSumAggregateInputType = {
    seq?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    tenantId?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    tenantId?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    tenantId?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: string
    tenantId: string
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    tenantId?: boolean
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    tenantId?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name" | "tenantId", ExtArgs["result"]["subject"]>

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: string
      tenantId: string
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly seq: FieldRef<"Subject", 'Int'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
    readonly removedAt: FieldRef<"Subject", 'DateTime'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly tenantId: FieldRef<"Subject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
  }


  /**
   * Model Ability
   */

  export type AggregateAbility = {
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  export type AbilityAvgAggregateOutputType = {
    seq: number | null
  }

  export type AbilitySumAggregateOutputType = {
    seq: number | null
  }

  export type AbilityMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    type: $Enums.AbilityTypes | null
    roleId: string | null
    description: string | null
    subjectId: string | null
    tenantId: string | null
  }

  export type AbilityMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    type: $Enums.AbilityTypes | null
    roleId: string | null
    description: string | null
    subjectId: string | null
    tenantId: string | null
  }

  export type AbilityCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    type: number
    roleId: number
    description: number
    conditions: number
    subjectId: number
    tenantId: number
    _all: number
  }


  export type AbilityAvgAggregateInputType = {
    seq?: true
  }

  export type AbilitySumAggregateInputType = {
    seq?: true
  }

  export type AbilityMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    type?: true
    roleId?: true
    description?: true
    subjectId?: true
    tenantId?: true
  }

  export type AbilityMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    type?: true
    roleId?: true
    description?: true
    subjectId?: true
    tenantId?: true
  }

  export type AbilityCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    type?: true
    roleId?: true
    description?: true
    conditions?: true
    subjectId?: true
    tenantId?: true
    _all?: true
  }

  export type AbilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ability to aggregate.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Abilities
    **/
    _count?: true | AbilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbilityMaxAggregateInputType
  }

  export type GetAbilityAggregateType<T extends AbilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAbility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbility[P]>
      : GetScalarType<T[P], AggregateAbility[P]>
  }




  export type AbilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbilityWhereInput
    orderBy?: AbilityOrderByWithAggregationInput | AbilityOrderByWithAggregationInput[]
    by: AbilityScalarFieldEnum[] | AbilityScalarFieldEnum
    having?: AbilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbilityCountAggregateInputType | true
    _avg?: AbilityAvgAggregateInputType
    _sum?: AbilitySumAggregateInputType
    _min?: AbilityMinAggregateInputType
    _max?: AbilityMaxAggregateInputType
  }

  export type AbilityGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    type: $Enums.AbilityTypes
    roleId: string
    description: string | null
    conditions: JsonValue | null
    subjectId: string
    tenantId: string
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  type GetAbilityGroupByPayload<T extends AbilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbilityGroupByOutputType[P]>
            : GetScalarType<T[P], AbilityGroupByOutputType[P]>
        }
      >
    >


  export type AbilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    roleId?: boolean
    description?: boolean
    conditions?: boolean
    subjectId?: boolean
    tenantId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ability"]>

  export type AbilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    roleId?: boolean
    description?: boolean
    conditions?: boolean
    subjectId?: boolean
    tenantId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ability"]>

  export type AbilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    roleId?: boolean
    description?: boolean
    conditions?: boolean
    subjectId?: boolean
    tenantId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ability"]>

  export type AbilitySelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    type?: boolean
    roleId?: boolean
    description?: boolean
    conditions?: boolean
    subjectId?: boolean
    tenantId?: boolean
  }

  export type AbilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "type" | "roleId" | "description" | "conditions" | "subjectId" | "tenantId", ExtArgs["result"]["ability"]>
  export type AbilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type AbilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type AbilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $AbilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ability"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      type: $Enums.AbilityTypes
      roleId: string
      description: string | null
      conditions: Prisma.JsonValue | null
      subjectId: string
      tenantId: string
    }, ExtArgs["result"]["ability"]>
    composites: {}
  }

  type AbilityGetPayload<S extends boolean | null | undefined | AbilityDefaultArgs> = $Result.GetResult<Prisma.$AbilityPayload, S>

  type AbilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbilityCountAggregateInputType | true
    }

  export interface AbilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ability'], meta: { name: 'Ability' } }
    /**
     * Find zero or one Ability that matches the filter.
     * @param {AbilityFindUniqueArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbilityFindUniqueArgs>(args: SelectSubset<T, AbilityFindUniqueArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbilityFindUniqueOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AbilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindFirstArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbilityFindFirstArgs>(args?: SelectSubset<T, AbilityFindFirstArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindFirstOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AbilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Abilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abilities
     * const abilities = await prisma.ability.findMany()
     * 
     * // Get first 10 Abilities
     * const abilities = await prisma.ability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abilityWithIdOnly = await prisma.ability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbilityFindManyArgs>(args?: SelectSubset<T, AbilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ability.
     * @param {AbilityCreateArgs} args - Arguments to create a Ability.
     * @example
     * // Create one Ability
     * const Ability = await prisma.ability.create({
     *   data: {
     *     // ... data to create a Ability
     *   }
     * })
     * 
     */
    create<T extends AbilityCreateArgs>(args: SelectSubset<T, AbilityCreateArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Abilities.
     * @param {AbilityCreateManyArgs} args - Arguments to create many Abilities.
     * @example
     * // Create many Abilities
     * const ability = await prisma.ability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbilityCreateManyArgs>(args?: SelectSubset<T, AbilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Abilities and returns the data saved in the database.
     * @param {AbilityCreateManyAndReturnArgs} args - Arguments to create many Abilities.
     * @example
     * // Create many Abilities
     * const ability = await prisma.ability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Abilities and only return the `id`
     * const abilityWithIdOnly = await prisma.ability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AbilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AbilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ability.
     * @param {AbilityDeleteArgs} args - Arguments to delete one Ability.
     * @example
     * // Delete one Ability
     * const Ability = await prisma.ability.delete({
     *   where: {
     *     // ... filter to delete one Ability
     *   }
     * })
     * 
     */
    delete<T extends AbilityDeleteArgs>(args: SelectSubset<T, AbilityDeleteArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ability.
     * @param {AbilityUpdateArgs} args - Arguments to update one Ability.
     * @example
     * // Update one Ability
     * const ability = await prisma.ability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbilityUpdateArgs>(args: SelectSubset<T, AbilityUpdateArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Abilities.
     * @param {AbilityDeleteManyArgs} args - Arguments to filter Abilities to delete.
     * @example
     * // Delete a few Abilities
     * const { count } = await prisma.ability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbilityDeleteManyArgs>(args?: SelectSubset<T, AbilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abilities
     * const ability = await prisma.ability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbilityUpdateManyArgs>(args: SelectSubset<T, AbilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abilities and returns the data updated in the database.
     * @param {AbilityUpdateManyAndReturnArgs} args - Arguments to update many Abilities.
     * @example
     * // Update many Abilities
     * const ability = await prisma.ability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Abilities and only return the `id`
     * const abilityWithIdOnly = await prisma.ability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AbilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AbilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ability.
     * @param {AbilityUpsertArgs} args - Arguments to update or create a Ability.
     * @example
     * // Update or create a Ability
     * const ability = await prisma.ability.upsert({
     *   create: {
     *     // ... data to create a Ability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ability we want to update
     *   }
     * })
     */
    upsert<T extends AbilityUpsertArgs>(args: SelectSubset<T, AbilityUpsertArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityCountArgs} args - Arguments to filter Abilities to count.
     * @example
     * // Count the number of Abilities
     * const count = await prisma.ability.count({
     *   where: {
     *     // ... the filter for the Abilities we want to count
     *   }
     * })
    **/
    count<T extends AbilityCountArgs>(
      args?: Subset<T, AbilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbilityAggregateArgs>(args: Subset<T, AbilityAggregateArgs>): Prisma.PrismaPromise<GetAbilityAggregateType<T>>

    /**
     * Group by Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbilityGroupByArgs['orderBy'] }
        : { orderBy?: AbilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ability model
   */
  readonly fields: AbilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ability model
   */
  interface AbilityFieldRefs {
    readonly id: FieldRef<"Ability", 'String'>
    readonly seq: FieldRef<"Ability", 'Int'>
    readonly createdAt: FieldRef<"Ability", 'DateTime'>
    readonly updatedAt: FieldRef<"Ability", 'DateTime'>
    readonly removedAt: FieldRef<"Ability", 'DateTime'>
    readonly type: FieldRef<"Ability", 'AbilityTypes'>
    readonly roleId: FieldRef<"Ability", 'String'>
    readonly description: FieldRef<"Ability", 'String'>
    readonly conditions: FieldRef<"Ability", 'Json'>
    readonly subjectId: FieldRef<"Ability", 'String'>
    readonly tenantId: FieldRef<"Ability", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ability findUnique
   */
  export type AbilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability findUniqueOrThrow
   */
  export type AbilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability findFirst
   */
  export type AbilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * Ability findFirstOrThrow
   */
  export type AbilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * Ability findMany
   */
  export type AbilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Abilities to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * Ability create
   */
  export type AbilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Ability.
     */
    data: XOR<AbilityCreateInput, AbilityUncheckedCreateInput>
  }

  /**
   * Ability createMany
   */
  export type AbilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Abilities.
     */
    data: AbilityCreateManyInput | AbilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ability createManyAndReturn
   */
  export type AbilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * The data used to create many Abilities.
     */
    data: AbilityCreateManyInput | AbilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ability update
   */
  export type AbilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Ability.
     */
    data: XOR<AbilityUpdateInput, AbilityUncheckedUpdateInput>
    /**
     * Choose, which Ability to update.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability updateMany
   */
  export type AbilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Abilities.
     */
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyInput>
    /**
     * Filter which Abilities to update
     */
    where?: AbilityWhereInput
    /**
     * Limit how many Abilities to update.
     */
    limit?: number
  }

  /**
   * Ability updateManyAndReturn
   */
  export type AbilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * The data used to update Abilities.
     */
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyInput>
    /**
     * Filter which Abilities to update
     */
    where?: AbilityWhereInput
    /**
     * Limit how many Abilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ability upsert
   */
  export type AbilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Ability to update in case it exists.
     */
    where: AbilityWhereUniqueInput
    /**
     * In case the Ability found by the `where` argument doesn't exist, create a new Ability with this data.
     */
    create: XOR<AbilityCreateInput, AbilityUncheckedCreateInput>
    /**
     * In case the Ability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbilityUpdateInput, AbilityUncheckedUpdateInput>
  }

  /**
   * Ability delete
   */
  export type AbilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter which Ability to delete.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability deleteMany
   */
  export type AbilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abilities to delete
     */
    where?: AbilityWhereInput
    /**
     * Limit how many Abilities to delete.
     */
    limit?: number
  }

  /**
   * Ability without action
   */
  export type AbilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    seq: number | null
  }

  export type PostSumAggregateOutputType = {
    seq: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    contentId: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    contentId: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    contentId: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    seq?: true
  }

  export type PostSumAggregateInputType = {
    seq?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    contentId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    contentId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    contentId?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    contentId: string
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    contentId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    contentId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    contentId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    contentId?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "contentId", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      contentId: string
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly seq: FieldRef<"Post", 'Int'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly removedAt: FieldRef<"Post", 'DateTime'>
    readonly contentId: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    seq: number | null
  }

  export type ContentSumAggregateOutputType = {
    seq: number | null
  }

  export type ContentMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    title: string | null
    description: string | null
    type: $Enums.TextTypes | null
    text: string | null
    fileId: string | null
    tenantId: string | null
  }

  export type ContentMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    title: string | null
    description: string | null
    type: $Enums.TextTypes | null
    text: string | null
    fileId: string | null
    tenantId: string | null
  }

  export type ContentCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    title: number
    description: number
    type: number
    text: number
    fileId: number
    tenantId: number
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    seq?: true
  }

  export type ContentSumAggregateInputType = {
    seq?: true
  }

  export type ContentMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    title?: true
    description?: true
    type?: true
    text?: true
    fileId?: true
    tenantId?: true
  }

  export type ContentMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    title?: true
    description?: true
    type?: true
    text?: true
    fileId?: true
    tenantId?: true
  }

  export type ContentCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    title?: true
    description?: true
    type?: true
    text?: true
    fileId?: true
    tenantId?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Content to aggregate.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithAggregationInput | ContentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _avg?: ContentAvgAggregateInputType
    _sum?: ContentSumAggregateInputType
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    title: string | null
    description: string | null
    type: $Enums.TextTypes
    text: string | null
    fileId: string | null
    tenantId: string
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    text?: boolean
    fileId?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    posts?: boolean | Content$postsArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    text?: boolean
    fileId?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    text?: boolean
    fileId?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    text?: boolean
    fileId?: boolean
    tenantId?: boolean
  }

  export type ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "title" | "description" | "type" | "text" | "fileId" | "tenantId", ExtArgs["result"]["content"]>
  export type ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    posts?: boolean | Content$postsArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Content"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      title: string | null
      description: string | null
      type: $Enums.TextTypes
      text: string | null
      fileId: string | null
      tenantId: string
    }, ExtArgs["result"]["content"]>
    composites: {}
  }

  type ContentGetPayload<S extends boolean | null | undefined | ContentDefaultArgs> = $Result.GetResult<Prisma.$ContentPayload, S>

  type ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Content'], meta: { name: 'Content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFindUniqueArgs>(args: SelectSubset<T, ContentFindUniqueArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFindFirstArgs>(args?: SelectSubset<T, ContentFindFirstArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentWithIdOnly = await prisma.content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentFindManyArgs>(args?: SelectSubset<T, ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
     */
    create<T extends ContentCreateArgs>(args: SelectSubset<T, ContentCreateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contents.
     * @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCreateManyArgs>(args?: SelectSubset<T, ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contents and returns the data saved in the database.
     * @param {ContentCreateManyAndReturnArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
     */
    delete<T extends ContentDeleteArgs>(args: SelectSubset<T, ContentDeleteArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateArgs>(args: SelectSubset<T, ContentUpdateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentDeleteManyArgs>(args?: SelectSubset<T, ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateManyArgs>(args: SelectSubset<T, ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents and returns the data updated in the database.
     * @param {ContentUpdateManyAndReturnArgs} args - Arguments to update many Contents.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpsertArgs>(args: SelectSubset<T, ContentUpsertArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Content model
   */
  readonly fields: ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends Content$postsArgs<ExtArgs> = {}>(args?: Subset<T, Content$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Content model
   */
  interface ContentFieldRefs {
    readonly id: FieldRef<"Content", 'String'>
    readonly seq: FieldRef<"Content", 'Int'>
    readonly createdAt: FieldRef<"Content", 'DateTime'>
    readonly updatedAt: FieldRef<"Content", 'DateTime'>
    readonly removedAt: FieldRef<"Content", 'DateTime'>
    readonly title: FieldRef<"Content", 'String'>
    readonly description: FieldRef<"Content", 'String'>
    readonly type: FieldRef<"Content", 'TextTypes'>
    readonly text: FieldRef<"Content", 'String'>
    readonly fileId: FieldRef<"Content", 'String'>
    readonly tenantId: FieldRef<"Content", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findUniqueOrThrow
   */
  export type ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findFirstOrThrow
   */
  export type ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findMany
   */
  export type ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Contents to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content create
   */
  export type ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Content.
     */
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }

  /**
   * Content createMany
   */
  export type ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Content createManyAndReturn
   */
  export type ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content update
   */
  export type ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Content.
     */
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content updateManyAndReturn
   */
  export type ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content upsert
   */
  export type ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Content to update in case it exists.
     */
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
     */
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }

  /**
   * Content delete
   */
  export type ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter which Content to delete.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contents to delete
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to delete.
     */
    limit?: number
  }

  /**
   * Content.posts
   */
  export type Content$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Content without action
   */
  export type ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    seq: number | null
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    seq: number | null
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    seq: number | null
    name: string | null
    size: number | null
    parentId: string | null
    mimeType: string | null
    url: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    name: string | null
    size: number | null
    parentId: string | null
    mimeType: string | null
    url: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    seq: number
    name: number
    size: number
    parentId: number
    mimeType: number
    url: number
    tenantId: number
    createdAt: number
    updatedAt: number
    removedAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    seq?: true
    size?: true
  }

  export type FileSumAggregateInputType = {
    seq?: true
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    seq?: true
    name?: true
    size?: true
    parentId?: true
    mimeType?: true
    url?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    seq?: true
    name?: true
    size?: true
    parentId?: true
    mimeType?: true
    url?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    seq?: true
    name?: true
    size?: true
    parentId?: true
    mimeType?: true
    url?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    seq: number
    name: string
    size: number
    parentId: string | null
    mimeType: string
    url: string
    tenantId: string
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    name?: boolean
    size?: boolean
    parentId?: boolean
    mimeType?: boolean
    url?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    parent?: boolean | File$parentArgs<ExtArgs>
    children?: boolean | File$childrenArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    associations?: boolean | File$associationsArgs<ExtArgs>
    classification?: boolean | File$classificationArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    name?: boolean
    size?: boolean
    parentId?: boolean
    mimeType?: boolean
    url?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    parent?: boolean | File$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    name?: boolean
    size?: boolean
    parentId?: boolean
    mimeType?: boolean
    url?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    parent?: boolean | File$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    seq?: boolean
    name?: boolean
    size?: boolean
    parentId?: boolean
    mimeType?: boolean
    url?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "name" | "size" | "parentId" | "mimeType" | "url" | "tenantId" | "createdAt" | "updatedAt" | "removedAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | File$parentArgs<ExtArgs>
    children?: boolean | File$childrenArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    associations?: boolean | File$associationsArgs<ExtArgs>
    classification?: boolean | File$classificationArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | File$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | File$parentArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      parent: Prisma.$FilePayload<ExtArgs> | null
      children: Prisma.$FilePayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      associations: Prisma.$FileAssociationPayload<ExtArgs>[]
      classification: Prisma.$FileClassificationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      name: string
      size: number
      parentId: string | null
      mimeType: string
      url: string
      tenantId: string
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends File$parentArgs<ExtArgs> = {}>(args?: Subset<T, File$parentArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends File$childrenArgs<ExtArgs> = {}>(args?: Subset<T, File$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    associations<T extends File$associationsArgs<ExtArgs> = {}>(args?: Subset<T, File$associationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classification<T extends File$classificationArgs<ExtArgs> = {}>(args?: Subset<T, File$classificationArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly seq: FieldRef<"File", 'Int'>
    readonly name: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly parentId: FieldRef<"File", 'String'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly url: FieldRef<"File", 'String'>
    readonly tenantId: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly removedAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.parent
   */
  export type File$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
  }

  /**
   * File.children
   */
  export type File$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File.associations
   */
  export type File$associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    where?: FileAssociationWhereInput
    orderBy?: FileAssociationOrderByWithRelationInput | FileAssociationOrderByWithRelationInput[]
    cursor?: FileAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileAssociationScalarFieldEnum | FileAssociationScalarFieldEnum[]
  }

  /**
   * File.classification
   */
  export type File$classificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    where?: FileClassificationWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model FileClassification
   */

  export type AggregateFileClassification = {
    _count: FileClassificationCountAggregateOutputType | null
    _avg: FileClassificationAvgAggregateOutputType | null
    _sum: FileClassificationSumAggregateOutputType | null
    _min: FileClassificationMinAggregateOutputType | null
    _max: FileClassificationMaxAggregateOutputType | null
  }

  export type FileClassificationAvgAggregateOutputType = {
    seq: number | null
  }

  export type FileClassificationSumAggregateOutputType = {
    seq: number | null
  }

  export type FileClassificationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    fileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type FileClassificationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    fileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type FileClassificationCountAggregateOutputType = {
    id: number
    seq: number
    categoryId: number
    fileId: number
    createdAt: number
    updatedAt: number
    removedAt: number
    _all: number
  }


  export type FileClassificationAvgAggregateInputType = {
    seq?: true
  }

  export type FileClassificationSumAggregateInputType = {
    seq?: true
  }

  export type FileClassificationMinAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    fileId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type FileClassificationMaxAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    fileId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type FileClassificationCountAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    fileId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    _all?: true
  }

  export type FileClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileClassification to aggregate.
     */
    where?: FileClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileClassifications to fetch.
     */
    orderBy?: FileClassificationOrderByWithRelationInput | FileClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileClassifications
    **/
    _count?: true | FileClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileClassificationMaxAggregateInputType
  }

  export type GetFileClassificationAggregateType<T extends FileClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateFileClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileClassification[P]>
      : GetScalarType<T[P], AggregateFileClassification[P]>
  }




  export type FileClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileClassificationWhereInput
    orderBy?: FileClassificationOrderByWithAggregationInput | FileClassificationOrderByWithAggregationInput[]
    by: FileClassificationScalarFieldEnum[] | FileClassificationScalarFieldEnum
    having?: FileClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileClassificationCountAggregateInputType | true
    _avg?: FileClassificationAvgAggregateInputType
    _sum?: FileClassificationSumAggregateInputType
    _min?: FileClassificationMinAggregateInputType
    _max?: FileClassificationMaxAggregateInputType
  }

  export type FileClassificationGroupByOutputType = {
    id: string
    seq: number
    categoryId: string
    fileId: string
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    _count: FileClassificationCountAggregateOutputType | null
    _avg: FileClassificationAvgAggregateOutputType | null
    _sum: FileClassificationSumAggregateOutputType | null
    _min: FileClassificationMinAggregateOutputType | null
    _max: FileClassificationMaxAggregateOutputType | null
  }

  type GetFileClassificationGroupByPayload<T extends FileClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], FileClassificationGroupByOutputType[P]>
        }
      >
    >


  export type FileClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileClassification"]>

  export type FileClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileClassification"]>

  export type FileClassificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileClassification"]>

  export type FileClassificationSelectScalar = {
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }

  export type FileClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "categoryId" | "fileId" | "createdAt" | "updatedAt" | "removedAt", ExtArgs["result"]["fileClassification"]>
  export type FileClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type FileClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type FileClassificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }

  export type $FileClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileClassification"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      file: Prisma.$FilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      categoryId: string
      fileId: string
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
    }, ExtArgs["result"]["fileClassification"]>
    composites: {}
  }

  type FileClassificationGetPayload<S extends boolean | null | undefined | FileClassificationDefaultArgs> = $Result.GetResult<Prisma.$FileClassificationPayload, S>

  type FileClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileClassificationCountAggregateInputType | true
    }

  export interface FileClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileClassification'], meta: { name: 'FileClassification' } }
    /**
     * Find zero or one FileClassification that matches the filter.
     * @param {FileClassificationFindUniqueArgs} args - Arguments to find a FileClassification
     * @example
     * // Get one FileClassification
     * const fileClassification = await prisma.fileClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileClassificationFindUniqueArgs>(args: SelectSubset<T, FileClassificationFindUniqueArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileClassificationFindUniqueOrThrowArgs} args - Arguments to find a FileClassification
     * @example
     * // Get one FileClassification
     * const fileClassification = await prisma.fileClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, FileClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileClassificationFindFirstArgs} args - Arguments to find a FileClassification
     * @example
     * // Get one FileClassification
     * const fileClassification = await prisma.fileClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileClassificationFindFirstArgs>(args?: SelectSubset<T, FileClassificationFindFirstArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileClassificationFindFirstOrThrowArgs} args - Arguments to find a FileClassification
     * @example
     * // Get one FileClassification
     * const fileClassification = await prisma.fileClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, FileClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileClassifications
     * const fileClassifications = await prisma.fileClassification.findMany()
     * 
     * // Get first 10 FileClassifications
     * const fileClassifications = await prisma.fileClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileClassificationWithIdOnly = await prisma.fileClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileClassificationFindManyArgs>(args?: SelectSubset<T, FileClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileClassification.
     * @param {FileClassificationCreateArgs} args - Arguments to create a FileClassification.
     * @example
     * // Create one FileClassification
     * const FileClassification = await prisma.fileClassification.create({
     *   data: {
     *     // ... data to create a FileClassification
     *   }
     * })
     * 
     */
    create<T extends FileClassificationCreateArgs>(args: SelectSubset<T, FileClassificationCreateArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileClassifications.
     * @param {FileClassificationCreateManyArgs} args - Arguments to create many FileClassifications.
     * @example
     * // Create many FileClassifications
     * const fileClassification = await prisma.fileClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileClassificationCreateManyArgs>(args?: SelectSubset<T, FileClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileClassifications and returns the data saved in the database.
     * @param {FileClassificationCreateManyAndReturnArgs} args - Arguments to create many FileClassifications.
     * @example
     * // Create many FileClassifications
     * const fileClassification = await prisma.fileClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileClassifications and only return the `id`
     * const fileClassificationWithIdOnly = await prisma.fileClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, FileClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileClassification.
     * @param {FileClassificationDeleteArgs} args - Arguments to delete one FileClassification.
     * @example
     * // Delete one FileClassification
     * const FileClassification = await prisma.fileClassification.delete({
     *   where: {
     *     // ... filter to delete one FileClassification
     *   }
     * })
     * 
     */
    delete<T extends FileClassificationDeleteArgs>(args: SelectSubset<T, FileClassificationDeleteArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileClassification.
     * @param {FileClassificationUpdateArgs} args - Arguments to update one FileClassification.
     * @example
     * // Update one FileClassification
     * const fileClassification = await prisma.fileClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileClassificationUpdateArgs>(args: SelectSubset<T, FileClassificationUpdateArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileClassifications.
     * @param {FileClassificationDeleteManyArgs} args - Arguments to filter FileClassifications to delete.
     * @example
     * // Delete a few FileClassifications
     * const { count } = await prisma.fileClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileClassificationDeleteManyArgs>(args?: SelectSubset<T, FileClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileClassifications
     * const fileClassification = await prisma.fileClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileClassificationUpdateManyArgs>(args: SelectSubset<T, FileClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileClassifications and returns the data updated in the database.
     * @param {FileClassificationUpdateManyAndReturnArgs} args - Arguments to update many FileClassifications.
     * @example
     * // Update many FileClassifications
     * const fileClassification = await prisma.fileClassification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileClassifications and only return the `id`
     * const fileClassificationWithIdOnly = await prisma.fileClassification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileClassificationUpdateManyAndReturnArgs>(args: SelectSubset<T, FileClassificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileClassification.
     * @param {FileClassificationUpsertArgs} args - Arguments to update or create a FileClassification.
     * @example
     * // Update or create a FileClassification
     * const fileClassification = await prisma.fileClassification.upsert({
     *   create: {
     *     // ... data to create a FileClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileClassification we want to update
     *   }
     * })
     */
    upsert<T extends FileClassificationUpsertArgs>(args: SelectSubset<T, FileClassificationUpsertArgs<ExtArgs>>): Prisma__FileClassificationClient<$Result.GetResult<Prisma.$FileClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileClassificationCountArgs} args - Arguments to filter FileClassifications to count.
     * @example
     * // Count the number of FileClassifications
     * const count = await prisma.fileClassification.count({
     *   where: {
     *     // ... the filter for the FileClassifications we want to count
     *   }
     * })
    **/
    count<T extends FileClassificationCountArgs>(
      args?: Subset<T, FileClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileClassificationAggregateArgs>(args: Subset<T, FileClassificationAggregateArgs>): Prisma.PrismaPromise<GetFileClassificationAggregateType<T>>

    /**
     * Group by FileClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileClassificationGroupByArgs['orderBy'] }
        : { orderBy?: FileClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileClassification model
   */
  readonly fields: FileClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileClassification model
   */
  interface FileClassificationFieldRefs {
    readonly id: FieldRef<"FileClassification", 'String'>
    readonly seq: FieldRef<"FileClassification", 'Int'>
    readonly categoryId: FieldRef<"FileClassification", 'String'>
    readonly fileId: FieldRef<"FileClassification", 'String'>
    readonly createdAt: FieldRef<"FileClassification", 'DateTime'>
    readonly updatedAt: FieldRef<"FileClassification", 'DateTime'>
    readonly removedAt: FieldRef<"FileClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileClassification findUnique
   */
  export type FileClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * Filter, which FileClassification to fetch.
     */
    where: FileClassificationWhereUniqueInput
  }

  /**
   * FileClassification findUniqueOrThrow
   */
  export type FileClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * Filter, which FileClassification to fetch.
     */
    where: FileClassificationWhereUniqueInput
  }

  /**
   * FileClassification findFirst
   */
  export type FileClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * Filter, which FileClassification to fetch.
     */
    where?: FileClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileClassifications to fetch.
     */
    orderBy?: FileClassificationOrderByWithRelationInput | FileClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileClassifications.
     */
    cursor?: FileClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileClassifications.
     */
    distinct?: FileClassificationScalarFieldEnum | FileClassificationScalarFieldEnum[]
  }

  /**
   * FileClassification findFirstOrThrow
   */
  export type FileClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * Filter, which FileClassification to fetch.
     */
    where?: FileClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileClassifications to fetch.
     */
    orderBy?: FileClassificationOrderByWithRelationInput | FileClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileClassifications.
     */
    cursor?: FileClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileClassifications.
     */
    distinct?: FileClassificationScalarFieldEnum | FileClassificationScalarFieldEnum[]
  }

  /**
   * FileClassification findMany
   */
  export type FileClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * Filter, which FileClassifications to fetch.
     */
    where?: FileClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileClassifications to fetch.
     */
    orderBy?: FileClassificationOrderByWithRelationInput | FileClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileClassifications.
     */
    cursor?: FileClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileClassifications.
     */
    skip?: number
    distinct?: FileClassificationScalarFieldEnum | FileClassificationScalarFieldEnum[]
  }

  /**
   * FileClassification create
   */
  export type FileClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a FileClassification.
     */
    data: XOR<FileClassificationCreateInput, FileClassificationUncheckedCreateInput>
  }

  /**
   * FileClassification createMany
   */
  export type FileClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileClassifications.
     */
    data: FileClassificationCreateManyInput | FileClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileClassification createManyAndReturn
   */
  export type FileClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many FileClassifications.
     */
    data: FileClassificationCreateManyInput | FileClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileClassification update
   */
  export type FileClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a FileClassification.
     */
    data: XOR<FileClassificationUpdateInput, FileClassificationUncheckedUpdateInput>
    /**
     * Choose, which FileClassification to update.
     */
    where: FileClassificationWhereUniqueInput
  }

  /**
   * FileClassification updateMany
   */
  export type FileClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileClassifications.
     */
    data: XOR<FileClassificationUpdateManyMutationInput, FileClassificationUncheckedUpdateManyInput>
    /**
     * Filter which FileClassifications to update
     */
    where?: FileClassificationWhereInput
    /**
     * Limit how many FileClassifications to update.
     */
    limit?: number
  }

  /**
   * FileClassification updateManyAndReturn
   */
  export type FileClassificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * The data used to update FileClassifications.
     */
    data: XOR<FileClassificationUpdateManyMutationInput, FileClassificationUncheckedUpdateManyInput>
    /**
     * Filter which FileClassifications to update
     */
    where?: FileClassificationWhereInput
    /**
     * Limit how many FileClassifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileClassification upsert
   */
  export type FileClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the FileClassification to update in case it exists.
     */
    where: FileClassificationWhereUniqueInput
    /**
     * In case the FileClassification found by the `where` argument doesn't exist, create a new FileClassification with this data.
     */
    create: XOR<FileClassificationCreateInput, FileClassificationUncheckedCreateInput>
    /**
     * In case the FileClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileClassificationUpdateInput, FileClassificationUncheckedUpdateInput>
  }

  /**
   * FileClassification delete
   */
  export type FileClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
    /**
     * Filter which FileClassification to delete.
     */
    where: FileClassificationWhereUniqueInput
  }

  /**
   * FileClassification deleteMany
   */
  export type FileClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileClassifications to delete
     */
    where?: FileClassificationWhereInput
    /**
     * Limit how many FileClassifications to delete.
     */
    limit?: number
  }

  /**
   * FileClassification without action
   */
  export type FileClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileClassification
     */
    select?: FileClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileClassification
     */
    omit?: FileClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileClassificationInclude<ExtArgs> | null
  }


  /**
   * Model FileAssociation
   */

  export type AggregateFileAssociation = {
    _count: FileAssociationCountAggregateOutputType | null
    _avg: FileAssociationAvgAggregateOutputType | null
    _sum: FileAssociationSumAggregateOutputType | null
    _min: FileAssociationMinAggregateOutputType | null
    _max: FileAssociationMaxAggregateOutputType | null
  }

  export type FileAssociationAvgAggregateOutputType = {
    seq: number | null
  }

  export type FileAssociationSumAggregateOutputType = {
    seq: number | null
  }

  export type FileAssociationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    fileId: string | null
    groupId: string | null
  }

  export type FileAssociationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    fileId: string | null
    groupId: string | null
  }

  export type FileAssociationCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    fileId: number
    groupId: number
    _all: number
  }


  export type FileAssociationAvgAggregateInputType = {
    seq?: true
  }

  export type FileAssociationSumAggregateInputType = {
    seq?: true
  }

  export type FileAssociationMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    fileId?: true
    groupId?: true
  }

  export type FileAssociationMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    fileId?: true
    groupId?: true
  }

  export type FileAssociationCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    fileId?: true
    groupId?: true
    _all?: true
  }

  export type FileAssociationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileAssociation to aggregate.
     */
    where?: FileAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssociations to fetch.
     */
    orderBy?: FileAssociationOrderByWithRelationInput | FileAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileAssociations
    **/
    _count?: true | FileAssociationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAssociationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileAssociationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileAssociationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileAssociationMaxAggregateInputType
  }

  export type GetFileAssociationAggregateType<T extends FileAssociationAggregateArgs> = {
        [P in keyof T & keyof AggregateFileAssociation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileAssociation[P]>
      : GetScalarType<T[P], AggregateFileAssociation[P]>
  }




  export type FileAssociationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAssociationWhereInput
    orderBy?: FileAssociationOrderByWithAggregationInput | FileAssociationOrderByWithAggregationInput[]
    by: FileAssociationScalarFieldEnum[] | FileAssociationScalarFieldEnum
    having?: FileAssociationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileAssociationCountAggregateInputType | true
    _avg?: FileAssociationAvgAggregateInputType
    _sum?: FileAssociationSumAggregateInputType
    _min?: FileAssociationMinAggregateInputType
    _max?: FileAssociationMaxAggregateInputType
  }

  export type FileAssociationGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    fileId: string
    groupId: string
    _count: FileAssociationCountAggregateOutputType | null
    _avg: FileAssociationAvgAggregateOutputType | null
    _sum: FileAssociationSumAggregateOutputType | null
    _min: FileAssociationMinAggregateOutputType | null
    _max: FileAssociationMaxAggregateOutputType | null
  }

  type GetFileAssociationGroupByPayload<T extends FileAssociationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileAssociationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileAssociationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileAssociationGroupByOutputType[P]>
            : GetScalarType<T[P], FileAssociationGroupByOutputType[P]>
        }
      >
    >


  export type FileAssociationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    fileId?: boolean
    groupId?: boolean
    file?: boolean | FileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileAssociation"]>

  export type FileAssociationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    fileId?: boolean
    groupId?: boolean
    file?: boolean | FileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileAssociation"]>

  export type FileAssociationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    fileId?: boolean
    groupId?: boolean
    file?: boolean | FileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileAssociation"]>

  export type FileAssociationSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    fileId?: boolean
    groupId?: boolean
  }

  export type FileAssociationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "fileId" | "groupId", ExtArgs["result"]["fileAssociation"]>
  export type FileAssociationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type FileAssociationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type FileAssociationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $FileAssociationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileAssociation"
    objects: {
      file: Prisma.$FilePayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      fileId: string
      groupId: string
    }, ExtArgs["result"]["fileAssociation"]>
    composites: {}
  }

  type FileAssociationGetPayload<S extends boolean | null | undefined | FileAssociationDefaultArgs> = $Result.GetResult<Prisma.$FileAssociationPayload, S>

  type FileAssociationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileAssociationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileAssociationCountAggregateInputType | true
    }

  export interface FileAssociationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileAssociation'], meta: { name: 'FileAssociation' } }
    /**
     * Find zero or one FileAssociation that matches the filter.
     * @param {FileAssociationFindUniqueArgs} args - Arguments to find a FileAssociation
     * @example
     * // Get one FileAssociation
     * const fileAssociation = await prisma.fileAssociation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileAssociationFindUniqueArgs>(args: SelectSubset<T, FileAssociationFindUniqueArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileAssociation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileAssociationFindUniqueOrThrowArgs} args - Arguments to find a FileAssociation
     * @example
     * // Get one FileAssociation
     * const fileAssociation = await prisma.fileAssociation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileAssociationFindUniqueOrThrowArgs>(args: SelectSubset<T, FileAssociationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileAssociation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssociationFindFirstArgs} args - Arguments to find a FileAssociation
     * @example
     * // Get one FileAssociation
     * const fileAssociation = await prisma.fileAssociation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileAssociationFindFirstArgs>(args?: SelectSubset<T, FileAssociationFindFirstArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileAssociation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssociationFindFirstOrThrowArgs} args - Arguments to find a FileAssociation
     * @example
     * // Get one FileAssociation
     * const fileAssociation = await prisma.fileAssociation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileAssociationFindFirstOrThrowArgs>(args?: SelectSubset<T, FileAssociationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileAssociations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssociationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileAssociations
     * const fileAssociations = await prisma.fileAssociation.findMany()
     * 
     * // Get first 10 FileAssociations
     * const fileAssociations = await prisma.fileAssociation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileAssociationWithIdOnly = await prisma.fileAssociation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileAssociationFindManyArgs>(args?: SelectSubset<T, FileAssociationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileAssociation.
     * @param {FileAssociationCreateArgs} args - Arguments to create a FileAssociation.
     * @example
     * // Create one FileAssociation
     * const FileAssociation = await prisma.fileAssociation.create({
     *   data: {
     *     // ... data to create a FileAssociation
     *   }
     * })
     * 
     */
    create<T extends FileAssociationCreateArgs>(args: SelectSubset<T, FileAssociationCreateArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileAssociations.
     * @param {FileAssociationCreateManyArgs} args - Arguments to create many FileAssociations.
     * @example
     * // Create many FileAssociations
     * const fileAssociation = await prisma.fileAssociation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileAssociationCreateManyArgs>(args?: SelectSubset<T, FileAssociationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileAssociations and returns the data saved in the database.
     * @param {FileAssociationCreateManyAndReturnArgs} args - Arguments to create many FileAssociations.
     * @example
     * // Create many FileAssociations
     * const fileAssociation = await prisma.fileAssociation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileAssociations and only return the `id`
     * const fileAssociationWithIdOnly = await prisma.fileAssociation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileAssociationCreateManyAndReturnArgs>(args?: SelectSubset<T, FileAssociationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileAssociation.
     * @param {FileAssociationDeleteArgs} args - Arguments to delete one FileAssociation.
     * @example
     * // Delete one FileAssociation
     * const FileAssociation = await prisma.fileAssociation.delete({
     *   where: {
     *     // ... filter to delete one FileAssociation
     *   }
     * })
     * 
     */
    delete<T extends FileAssociationDeleteArgs>(args: SelectSubset<T, FileAssociationDeleteArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileAssociation.
     * @param {FileAssociationUpdateArgs} args - Arguments to update one FileAssociation.
     * @example
     * // Update one FileAssociation
     * const fileAssociation = await prisma.fileAssociation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileAssociationUpdateArgs>(args: SelectSubset<T, FileAssociationUpdateArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileAssociations.
     * @param {FileAssociationDeleteManyArgs} args - Arguments to filter FileAssociations to delete.
     * @example
     * // Delete a few FileAssociations
     * const { count } = await prisma.fileAssociation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileAssociationDeleteManyArgs>(args?: SelectSubset<T, FileAssociationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssociationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileAssociations
     * const fileAssociation = await prisma.fileAssociation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileAssociationUpdateManyArgs>(args: SelectSubset<T, FileAssociationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileAssociations and returns the data updated in the database.
     * @param {FileAssociationUpdateManyAndReturnArgs} args - Arguments to update many FileAssociations.
     * @example
     * // Update many FileAssociations
     * const fileAssociation = await prisma.fileAssociation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileAssociations and only return the `id`
     * const fileAssociationWithIdOnly = await prisma.fileAssociation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileAssociationUpdateManyAndReturnArgs>(args: SelectSubset<T, FileAssociationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileAssociation.
     * @param {FileAssociationUpsertArgs} args - Arguments to update or create a FileAssociation.
     * @example
     * // Update or create a FileAssociation
     * const fileAssociation = await prisma.fileAssociation.upsert({
     *   create: {
     *     // ... data to create a FileAssociation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileAssociation we want to update
     *   }
     * })
     */
    upsert<T extends FileAssociationUpsertArgs>(args: SelectSubset<T, FileAssociationUpsertArgs<ExtArgs>>): Prisma__FileAssociationClient<$Result.GetResult<Prisma.$FileAssociationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssociationCountArgs} args - Arguments to filter FileAssociations to count.
     * @example
     * // Count the number of FileAssociations
     * const count = await prisma.fileAssociation.count({
     *   where: {
     *     // ... the filter for the FileAssociations we want to count
     *   }
     * })
    **/
    count<T extends FileAssociationCountArgs>(
      args?: Subset<T, FileAssociationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileAssociationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssociationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAssociationAggregateArgs>(args: Subset<T, FileAssociationAggregateArgs>): Prisma.PrismaPromise<GetFileAssociationAggregateType<T>>

    /**
     * Group by FileAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssociationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileAssociationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileAssociationGroupByArgs['orderBy'] }
        : { orderBy?: FileAssociationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileAssociationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileAssociationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileAssociation model
   */
  readonly fields: FileAssociationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileAssociation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileAssociationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileAssociation model
   */
  interface FileAssociationFieldRefs {
    readonly id: FieldRef<"FileAssociation", 'String'>
    readonly seq: FieldRef<"FileAssociation", 'Int'>
    readonly createdAt: FieldRef<"FileAssociation", 'DateTime'>
    readonly updatedAt: FieldRef<"FileAssociation", 'DateTime'>
    readonly removedAt: FieldRef<"FileAssociation", 'DateTime'>
    readonly fileId: FieldRef<"FileAssociation", 'String'>
    readonly groupId: FieldRef<"FileAssociation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FileAssociation findUnique
   */
  export type FileAssociationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * Filter, which FileAssociation to fetch.
     */
    where: FileAssociationWhereUniqueInput
  }

  /**
   * FileAssociation findUniqueOrThrow
   */
  export type FileAssociationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * Filter, which FileAssociation to fetch.
     */
    where: FileAssociationWhereUniqueInput
  }

  /**
   * FileAssociation findFirst
   */
  export type FileAssociationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * Filter, which FileAssociation to fetch.
     */
    where?: FileAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssociations to fetch.
     */
    orderBy?: FileAssociationOrderByWithRelationInput | FileAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileAssociations.
     */
    cursor?: FileAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileAssociations.
     */
    distinct?: FileAssociationScalarFieldEnum | FileAssociationScalarFieldEnum[]
  }

  /**
   * FileAssociation findFirstOrThrow
   */
  export type FileAssociationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * Filter, which FileAssociation to fetch.
     */
    where?: FileAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssociations to fetch.
     */
    orderBy?: FileAssociationOrderByWithRelationInput | FileAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileAssociations.
     */
    cursor?: FileAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileAssociations.
     */
    distinct?: FileAssociationScalarFieldEnum | FileAssociationScalarFieldEnum[]
  }

  /**
   * FileAssociation findMany
   */
  export type FileAssociationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * Filter, which FileAssociations to fetch.
     */
    where?: FileAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssociations to fetch.
     */
    orderBy?: FileAssociationOrderByWithRelationInput | FileAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileAssociations.
     */
    cursor?: FileAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssociations.
     */
    skip?: number
    distinct?: FileAssociationScalarFieldEnum | FileAssociationScalarFieldEnum[]
  }

  /**
   * FileAssociation create
   */
  export type FileAssociationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * The data needed to create a FileAssociation.
     */
    data: XOR<FileAssociationCreateInput, FileAssociationUncheckedCreateInput>
  }

  /**
   * FileAssociation createMany
   */
  export type FileAssociationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileAssociations.
     */
    data: FileAssociationCreateManyInput | FileAssociationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileAssociation createManyAndReturn
   */
  export type FileAssociationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * The data used to create many FileAssociations.
     */
    data: FileAssociationCreateManyInput | FileAssociationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileAssociation update
   */
  export type FileAssociationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * The data needed to update a FileAssociation.
     */
    data: XOR<FileAssociationUpdateInput, FileAssociationUncheckedUpdateInput>
    /**
     * Choose, which FileAssociation to update.
     */
    where: FileAssociationWhereUniqueInput
  }

  /**
   * FileAssociation updateMany
   */
  export type FileAssociationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileAssociations.
     */
    data: XOR<FileAssociationUpdateManyMutationInput, FileAssociationUncheckedUpdateManyInput>
    /**
     * Filter which FileAssociations to update
     */
    where?: FileAssociationWhereInput
    /**
     * Limit how many FileAssociations to update.
     */
    limit?: number
  }

  /**
   * FileAssociation updateManyAndReturn
   */
  export type FileAssociationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * The data used to update FileAssociations.
     */
    data: XOR<FileAssociationUpdateManyMutationInput, FileAssociationUncheckedUpdateManyInput>
    /**
     * Filter which FileAssociations to update
     */
    where?: FileAssociationWhereInput
    /**
     * Limit how many FileAssociations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileAssociation upsert
   */
  export type FileAssociationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * The filter to search for the FileAssociation to update in case it exists.
     */
    where: FileAssociationWhereUniqueInput
    /**
     * In case the FileAssociation found by the `where` argument doesn't exist, create a new FileAssociation with this data.
     */
    create: XOR<FileAssociationCreateInput, FileAssociationUncheckedCreateInput>
    /**
     * In case the FileAssociation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileAssociationUpdateInput, FileAssociationUncheckedUpdateInput>
  }

  /**
   * FileAssociation delete
   */
  export type FileAssociationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
    /**
     * Filter which FileAssociation to delete.
     */
    where: FileAssociationWhereUniqueInput
  }

  /**
   * FileAssociation deleteMany
   */
  export type FileAssociationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileAssociations to delete
     */
    where?: FileAssociationWhereInput
    /**
     * Limit how many FileAssociations to delete.
     */
    limit?: number
  }

  /**
   * FileAssociation without action
   */
  export type FileAssociationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAssociation
     */
    select?: FileAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileAssociation
     */
    omit?: FileAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAssociationInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    seq: number | null
  }

  export type RoleSumAggregateOutputType = {
    seq: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: $Enums.Roles | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: $Enums.Roles | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    seq?: true
  }

  export type RoleSumAggregateInputType = {
    seq?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: $Enums.Roles
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    abilities?: boolean | Role$abilitiesArgs<ExtArgs>
    assignments?: boolean | Role$assignmentsArgs<ExtArgs>
    associations?: boolean | Role$associationsArgs<ExtArgs>
    classification?: boolean | Role$classificationArgs<ExtArgs>
    tenants?: boolean | Role$tenantsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilities?: boolean | Role$abilitiesArgs<ExtArgs>
    assignments?: boolean | Role$assignmentsArgs<ExtArgs>
    associations?: boolean | Role$associationsArgs<ExtArgs>
    classification?: boolean | Role$classificationArgs<ExtArgs>
    tenants?: boolean | Role$tenantsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      abilities: Prisma.$AbilityPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      associations: Prisma.$RoleAssociationPayload<ExtArgs>[]
      classification: Prisma.$RoleClassificationPayload<ExtArgs> | null
      tenants: Prisma.$TenantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: $Enums.Roles
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abilities<T extends Role$abilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Role$abilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends Role$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Role$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    associations<T extends Role$associationsArgs<ExtArgs> = {}>(args?: Subset<T, Role$associationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classification<T extends Role$classificationArgs<ExtArgs> = {}>(args?: Subset<T, Role$classificationArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenants<T extends Role$tenantsArgs<ExtArgs> = {}>(args?: Subset<T, Role$tenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly seq: FieldRef<"Role", 'Int'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly removedAt: FieldRef<"Role", 'DateTime'>
    readonly name: FieldRef<"Role", 'Roles'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data?: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.abilities
   */
  export type Role$abilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    where?: AbilityWhereInput
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    cursor?: AbilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * Role.assignments
   */
  export type Role$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Role.associations
   */
  export type Role$associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    where?: RoleAssociationWhereInput
    orderBy?: RoleAssociationOrderByWithRelationInput | RoleAssociationOrderByWithRelationInput[]
    cursor?: RoleAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleAssociationScalarFieldEnum | RoleAssociationScalarFieldEnum[]
  }

  /**
   * Role.classification
   */
  export type Role$classificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    where?: RoleClassificationWhereInput
  }

  /**
   * Role.tenants
   */
  export type Role$tenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model RoleAssociation
   */

  export type AggregateRoleAssociation = {
    _count: RoleAssociationCountAggregateOutputType | null
    _avg: RoleAssociationAvgAggregateOutputType | null
    _sum: RoleAssociationSumAggregateOutputType | null
    _min: RoleAssociationMinAggregateOutputType | null
    _max: RoleAssociationMaxAggregateOutputType | null
  }

  export type RoleAssociationAvgAggregateOutputType = {
    seq: number | null
  }

  export type RoleAssociationSumAggregateOutputType = {
    seq: number | null
  }

  export type RoleAssociationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    roleId: string | null
    groupId: string | null
  }

  export type RoleAssociationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    roleId: string | null
    groupId: string | null
  }

  export type RoleAssociationCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    roleId: number
    groupId: number
    _all: number
  }


  export type RoleAssociationAvgAggregateInputType = {
    seq?: true
  }

  export type RoleAssociationSumAggregateInputType = {
    seq?: true
  }

  export type RoleAssociationMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    roleId?: true
    groupId?: true
  }

  export type RoleAssociationMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    roleId?: true
    groupId?: true
  }

  export type RoleAssociationCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    roleId?: true
    groupId?: true
    _all?: true
  }

  export type RoleAssociationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleAssociation to aggregate.
     */
    where?: RoleAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssociations to fetch.
     */
    orderBy?: RoleAssociationOrderByWithRelationInput | RoleAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleAssociations
    **/
    _count?: true | RoleAssociationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAssociationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleAssociationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleAssociationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleAssociationMaxAggregateInputType
  }

  export type GetRoleAssociationAggregateType<T extends RoleAssociationAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleAssociation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleAssociation[P]>
      : GetScalarType<T[P], AggregateRoleAssociation[P]>
  }




  export type RoleAssociationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssociationWhereInput
    orderBy?: RoleAssociationOrderByWithAggregationInput | RoleAssociationOrderByWithAggregationInput[]
    by: RoleAssociationScalarFieldEnum[] | RoleAssociationScalarFieldEnum
    having?: RoleAssociationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleAssociationCountAggregateInputType | true
    _avg?: RoleAssociationAvgAggregateInputType
    _sum?: RoleAssociationSumAggregateInputType
    _min?: RoleAssociationMinAggregateInputType
    _max?: RoleAssociationMaxAggregateInputType
  }

  export type RoleAssociationGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    roleId: string
    groupId: string
    _count: RoleAssociationCountAggregateOutputType | null
    _avg: RoleAssociationAvgAggregateOutputType | null
    _sum: RoleAssociationSumAggregateOutputType | null
    _min: RoleAssociationMinAggregateOutputType | null
    _max: RoleAssociationMaxAggregateOutputType | null
  }

  type GetRoleAssociationGroupByPayload<T extends RoleAssociationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleAssociationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleAssociationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleAssociationGroupByOutputType[P]>
            : GetScalarType<T[P], RoleAssociationGroupByOutputType[P]>
        }
      >
    >


  export type RoleAssociationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssociation"]>

  export type RoleAssociationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssociation"]>

  export type RoleAssociationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssociation"]>

  export type RoleAssociationSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    roleId?: boolean
    groupId?: boolean
  }

  export type RoleAssociationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "roleId" | "groupId", ExtArgs["result"]["roleAssociation"]>
  export type RoleAssociationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RoleAssociationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RoleAssociationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $RoleAssociationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleAssociation"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      roleId: string
      groupId: string
    }, ExtArgs["result"]["roleAssociation"]>
    composites: {}
  }

  type RoleAssociationGetPayload<S extends boolean | null | undefined | RoleAssociationDefaultArgs> = $Result.GetResult<Prisma.$RoleAssociationPayload, S>

  type RoleAssociationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleAssociationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleAssociationCountAggregateInputType | true
    }

  export interface RoleAssociationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleAssociation'], meta: { name: 'RoleAssociation' } }
    /**
     * Find zero or one RoleAssociation that matches the filter.
     * @param {RoleAssociationFindUniqueArgs} args - Arguments to find a RoleAssociation
     * @example
     * // Get one RoleAssociation
     * const roleAssociation = await prisma.roleAssociation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleAssociationFindUniqueArgs>(args: SelectSubset<T, RoleAssociationFindUniqueArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleAssociation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleAssociationFindUniqueOrThrowArgs} args - Arguments to find a RoleAssociation
     * @example
     * // Get one RoleAssociation
     * const roleAssociation = await prisma.roleAssociation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleAssociationFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleAssociationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleAssociation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssociationFindFirstArgs} args - Arguments to find a RoleAssociation
     * @example
     * // Get one RoleAssociation
     * const roleAssociation = await prisma.roleAssociation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleAssociationFindFirstArgs>(args?: SelectSubset<T, RoleAssociationFindFirstArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleAssociation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssociationFindFirstOrThrowArgs} args - Arguments to find a RoleAssociation
     * @example
     * // Get one RoleAssociation
     * const roleAssociation = await prisma.roleAssociation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleAssociationFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleAssociationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleAssociations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssociationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleAssociations
     * const roleAssociations = await prisma.roleAssociation.findMany()
     * 
     * // Get first 10 RoleAssociations
     * const roleAssociations = await prisma.roleAssociation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleAssociationWithIdOnly = await prisma.roleAssociation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleAssociationFindManyArgs>(args?: SelectSubset<T, RoleAssociationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleAssociation.
     * @param {RoleAssociationCreateArgs} args - Arguments to create a RoleAssociation.
     * @example
     * // Create one RoleAssociation
     * const RoleAssociation = await prisma.roleAssociation.create({
     *   data: {
     *     // ... data to create a RoleAssociation
     *   }
     * })
     * 
     */
    create<T extends RoleAssociationCreateArgs>(args: SelectSubset<T, RoleAssociationCreateArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleAssociations.
     * @param {RoleAssociationCreateManyArgs} args - Arguments to create many RoleAssociations.
     * @example
     * // Create many RoleAssociations
     * const roleAssociation = await prisma.roleAssociation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleAssociationCreateManyArgs>(args?: SelectSubset<T, RoleAssociationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleAssociations and returns the data saved in the database.
     * @param {RoleAssociationCreateManyAndReturnArgs} args - Arguments to create many RoleAssociations.
     * @example
     * // Create many RoleAssociations
     * const roleAssociation = await prisma.roleAssociation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleAssociations and only return the `id`
     * const roleAssociationWithIdOnly = await prisma.roleAssociation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleAssociationCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleAssociationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleAssociation.
     * @param {RoleAssociationDeleteArgs} args - Arguments to delete one RoleAssociation.
     * @example
     * // Delete one RoleAssociation
     * const RoleAssociation = await prisma.roleAssociation.delete({
     *   where: {
     *     // ... filter to delete one RoleAssociation
     *   }
     * })
     * 
     */
    delete<T extends RoleAssociationDeleteArgs>(args: SelectSubset<T, RoleAssociationDeleteArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleAssociation.
     * @param {RoleAssociationUpdateArgs} args - Arguments to update one RoleAssociation.
     * @example
     * // Update one RoleAssociation
     * const roleAssociation = await prisma.roleAssociation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleAssociationUpdateArgs>(args: SelectSubset<T, RoleAssociationUpdateArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleAssociations.
     * @param {RoleAssociationDeleteManyArgs} args - Arguments to filter RoleAssociations to delete.
     * @example
     * // Delete a few RoleAssociations
     * const { count } = await prisma.roleAssociation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleAssociationDeleteManyArgs>(args?: SelectSubset<T, RoleAssociationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssociationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleAssociations
     * const roleAssociation = await prisma.roleAssociation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleAssociationUpdateManyArgs>(args: SelectSubset<T, RoleAssociationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleAssociations and returns the data updated in the database.
     * @param {RoleAssociationUpdateManyAndReturnArgs} args - Arguments to update many RoleAssociations.
     * @example
     * // Update many RoleAssociations
     * const roleAssociation = await prisma.roleAssociation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleAssociations and only return the `id`
     * const roleAssociationWithIdOnly = await prisma.roleAssociation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleAssociationUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleAssociationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleAssociation.
     * @param {RoleAssociationUpsertArgs} args - Arguments to update or create a RoleAssociation.
     * @example
     * // Update or create a RoleAssociation
     * const roleAssociation = await prisma.roleAssociation.upsert({
     *   create: {
     *     // ... data to create a RoleAssociation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleAssociation we want to update
     *   }
     * })
     */
    upsert<T extends RoleAssociationUpsertArgs>(args: SelectSubset<T, RoleAssociationUpsertArgs<ExtArgs>>): Prisma__RoleAssociationClient<$Result.GetResult<Prisma.$RoleAssociationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssociationCountArgs} args - Arguments to filter RoleAssociations to count.
     * @example
     * // Count the number of RoleAssociations
     * const count = await prisma.roleAssociation.count({
     *   where: {
     *     // ... the filter for the RoleAssociations we want to count
     *   }
     * })
    **/
    count<T extends RoleAssociationCountArgs>(
      args?: Subset<T, RoleAssociationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleAssociationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssociationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAssociationAggregateArgs>(args: Subset<T, RoleAssociationAggregateArgs>): Prisma.PrismaPromise<GetRoleAssociationAggregateType<T>>

    /**
     * Group by RoleAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssociationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleAssociationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleAssociationGroupByArgs['orderBy'] }
        : { orderBy?: RoleAssociationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleAssociationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleAssociationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleAssociation model
   */
  readonly fields: RoleAssociationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleAssociation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleAssociationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleAssociation model
   */
  interface RoleAssociationFieldRefs {
    readonly id: FieldRef<"RoleAssociation", 'String'>
    readonly seq: FieldRef<"RoleAssociation", 'Int'>
    readonly createdAt: FieldRef<"RoleAssociation", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleAssociation", 'DateTime'>
    readonly removedAt: FieldRef<"RoleAssociation", 'DateTime'>
    readonly roleId: FieldRef<"RoleAssociation", 'String'>
    readonly groupId: FieldRef<"RoleAssociation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoleAssociation findUnique
   */
  export type RoleAssociationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssociation to fetch.
     */
    where: RoleAssociationWhereUniqueInput
  }

  /**
   * RoleAssociation findUniqueOrThrow
   */
  export type RoleAssociationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssociation to fetch.
     */
    where: RoleAssociationWhereUniqueInput
  }

  /**
   * RoleAssociation findFirst
   */
  export type RoleAssociationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssociation to fetch.
     */
    where?: RoleAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssociations to fetch.
     */
    orderBy?: RoleAssociationOrderByWithRelationInput | RoleAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleAssociations.
     */
    cursor?: RoleAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleAssociations.
     */
    distinct?: RoleAssociationScalarFieldEnum | RoleAssociationScalarFieldEnum[]
  }

  /**
   * RoleAssociation findFirstOrThrow
   */
  export type RoleAssociationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssociation to fetch.
     */
    where?: RoleAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssociations to fetch.
     */
    orderBy?: RoleAssociationOrderByWithRelationInput | RoleAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleAssociations.
     */
    cursor?: RoleAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleAssociations.
     */
    distinct?: RoleAssociationScalarFieldEnum | RoleAssociationScalarFieldEnum[]
  }

  /**
   * RoleAssociation findMany
   */
  export type RoleAssociationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssociations to fetch.
     */
    where?: RoleAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssociations to fetch.
     */
    orderBy?: RoleAssociationOrderByWithRelationInput | RoleAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleAssociations.
     */
    cursor?: RoleAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssociations.
     */
    skip?: number
    distinct?: RoleAssociationScalarFieldEnum | RoleAssociationScalarFieldEnum[]
  }

  /**
   * RoleAssociation create
   */
  export type RoleAssociationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleAssociation.
     */
    data: XOR<RoleAssociationCreateInput, RoleAssociationUncheckedCreateInput>
  }

  /**
   * RoleAssociation createMany
   */
  export type RoleAssociationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleAssociations.
     */
    data: RoleAssociationCreateManyInput | RoleAssociationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleAssociation createManyAndReturn
   */
  export type RoleAssociationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * The data used to create many RoleAssociations.
     */
    data: RoleAssociationCreateManyInput | RoleAssociationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleAssociation update
   */
  export type RoleAssociationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleAssociation.
     */
    data: XOR<RoleAssociationUpdateInput, RoleAssociationUncheckedUpdateInput>
    /**
     * Choose, which RoleAssociation to update.
     */
    where: RoleAssociationWhereUniqueInput
  }

  /**
   * RoleAssociation updateMany
   */
  export type RoleAssociationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleAssociations.
     */
    data: XOR<RoleAssociationUpdateManyMutationInput, RoleAssociationUncheckedUpdateManyInput>
    /**
     * Filter which RoleAssociations to update
     */
    where?: RoleAssociationWhereInput
    /**
     * Limit how many RoleAssociations to update.
     */
    limit?: number
  }

  /**
   * RoleAssociation updateManyAndReturn
   */
  export type RoleAssociationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * The data used to update RoleAssociations.
     */
    data: XOR<RoleAssociationUpdateManyMutationInput, RoleAssociationUncheckedUpdateManyInput>
    /**
     * Filter which RoleAssociations to update
     */
    where?: RoleAssociationWhereInput
    /**
     * Limit how many RoleAssociations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleAssociation upsert
   */
  export type RoleAssociationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleAssociation to update in case it exists.
     */
    where: RoleAssociationWhereUniqueInput
    /**
     * In case the RoleAssociation found by the `where` argument doesn't exist, create a new RoleAssociation with this data.
     */
    create: XOR<RoleAssociationCreateInput, RoleAssociationUncheckedCreateInput>
    /**
     * In case the RoleAssociation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleAssociationUpdateInput, RoleAssociationUncheckedUpdateInput>
  }

  /**
   * RoleAssociation delete
   */
  export type RoleAssociationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
    /**
     * Filter which RoleAssociation to delete.
     */
    where: RoleAssociationWhereUniqueInput
  }

  /**
   * RoleAssociation deleteMany
   */
  export type RoleAssociationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleAssociations to delete
     */
    where?: RoleAssociationWhereInput
    /**
     * Limit how many RoleAssociations to delete.
     */
    limit?: number
  }

  /**
   * RoleAssociation without action
   */
  export type RoleAssociationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssociation
     */
    select?: RoleAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssociation
     */
    omit?: RoleAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssociationInclude<ExtArgs> | null
  }


  /**
   * Model RoleClassification
   */

  export type AggregateRoleClassification = {
    _count: RoleClassificationCountAggregateOutputType | null
    _avg: RoleClassificationAvgAggregateOutputType | null
    _sum: RoleClassificationSumAggregateOutputType | null
    _min: RoleClassificationMinAggregateOutputType | null
    _max: RoleClassificationMaxAggregateOutputType | null
  }

  export type RoleClassificationAvgAggregateOutputType = {
    seq: number | null
  }

  export type RoleClassificationSumAggregateOutputType = {
    seq: number | null
  }

  export type RoleClassificationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type RoleClassificationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type RoleClassificationCountAggregateOutputType = {
    id: number
    seq: number
    categoryId: number
    roleId: number
    createdAt: number
    updatedAt: number
    removedAt: number
    _all: number
  }


  export type RoleClassificationAvgAggregateInputType = {
    seq?: true
  }

  export type RoleClassificationSumAggregateInputType = {
    seq?: true
  }

  export type RoleClassificationMinAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type RoleClassificationMaxAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type RoleClassificationCountAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    _all?: true
  }

  export type RoleClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleClassification to aggregate.
     */
    where?: RoleClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleClassifications to fetch.
     */
    orderBy?: RoleClassificationOrderByWithRelationInput | RoleClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleClassifications
    **/
    _count?: true | RoleClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleClassificationMaxAggregateInputType
  }

  export type GetRoleClassificationAggregateType<T extends RoleClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleClassification[P]>
      : GetScalarType<T[P], AggregateRoleClassification[P]>
  }




  export type RoleClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleClassificationWhereInput
    orderBy?: RoleClassificationOrderByWithAggregationInput | RoleClassificationOrderByWithAggregationInput[]
    by: RoleClassificationScalarFieldEnum[] | RoleClassificationScalarFieldEnum
    having?: RoleClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleClassificationCountAggregateInputType | true
    _avg?: RoleClassificationAvgAggregateInputType
    _sum?: RoleClassificationSumAggregateInputType
    _min?: RoleClassificationMinAggregateInputType
    _max?: RoleClassificationMaxAggregateInputType
  }

  export type RoleClassificationGroupByOutputType = {
    id: string
    seq: number
    categoryId: string
    roleId: string
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    _count: RoleClassificationCountAggregateOutputType | null
    _avg: RoleClassificationAvgAggregateOutputType | null
    _sum: RoleClassificationSumAggregateOutputType | null
    _min: RoleClassificationMinAggregateOutputType | null
    _max: RoleClassificationMaxAggregateOutputType | null
  }

  type GetRoleClassificationGroupByPayload<T extends RoleClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], RoleClassificationGroupByOutputType[P]>
        }
      >
    >


  export type RoleClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleClassification"]>

  export type RoleClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleClassification"]>

  export type RoleClassificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleClassification"]>

  export type RoleClassificationSelectScalar = {
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }

  export type RoleClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "categoryId" | "roleId" | "createdAt" | "updatedAt" | "removedAt", ExtArgs["result"]["roleClassification"]>
  export type RoleClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RoleClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RoleClassificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $RoleClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleClassification"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      categoryId: string
      roleId: string
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
    }, ExtArgs["result"]["roleClassification"]>
    composites: {}
  }

  type RoleClassificationGetPayload<S extends boolean | null | undefined | RoleClassificationDefaultArgs> = $Result.GetResult<Prisma.$RoleClassificationPayload, S>

  type RoleClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleClassificationCountAggregateInputType | true
    }

  export interface RoleClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleClassification'], meta: { name: 'RoleClassification' } }
    /**
     * Find zero or one RoleClassification that matches the filter.
     * @param {RoleClassificationFindUniqueArgs} args - Arguments to find a RoleClassification
     * @example
     * // Get one RoleClassification
     * const roleClassification = await prisma.roleClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleClassificationFindUniqueArgs>(args: SelectSubset<T, RoleClassificationFindUniqueArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleClassificationFindUniqueOrThrowArgs} args - Arguments to find a RoleClassification
     * @example
     * // Get one RoleClassification
     * const roleClassification = await prisma.roleClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleClassificationFindFirstArgs} args - Arguments to find a RoleClassification
     * @example
     * // Get one RoleClassification
     * const roleClassification = await prisma.roleClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleClassificationFindFirstArgs>(args?: SelectSubset<T, RoleClassificationFindFirstArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleClassificationFindFirstOrThrowArgs} args - Arguments to find a RoleClassification
     * @example
     * // Get one RoleClassification
     * const roleClassification = await prisma.roleClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleClassifications
     * const roleClassifications = await prisma.roleClassification.findMany()
     * 
     * // Get first 10 RoleClassifications
     * const roleClassifications = await prisma.roleClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleClassificationWithIdOnly = await prisma.roleClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleClassificationFindManyArgs>(args?: SelectSubset<T, RoleClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleClassification.
     * @param {RoleClassificationCreateArgs} args - Arguments to create a RoleClassification.
     * @example
     * // Create one RoleClassification
     * const RoleClassification = await prisma.roleClassification.create({
     *   data: {
     *     // ... data to create a RoleClassification
     *   }
     * })
     * 
     */
    create<T extends RoleClassificationCreateArgs>(args: SelectSubset<T, RoleClassificationCreateArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleClassifications.
     * @param {RoleClassificationCreateManyArgs} args - Arguments to create many RoleClassifications.
     * @example
     * // Create many RoleClassifications
     * const roleClassification = await prisma.roleClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleClassificationCreateManyArgs>(args?: SelectSubset<T, RoleClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleClassifications and returns the data saved in the database.
     * @param {RoleClassificationCreateManyAndReturnArgs} args - Arguments to create many RoleClassifications.
     * @example
     * // Create many RoleClassifications
     * const roleClassification = await prisma.roleClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleClassifications and only return the `id`
     * const roleClassificationWithIdOnly = await prisma.roleClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleClassification.
     * @param {RoleClassificationDeleteArgs} args - Arguments to delete one RoleClassification.
     * @example
     * // Delete one RoleClassification
     * const RoleClassification = await prisma.roleClassification.delete({
     *   where: {
     *     // ... filter to delete one RoleClassification
     *   }
     * })
     * 
     */
    delete<T extends RoleClassificationDeleteArgs>(args: SelectSubset<T, RoleClassificationDeleteArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleClassification.
     * @param {RoleClassificationUpdateArgs} args - Arguments to update one RoleClassification.
     * @example
     * // Update one RoleClassification
     * const roleClassification = await prisma.roleClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleClassificationUpdateArgs>(args: SelectSubset<T, RoleClassificationUpdateArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleClassifications.
     * @param {RoleClassificationDeleteManyArgs} args - Arguments to filter RoleClassifications to delete.
     * @example
     * // Delete a few RoleClassifications
     * const { count } = await prisma.roleClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleClassificationDeleteManyArgs>(args?: SelectSubset<T, RoleClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleClassifications
     * const roleClassification = await prisma.roleClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleClassificationUpdateManyArgs>(args: SelectSubset<T, RoleClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleClassifications and returns the data updated in the database.
     * @param {RoleClassificationUpdateManyAndReturnArgs} args - Arguments to update many RoleClassifications.
     * @example
     * // Update many RoleClassifications
     * const roleClassification = await prisma.roleClassification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleClassifications and only return the `id`
     * const roleClassificationWithIdOnly = await prisma.roleClassification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleClassificationUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleClassificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleClassification.
     * @param {RoleClassificationUpsertArgs} args - Arguments to update or create a RoleClassification.
     * @example
     * // Update or create a RoleClassification
     * const roleClassification = await prisma.roleClassification.upsert({
     *   create: {
     *     // ... data to create a RoleClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleClassification we want to update
     *   }
     * })
     */
    upsert<T extends RoleClassificationUpsertArgs>(args: SelectSubset<T, RoleClassificationUpsertArgs<ExtArgs>>): Prisma__RoleClassificationClient<$Result.GetResult<Prisma.$RoleClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleClassificationCountArgs} args - Arguments to filter RoleClassifications to count.
     * @example
     * // Count the number of RoleClassifications
     * const count = await prisma.roleClassification.count({
     *   where: {
     *     // ... the filter for the RoleClassifications we want to count
     *   }
     * })
    **/
    count<T extends RoleClassificationCountArgs>(
      args?: Subset<T, RoleClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleClassificationAggregateArgs>(args: Subset<T, RoleClassificationAggregateArgs>): Prisma.PrismaPromise<GetRoleClassificationAggregateType<T>>

    /**
     * Group by RoleClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleClassificationGroupByArgs['orderBy'] }
        : { orderBy?: RoleClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleClassification model
   */
  readonly fields: RoleClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleClassification model
   */
  interface RoleClassificationFieldRefs {
    readonly id: FieldRef<"RoleClassification", 'String'>
    readonly seq: FieldRef<"RoleClassification", 'Int'>
    readonly categoryId: FieldRef<"RoleClassification", 'String'>
    readonly roleId: FieldRef<"RoleClassification", 'String'>
    readonly createdAt: FieldRef<"RoleClassification", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleClassification", 'DateTime'>
    readonly removedAt: FieldRef<"RoleClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleClassification findUnique
   */
  export type RoleClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * Filter, which RoleClassification to fetch.
     */
    where: RoleClassificationWhereUniqueInput
  }

  /**
   * RoleClassification findUniqueOrThrow
   */
  export type RoleClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * Filter, which RoleClassification to fetch.
     */
    where: RoleClassificationWhereUniqueInput
  }

  /**
   * RoleClassification findFirst
   */
  export type RoleClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * Filter, which RoleClassification to fetch.
     */
    where?: RoleClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleClassifications to fetch.
     */
    orderBy?: RoleClassificationOrderByWithRelationInput | RoleClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleClassifications.
     */
    cursor?: RoleClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleClassifications.
     */
    distinct?: RoleClassificationScalarFieldEnum | RoleClassificationScalarFieldEnum[]
  }

  /**
   * RoleClassification findFirstOrThrow
   */
  export type RoleClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * Filter, which RoleClassification to fetch.
     */
    where?: RoleClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleClassifications to fetch.
     */
    orderBy?: RoleClassificationOrderByWithRelationInput | RoleClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleClassifications.
     */
    cursor?: RoleClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleClassifications.
     */
    distinct?: RoleClassificationScalarFieldEnum | RoleClassificationScalarFieldEnum[]
  }

  /**
   * RoleClassification findMany
   */
  export type RoleClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * Filter, which RoleClassifications to fetch.
     */
    where?: RoleClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleClassifications to fetch.
     */
    orderBy?: RoleClassificationOrderByWithRelationInput | RoleClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleClassifications.
     */
    cursor?: RoleClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleClassifications.
     */
    skip?: number
    distinct?: RoleClassificationScalarFieldEnum | RoleClassificationScalarFieldEnum[]
  }

  /**
   * RoleClassification create
   */
  export type RoleClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleClassification.
     */
    data: XOR<RoleClassificationCreateInput, RoleClassificationUncheckedCreateInput>
  }

  /**
   * RoleClassification createMany
   */
  export type RoleClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleClassifications.
     */
    data: RoleClassificationCreateManyInput | RoleClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleClassification createManyAndReturn
   */
  export type RoleClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many RoleClassifications.
     */
    data: RoleClassificationCreateManyInput | RoleClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleClassification update
   */
  export type RoleClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleClassification.
     */
    data: XOR<RoleClassificationUpdateInput, RoleClassificationUncheckedUpdateInput>
    /**
     * Choose, which RoleClassification to update.
     */
    where: RoleClassificationWhereUniqueInput
  }

  /**
   * RoleClassification updateMany
   */
  export type RoleClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleClassifications.
     */
    data: XOR<RoleClassificationUpdateManyMutationInput, RoleClassificationUncheckedUpdateManyInput>
    /**
     * Filter which RoleClassifications to update
     */
    where?: RoleClassificationWhereInput
    /**
     * Limit how many RoleClassifications to update.
     */
    limit?: number
  }

  /**
   * RoleClassification updateManyAndReturn
   */
  export type RoleClassificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * The data used to update RoleClassifications.
     */
    data: XOR<RoleClassificationUpdateManyMutationInput, RoleClassificationUncheckedUpdateManyInput>
    /**
     * Filter which RoleClassifications to update
     */
    where?: RoleClassificationWhereInput
    /**
     * Limit how many RoleClassifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleClassification upsert
   */
  export type RoleClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleClassification to update in case it exists.
     */
    where: RoleClassificationWhereUniqueInput
    /**
     * In case the RoleClassification found by the `where` argument doesn't exist, create a new RoleClassification with this data.
     */
    create: XOR<RoleClassificationCreateInput, RoleClassificationUncheckedCreateInput>
    /**
     * In case the RoleClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleClassificationUpdateInput, RoleClassificationUncheckedUpdateInput>
  }

  /**
   * RoleClassification delete
   */
  export type RoleClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
    /**
     * Filter which RoleClassification to delete.
     */
    where: RoleClassificationWhereUniqueInput
  }

  /**
   * RoleClassification deleteMany
   */
  export type RoleClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleClassifications to delete
     */
    where?: RoleClassificationWhereInput
    /**
     * Limit how many RoleClassifications to delete.
     */
    limit?: number
  }

  /**
   * RoleClassification without action
   */
  export type RoleClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleClassification
     */
    select?: RoleClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleClassification
     */
    omit?: RoleClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleClassificationInclude<ExtArgs> | null
  }


  /**
   * Model Space
   */

  export type AggregateSpace = {
    _count: SpaceCountAggregateOutputType | null
    _avg: SpaceAvgAggregateOutputType | null
    _sum: SpaceSumAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  export type SpaceAvgAggregateOutputType = {
    seq: number | null
  }

  export type SpaceSumAggregateOutputType = {
    seq: number | null
  }

  export type SpaceMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type SpaceMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type SpaceCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    _all: number
  }


  export type SpaceAvgAggregateInputType = {
    seq?: true
  }

  export type SpaceSumAggregateInputType = {
    seq?: true
  }

  export type SpaceMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type SpaceMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type SpaceCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    _all?: true
  }

  export type SpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Space to aggregate.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spaces
    **/
    _count?: true | SpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMaxAggregateInputType
  }

  export type GetSpaceAggregateType<T extends SpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpace[P]>
      : GetScalarType<T[P], AggregateSpace[P]>
  }




  export type SpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithAggregationInput | SpaceOrderByWithAggregationInput[]
    by: SpaceScalarFieldEnum[] | SpaceScalarFieldEnum
    having?: SpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceCountAggregateInputType | true
    _avg?: SpaceAvgAggregateInputType
    _sum?: SpaceSumAggregateInputType
    _min?: SpaceMinAggregateInputType
    _max?: SpaceMaxAggregateInputType
  }

  export type SpaceGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    _count: SpaceCountAggregateOutputType | null
    _avg: SpaceAvgAggregateOutputType | null
    _sum: SpaceSumAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  type GetSpaceGroupByPayload<T extends SpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceGroupByOutputType[P]>
        }
      >
    >


  export type SpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    ground?: boolean | Space$groundArgs<ExtArgs>
    associations?: boolean | Space$associationsArgs<ExtArgs>
    classification?: boolean | Space$classificationArgs<ExtArgs>
    tenants?: boolean | Space$tenantsArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }

  export type SpaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt", ExtArgs["result"]["space"]>
  export type SpaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ground?: boolean | Space$groundArgs<ExtArgs>
    associations?: boolean | Space$associationsArgs<ExtArgs>
    classification?: boolean | Space$classificationArgs<ExtArgs>
    tenants?: boolean | Space$tenantsArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SpaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Space"
    objects: {
      ground: Prisma.$GroundPayload<ExtArgs> | null
      associations: Prisma.$SpaceAssociationPayload<ExtArgs>[]
      classification: Prisma.$SpaceClassificationPayload<ExtArgs> | null
      tenants: Prisma.$TenantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
    }, ExtArgs["result"]["space"]>
    composites: {}
  }

  type SpaceGetPayload<S extends boolean | null | undefined | SpaceDefaultArgs> = $Result.GetResult<Prisma.$SpacePayload, S>

  type SpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpaceCountAggregateInputType | true
    }

  export interface SpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Space'], meta: { name: 'Space' } }
    /**
     * Find zero or one Space that matches the filter.
     * @param {SpaceFindUniqueArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceFindUniqueArgs>(args: SelectSubset<T, SpaceFindUniqueArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Space that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpaceFindUniqueOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Space that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceFindFirstArgs>(args?: SelectSubset<T, SpaceFindFirstArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Space that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spaces
     * const spaces = await prisma.space.findMany()
     * 
     * // Get first 10 Spaces
     * const spaces = await prisma.space.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceWithIdOnly = await prisma.space.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceFindManyArgs>(args?: SelectSubset<T, SpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Space.
     * @param {SpaceCreateArgs} args - Arguments to create a Space.
     * @example
     * // Create one Space
     * const Space = await prisma.space.create({
     *   data: {
     *     // ... data to create a Space
     *   }
     * })
     * 
     */
    create<T extends SpaceCreateArgs>(args: SelectSubset<T, SpaceCreateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spaces.
     * @param {SpaceCreateManyArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceCreateManyArgs>(args?: SelectSubset<T, SpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spaces and returns the data saved in the database.
     * @param {SpaceCreateManyAndReturnArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spaces and only return the `id`
     * const spaceWithIdOnly = await prisma.space.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaceCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Space.
     * @param {SpaceDeleteArgs} args - Arguments to delete one Space.
     * @example
     * // Delete one Space
     * const Space = await prisma.space.delete({
     *   where: {
     *     // ... filter to delete one Space
     *   }
     * })
     * 
     */
    delete<T extends SpaceDeleteArgs>(args: SelectSubset<T, SpaceDeleteArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Space.
     * @param {SpaceUpdateArgs} args - Arguments to update one Space.
     * @example
     * // Update one Space
     * const space = await prisma.space.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceUpdateArgs>(args: SelectSubset<T, SpaceUpdateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spaces.
     * @param {SpaceDeleteManyArgs} args - Arguments to filter Spaces to delete.
     * @example
     * // Delete a few Spaces
     * const { count } = await prisma.space.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceDeleteManyArgs>(args?: SelectSubset<T, SpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceUpdateManyArgs>(args: SelectSubset<T, SpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces and returns the data updated in the database.
     * @param {SpaceUpdateManyAndReturnArgs} args - Arguments to update many Spaces.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spaces and only return the `id`
     * const spaceWithIdOnly = await prisma.space.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpaceUpdateManyAndReturnArgs>(args: SelectSubset<T, SpaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Space.
     * @param {SpaceUpsertArgs} args - Arguments to update or create a Space.
     * @example
     * // Update or create a Space
     * const space = await prisma.space.upsert({
     *   create: {
     *     // ... data to create a Space
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Space we want to update
     *   }
     * })
     */
    upsert<T extends SpaceUpsertArgs>(args: SelectSubset<T, SpaceUpsertArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceCountArgs} args - Arguments to filter Spaces to count.
     * @example
     * // Count the number of Spaces
     * const count = await prisma.space.count({
     *   where: {
     *     // ... the filter for the Spaces we want to count
     *   }
     * })
    **/
    count<T extends SpaceCountArgs>(
      args?: Subset<T, SpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceAggregateArgs>(args: Subset<T, SpaceAggregateArgs>): Prisma.PrismaPromise<GetSpaceAggregateType<T>>

    /**
     * Group by Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceGroupByArgs['orderBy'] }
        : { orderBy?: SpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Space model
   */
  readonly fields: SpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Space.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ground<T extends Space$groundArgs<ExtArgs> = {}>(args?: Subset<T, Space$groundArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    associations<T extends Space$associationsArgs<ExtArgs> = {}>(args?: Subset<T, Space$associationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classification<T extends Space$classificationArgs<ExtArgs> = {}>(args?: Subset<T, Space$classificationArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenants<T extends Space$tenantsArgs<ExtArgs> = {}>(args?: Subset<T, Space$tenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Space model
   */
  interface SpaceFieldRefs {
    readonly id: FieldRef<"Space", 'String'>
    readonly seq: FieldRef<"Space", 'Int'>
    readonly createdAt: FieldRef<"Space", 'DateTime'>
    readonly updatedAt: FieldRef<"Space", 'DateTime'>
    readonly removedAt: FieldRef<"Space", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Space findUnique
   */
  export type SpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findUniqueOrThrow
   */
  export type SpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findFirst
   */
  export type SpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findFirstOrThrow
   */
  export type SpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findMany
   */
  export type SpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Spaces to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space create
   */
  export type SpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Space.
     */
    data?: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
  }

  /**
   * Space createMany
   */
  export type SpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Space createManyAndReturn
   */
  export type SpaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Space update
   */
  export type SpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Space.
     */
    data: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
    /**
     * Choose, which Space to update.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space updateMany
   */
  export type SpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to update.
     */
    limit?: number
  }

  /**
   * Space updateManyAndReturn
   */
  export type SpaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to update.
     */
    limit?: number
  }

  /**
   * Space upsert
   */
  export type SpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Space to update in case it exists.
     */
    where: SpaceWhereUniqueInput
    /**
     * In case the Space found by the `where` argument doesn't exist, create a new Space with this data.
     */
    create: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
    /**
     * In case the Space was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
  }

  /**
   * Space delete
   */
  export type SpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter which Space to delete.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space deleteMany
   */
  export type SpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spaces to delete
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to delete.
     */
    limit?: number
  }

  /**
   * Space.ground
   */
  export type Space$groundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    where?: GroundWhereInput
  }

  /**
   * Space.associations
   */
  export type Space$associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    where?: SpaceAssociationWhereInput
    orderBy?: SpaceAssociationOrderByWithRelationInput | SpaceAssociationOrderByWithRelationInput[]
    cursor?: SpaceAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceAssociationScalarFieldEnum | SpaceAssociationScalarFieldEnum[]
  }

  /**
   * Space.classification
   */
  export type Space$classificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    where?: SpaceClassificationWhereInput
  }

  /**
   * Space.tenants
   */
  export type Space$tenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Space without action
   */
  export type SpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
  }


  /**
   * Model SpaceClassification
   */

  export type AggregateSpaceClassification = {
    _count: SpaceClassificationCountAggregateOutputType | null
    _avg: SpaceClassificationAvgAggregateOutputType | null
    _sum: SpaceClassificationSumAggregateOutputType | null
    _min: SpaceClassificationMinAggregateOutputType | null
    _max: SpaceClassificationMaxAggregateOutputType | null
  }

  export type SpaceClassificationAvgAggregateOutputType = {
    seq: number | null
  }

  export type SpaceClassificationSumAggregateOutputType = {
    seq: number | null
  }

  export type SpaceClassificationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    spaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type SpaceClassificationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    spaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type SpaceClassificationCountAggregateOutputType = {
    id: number
    seq: number
    categoryId: number
    spaceId: number
    createdAt: number
    updatedAt: number
    removedAt: number
    _all: number
  }


  export type SpaceClassificationAvgAggregateInputType = {
    seq?: true
  }

  export type SpaceClassificationSumAggregateInputType = {
    seq?: true
  }

  export type SpaceClassificationMinAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type SpaceClassificationMaxAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type SpaceClassificationCountAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    _all?: true
  }

  export type SpaceClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceClassification to aggregate.
     */
    where?: SpaceClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceClassifications to fetch.
     */
    orderBy?: SpaceClassificationOrderByWithRelationInput | SpaceClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpaceClassifications
    **/
    _count?: true | SpaceClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpaceClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpaceClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceClassificationMaxAggregateInputType
  }

  export type GetSpaceClassificationAggregateType<T extends SpaceClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSpaceClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpaceClassification[P]>
      : GetScalarType<T[P], AggregateSpaceClassification[P]>
  }




  export type SpaceClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceClassificationWhereInput
    orderBy?: SpaceClassificationOrderByWithAggregationInput | SpaceClassificationOrderByWithAggregationInput[]
    by: SpaceClassificationScalarFieldEnum[] | SpaceClassificationScalarFieldEnum
    having?: SpaceClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceClassificationCountAggregateInputType | true
    _avg?: SpaceClassificationAvgAggregateInputType
    _sum?: SpaceClassificationSumAggregateInputType
    _min?: SpaceClassificationMinAggregateInputType
    _max?: SpaceClassificationMaxAggregateInputType
  }

  export type SpaceClassificationGroupByOutputType = {
    id: string
    seq: number
    categoryId: string
    spaceId: string
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    _count: SpaceClassificationCountAggregateOutputType | null
    _avg: SpaceClassificationAvgAggregateOutputType | null
    _sum: SpaceClassificationSumAggregateOutputType | null
    _min: SpaceClassificationMinAggregateOutputType | null
    _max: SpaceClassificationMaxAggregateOutputType | null
  }

  type GetSpaceClassificationGroupByPayload<T extends SpaceClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceClassificationGroupByOutputType[P]>
        }
      >
    >


  export type SpaceClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceClassification"]>

  export type SpaceClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceClassification"]>

  export type SpaceClassificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceClassification"]>

  export type SpaceClassificationSelectScalar = {
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }

  export type SpaceClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "categoryId" | "spaceId" | "createdAt" | "updatedAt" | "removedAt", ExtArgs["result"]["spaceClassification"]>
  export type SpaceClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }
  export type SpaceClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }
  export type SpaceClassificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }

  export type $SpaceClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpaceClassification"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      space: Prisma.$SpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      categoryId: string
      spaceId: string
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
    }, ExtArgs["result"]["spaceClassification"]>
    composites: {}
  }

  type SpaceClassificationGetPayload<S extends boolean | null | undefined | SpaceClassificationDefaultArgs> = $Result.GetResult<Prisma.$SpaceClassificationPayload, S>

  type SpaceClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpaceClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpaceClassificationCountAggregateInputType | true
    }

  export interface SpaceClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpaceClassification'], meta: { name: 'SpaceClassification' } }
    /**
     * Find zero or one SpaceClassification that matches the filter.
     * @param {SpaceClassificationFindUniqueArgs} args - Arguments to find a SpaceClassification
     * @example
     * // Get one SpaceClassification
     * const spaceClassification = await prisma.spaceClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceClassificationFindUniqueArgs>(args: SelectSubset<T, SpaceClassificationFindUniqueArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpaceClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpaceClassificationFindUniqueOrThrowArgs} args - Arguments to find a SpaceClassification
     * @example
     * // Get one SpaceClassification
     * const spaceClassification = await prisma.spaceClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpaceClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceClassificationFindFirstArgs} args - Arguments to find a SpaceClassification
     * @example
     * // Get one SpaceClassification
     * const spaceClassification = await prisma.spaceClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceClassificationFindFirstArgs>(args?: SelectSubset<T, SpaceClassificationFindFirstArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpaceClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceClassificationFindFirstOrThrowArgs} args - Arguments to find a SpaceClassification
     * @example
     * // Get one SpaceClassification
     * const spaceClassification = await prisma.spaceClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpaceClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpaceClassifications
     * const spaceClassifications = await prisma.spaceClassification.findMany()
     * 
     * // Get first 10 SpaceClassifications
     * const spaceClassifications = await prisma.spaceClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceClassificationWithIdOnly = await prisma.spaceClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceClassificationFindManyArgs>(args?: SelectSubset<T, SpaceClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpaceClassification.
     * @param {SpaceClassificationCreateArgs} args - Arguments to create a SpaceClassification.
     * @example
     * // Create one SpaceClassification
     * const SpaceClassification = await prisma.spaceClassification.create({
     *   data: {
     *     // ... data to create a SpaceClassification
     *   }
     * })
     * 
     */
    create<T extends SpaceClassificationCreateArgs>(args: SelectSubset<T, SpaceClassificationCreateArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpaceClassifications.
     * @param {SpaceClassificationCreateManyArgs} args - Arguments to create many SpaceClassifications.
     * @example
     * // Create many SpaceClassifications
     * const spaceClassification = await prisma.spaceClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceClassificationCreateManyArgs>(args?: SelectSubset<T, SpaceClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpaceClassifications and returns the data saved in the database.
     * @param {SpaceClassificationCreateManyAndReturnArgs} args - Arguments to create many SpaceClassifications.
     * @example
     * // Create many SpaceClassifications
     * const spaceClassification = await prisma.spaceClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpaceClassifications and only return the `id`
     * const spaceClassificationWithIdOnly = await prisma.spaceClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaceClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaceClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpaceClassification.
     * @param {SpaceClassificationDeleteArgs} args - Arguments to delete one SpaceClassification.
     * @example
     * // Delete one SpaceClassification
     * const SpaceClassification = await prisma.spaceClassification.delete({
     *   where: {
     *     // ... filter to delete one SpaceClassification
     *   }
     * })
     * 
     */
    delete<T extends SpaceClassificationDeleteArgs>(args: SelectSubset<T, SpaceClassificationDeleteArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpaceClassification.
     * @param {SpaceClassificationUpdateArgs} args - Arguments to update one SpaceClassification.
     * @example
     * // Update one SpaceClassification
     * const spaceClassification = await prisma.spaceClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceClassificationUpdateArgs>(args: SelectSubset<T, SpaceClassificationUpdateArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpaceClassifications.
     * @param {SpaceClassificationDeleteManyArgs} args - Arguments to filter SpaceClassifications to delete.
     * @example
     * // Delete a few SpaceClassifications
     * const { count } = await prisma.spaceClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceClassificationDeleteManyArgs>(args?: SelectSubset<T, SpaceClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaceClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpaceClassifications
     * const spaceClassification = await prisma.spaceClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceClassificationUpdateManyArgs>(args: SelectSubset<T, SpaceClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaceClassifications and returns the data updated in the database.
     * @param {SpaceClassificationUpdateManyAndReturnArgs} args - Arguments to update many SpaceClassifications.
     * @example
     * // Update many SpaceClassifications
     * const spaceClassification = await prisma.spaceClassification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpaceClassifications and only return the `id`
     * const spaceClassificationWithIdOnly = await prisma.spaceClassification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpaceClassificationUpdateManyAndReturnArgs>(args: SelectSubset<T, SpaceClassificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpaceClassification.
     * @param {SpaceClassificationUpsertArgs} args - Arguments to update or create a SpaceClassification.
     * @example
     * // Update or create a SpaceClassification
     * const spaceClassification = await prisma.spaceClassification.upsert({
     *   create: {
     *     // ... data to create a SpaceClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpaceClassification we want to update
     *   }
     * })
     */
    upsert<T extends SpaceClassificationUpsertArgs>(args: SelectSubset<T, SpaceClassificationUpsertArgs<ExtArgs>>): Prisma__SpaceClassificationClient<$Result.GetResult<Prisma.$SpaceClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpaceClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceClassificationCountArgs} args - Arguments to filter SpaceClassifications to count.
     * @example
     * // Count the number of SpaceClassifications
     * const count = await prisma.spaceClassification.count({
     *   where: {
     *     // ... the filter for the SpaceClassifications we want to count
     *   }
     * })
    **/
    count<T extends SpaceClassificationCountArgs>(
      args?: Subset<T, SpaceClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpaceClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceClassificationAggregateArgs>(args: Subset<T, SpaceClassificationAggregateArgs>): Prisma.PrismaPromise<GetSpaceClassificationAggregateType<T>>

    /**
     * Group by SpaceClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceClassificationGroupByArgs['orderBy'] }
        : { orderBy?: SpaceClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpaceClassification model
   */
  readonly fields: SpaceClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpaceClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpaceClassification model
   */
  interface SpaceClassificationFieldRefs {
    readonly id: FieldRef<"SpaceClassification", 'String'>
    readonly seq: FieldRef<"SpaceClassification", 'Int'>
    readonly categoryId: FieldRef<"SpaceClassification", 'String'>
    readonly spaceId: FieldRef<"SpaceClassification", 'String'>
    readonly createdAt: FieldRef<"SpaceClassification", 'DateTime'>
    readonly updatedAt: FieldRef<"SpaceClassification", 'DateTime'>
    readonly removedAt: FieldRef<"SpaceClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpaceClassification findUnique
   */
  export type SpaceClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceClassification to fetch.
     */
    where: SpaceClassificationWhereUniqueInput
  }

  /**
   * SpaceClassification findUniqueOrThrow
   */
  export type SpaceClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceClassification to fetch.
     */
    where: SpaceClassificationWhereUniqueInput
  }

  /**
   * SpaceClassification findFirst
   */
  export type SpaceClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceClassification to fetch.
     */
    where?: SpaceClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceClassifications to fetch.
     */
    orderBy?: SpaceClassificationOrderByWithRelationInput | SpaceClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceClassifications.
     */
    cursor?: SpaceClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceClassifications.
     */
    distinct?: SpaceClassificationScalarFieldEnum | SpaceClassificationScalarFieldEnum[]
  }

  /**
   * SpaceClassification findFirstOrThrow
   */
  export type SpaceClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceClassification to fetch.
     */
    where?: SpaceClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceClassifications to fetch.
     */
    orderBy?: SpaceClassificationOrderByWithRelationInput | SpaceClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceClassifications.
     */
    cursor?: SpaceClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceClassifications.
     */
    distinct?: SpaceClassificationScalarFieldEnum | SpaceClassificationScalarFieldEnum[]
  }

  /**
   * SpaceClassification findMany
   */
  export type SpaceClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceClassifications to fetch.
     */
    where?: SpaceClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceClassifications to fetch.
     */
    orderBy?: SpaceClassificationOrderByWithRelationInput | SpaceClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpaceClassifications.
     */
    cursor?: SpaceClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceClassifications.
     */
    skip?: number
    distinct?: SpaceClassificationScalarFieldEnum | SpaceClassificationScalarFieldEnum[]
  }

  /**
   * SpaceClassification create
   */
  export type SpaceClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SpaceClassification.
     */
    data: XOR<SpaceClassificationCreateInput, SpaceClassificationUncheckedCreateInput>
  }

  /**
   * SpaceClassification createMany
   */
  export type SpaceClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpaceClassifications.
     */
    data: SpaceClassificationCreateManyInput | SpaceClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpaceClassification createManyAndReturn
   */
  export type SpaceClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many SpaceClassifications.
     */
    data: SpaceClassificationCreateManyInput | SpaceClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpaceClassification update
   */
  export type SpaceClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SpaceClassification.
     */
    data: XOR<SpaceClassificationUpdateInput, SpaceClassificationUncheckedUpdateInput>
    /**
     * Choose, which SpaceClassification to update.
     */
    where: SpaceClassificationWhereUniqueInput
  }

  /**
   * SpaceClassification updateMany
   */
  export type SpaceClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpaceClassifications.
     */
    data: XOR<SpaceClassificationUpdateManyMutationInput, SpaceClassificationUncheckedUpdateManyInput>
    /**
     * Filter which SpaceClassifications to update
     */
    where?: SpaceClassificationWhereInput
    /**
     * Limit how many SpaceClassifications to update.
     */
    limit?: number
  }

  /**
   * SpaceClassification updateManyAndReturn
   */
  export type SpaceClassificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * The data used to update SpaceClassifications.
     */
    data: XOR<SpaceClassificationUpdateManyMutationInput, SpaceClassificationUncheckedUpdateManyInput>
    /**
     * Filter which SpaceClassifications to update
     */
    where?: SpaceClassificationWhereInput
    /**
     * Limit how many SpaceClassifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpaceClassification upsert
   */
  export type SpaceClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SpaceClassification to update in case it exists.
     */
    where: SpaceClassificationWhereUniqueInput
    /**
     * In case the SpaceClassification found by the `where` argument doesn't exist, create a new SpaceClassification with this data.
     */
    create: XOR<SpaceClassificationCreateInput, SpaceClassificationUncheckedCreateInput>
    /**
     * In case the SpaceClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceClassificationUpdateInput, SpaceClassificationUncheckedUpdateInput>
  }

  /**
   * SpaceClassification delete
   */
  export type SpaceClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
    /**
     * Filter which SpaceClassification to delete.
     */
    where: SpaceClassificationWhereUniqueInput
  }

  /**
   * SpaceClassification deleteMany
   */
  export type SpaceClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceClassifications to delete
     */
    where?: SpaceClassificationWhereInput
    /**
     * Limit how many SpaceClassifications to delete.
     */
    limit?: number
  }

  /**
   * SpaceClassification without action
   */
  export type SpaceClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceClassification
     */
    select?: SpaceClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceClassification
     */
    omit?: SpaceClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceClassificationInclude<ExtArgs> | null
  }


  /**
   * Model SpaceAssociation
   */

  export type AggregateSpaceAssociation = {
    _count: SpaceAssociationCountAggregateOutputType | null
    _avg: SpaceAssociationAvgAggregateOutputType | null
    _sum: SpaceAssociationSumAggregateOutputType | null
    _min: SpaceAssociationMinAggregateOutputType | null
    _max: SpaceAssociationMaxAggregateOutputType | null
  }

  export type SpaceAssociationAvgAggregateOutputType = {
    seq: number | null
  }

  export type SpaceAssociationSumAggregateOutputType = {
    seq: number | null
  }

  export type SpaceAssociationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    spaceId: string | null
    groupId: string | null
  }

  export type SpaceAssociationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    spaceId: string | null
    groupId: string | null
  }

  export type SpaceAssociationCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    spaceId: number
    groupId: number
    _all: number
  }


  export type SpaceAssociationAvgAggregateInputType = {
    seq?: true
  }

  export type SpaceAssociationSumAggregateInputType = {
    seq?: true
  }

  export type SpaceAssociationMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    spaceId?: true
    groupId?: true
  }

  export type SpaceAssociationMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    spaceId?: true
    groupId?: true
  }

  export type SpaceAssociationCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    spaceId?: true
    groupId?: true
    _all?: true
  }

  export type SpaceAssociationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceAssociation to aggregate.
     */
    where?: SpaceAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceAssociations to fetch.
     */
    orderBy?: SpaceAssociationOrderByWithRelationInput | SpaceAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpaceAssociations
    **/
    _count?: true | SpaceAssociationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpaceAssociationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpaceAssociationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceAssociationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceAssociationMaxAggregateInputType
  }

  export type GetSpaceAssociationAggregateType<T extends SpaceAssociationAggregateArgs> = {
        [P in keyof T & keyof AggregateSpaceAssociation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpaceAssociation[P]>
      : GetScalarType<T[P], AggregateSpaceAssociation[P]>
  }




  export type SpaceAssociationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceAssociationWhereInput
    orderBy?: SpaceAssociationOrderByWithAggregationInput | SpaceAssociationOrderByWithAggregationInput[]
    by: SpaceAssociationScalarFieldEnum[] | SpaceAssociationScalarFieldEnum
    having?: SpaceAssociationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceAssociationCountAggregateInputType | true
    _avg?: SpaceAssociationAvgAggregateInputType
    _sum?: SpaceAssociationSumAggregateInputType
    _min?: SpaceAssociationMinAggregateInputType
    _max?: SpaceAssociationMaxAggregateInputType
  }

  export type SpaceAssociationGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    spaceId: string
    groupId: string
    _count: SpaceAssociationCountAggregateOutputType | null
    _avg: SpaceAssociationAvgAggregateOutputType | null
    _sum: SpaceAssociationSumAggregateOutputType | null
    _min: SpaceAssociationMinAggregateOutputType | null
    _max: SpaceAssociationMaxAggregateOutputType | null
  }

  type GetSpaceAssociationGroupByPayload<T extends SpaceAssociationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceAssociationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceAssociationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceAssociationGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceAssociationGroupByOutputType[P]>
        }
      >
    >


  export type SpaceAssociationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    spaceId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceAssociation"]>

  export type SpaceAssociationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    spaceId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceAssociation"]>

  export type SpaceAssociationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    spaceId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceAssociation"]>

  export type SpaceAssociationSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    spaceId?: boolean
    groupId?: boolean
  }

  export type SpaceAssociationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "spaceId" | "groupId", ExtArgs["result"]["spaceAssociation"]>
  export type SpaceAssociationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }
  export type SpaceAssociationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }
  export type SpaceAssociationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }

  export type $SpaceAssociationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpaceAssociation"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      space: Prisma.$SpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      spaceId: string
      groupId: string
    }, ExtArgs["result"]["spaceAssociation"]>
    composites: {}
  }

  type SpaceAssociationGetPayload<S extends boolean | null | undefined | SpaceAssociationDefaultArgs> = $Result.GetResult<Prisma.$SpaceAssociationPayload, S>

  type SpaceAssociationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpaceAssociationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpaceAssociationCountAggregateInputType | true
    }

  export interface SpaceAssociationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpaceAssociation'], meta: { name: 'SpaceAssociation' } }
    /**
     * Find zero or one SpaceAssociation that matches the filter.
     * @param {SpaceAssociationFindUniqueArgs} args - Arguments to find a SpaceAssociation
     * @example
     * // Get one SpaceAssociation
     * const spaceAssociation = await prisma.spaceAssociation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceAssociationFindUniqueArgs>(args: SelectSubset<T, SpaceAssociationFindUniqueArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpaceAssociation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpaceAssociationFindUniqueOrThrowArgs} args - Arguments to find a SpaceAssociation
     * @example
     * // Get one SpaceAssociation
     * const spaceAssociation = await prisma.spaceAssociation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceAssociationFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceAssociationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpaceAssociation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAssociationFindFirstArgs} args - Arguments to find a SpaceAssociation
     * @example
     * // Get one SpaceAssociation
     * const spaceAssociation = await prisma.spaceAssociation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceAssociationFindFirstArgs>(args?: SelectSubset<T, SpaceAssociationFindFirstArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpaceAssociation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAssociationFindFirstOrThrowArgs} args - Arguments to find a SpaceAssociation
     * @example
     * // Get one SpaceAssociation
     * const spaceAssociation = await prisma.spaceAssociation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceAssociationFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceAssociationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpaceAssociations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAssociationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpaceAssociations
     * const spaceAssociations = await prisma.spaceAssociation.findMany()
     * 
     * // Get first 10 SpaceAssociations
     * const spaceAssociations = await prisma.spaceAssociation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceAssociationWithIdOnly = await prisma.spaceAssociation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceAssociationFindManyArgs>(args?: SelectSubset<T, SpaceAssociationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpaceAssociation.
     * @param {SpaceAssociationCreateArgs} args - Arguments to create a SpaceAssociation.
     * @example
     * // Create one SpaceAssociation
     * const SpaceAssociation = await prisma.spaceAssociation.create({
     *   data: {
     *     // ... data to create a SpaceAssociation
     *   }
     * })
     * 
     */
    create<T extends SpaceAssociationCreateArgs>(args: SelectSubset<T, SpaceAssociationCreateArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpaceAssociations.
     * @param {SpaceAssociationCreateManyArgs} args - Arguments to create many SpaceAssociations.
     * @example
     * // Create many SpaceAssociations
     * const spaceAssociation = await prisma.spaceAssociation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceAssociationCreateManyArgs>(args?: SelectSubset<T, SpaceAssociationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpaceAssociations and returns the data saved in the database.
     * @param {SpaceAssociationCreateManyAndReturnArgs} args - Arguments to create many SpaceAssociations.
     * @example
     * // Create many SpaceAssociations
     * const spaceAssociation = await prisma.spaceAssociation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpaceAssociations and only return the `id`
     * const spaceAssociationWithIdOnly = await prisma.spaceAssociation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaceAssociationCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaceAssociationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpaceAssociation.
     * @param {SpaceAssociationDeleteArgs} args - Arguments to delete one SpaceAssociation.
     * @example
     * // Delete one SpaceAssociation
     * const SpaceAssociation = await prisma.spaceAssociation.delete({
     *   where: {
     *     // ... filter to delete one SpaceAssociation
     *   }
     * })
     * 
     */
    delete<T extends SpaceAssociationDeleteArgs>(args: SelectSubset<T, SpaceAssociationDeleteArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpaceAssociation.
     * @param {SpaceAssociationUpdateArgs} args - Arguments to update one SpaceAssociation.
     * @example
     * // Update one SpaceAssociation
     * const spaceAssociation = await prisma.spaceAssociation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceAssociationUpdateArgs>(args: SelectSubset<T, SpaceAssociationUpdateArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpaceAssociations.
     * @param {SpaceAssociationDeleteManyArgs} args - Arguments to filter SpaceAssociations to delete.
     * @example
     * // Delete a few SpaceAssociations
     * const { count } = await prisma.spaceAssociation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceAssociationDeleteManyArgs>(args?: SelectSubset<T, SpaceAssociationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaceAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAssociationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpaceAssociations
     * const spaceAssociation = await prisma.spaceAssociation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceAssociationUpdateManyArgs>(args: SelectSubset<T, SpaceAssociationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaceAssociations and returns the data updated in the database.
     * @param {SpaceAssociationUpdateManyAndReturnArgs} args - Arguments to update many SpaceAssociations.
     * @example
     * // Update many SpaceAssociations
     * const spaceAssociation = await prisma.spaceAssociation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpaceAssociations and only return the `id`
     * const spaceAssociationWithIdOnly = await prisma.spaceAssociation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpaceAssociationUpdateManyAndReturnArgs>(args: SelectSubset<T, SpaceAssociationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpaceAssociation.
     * @param {SpaceAssociationUpsertArgs} args - Arguments to update or create a SpaceAssociation.
     * @example
     * // Update or create a SpaceAssociation
     * const spaceAssociation = await prisma.spaceAssociation.upsert({
     *   create: {
     *     // ... data to create a SpaceAssociation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpaceAssociation we want to update
     *   }
     * })
     */
    upsert<T extends SpaceAssociationUpsertArgs>(args: SelectSubset<T, SpaceAssociationUpsertArgs<ExtArgs>>): Prisma__SpaceAssociationClient<$Result.GetResult<Prisma.$SpaceAssociationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpaceAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAssociationCountArgs} args - Arguments to filter SpaceAssociations to count.
     * @example
     * // Count the number of SpaceAssociations
     * const count = await prisma.spaceAssociation.count({
     *   where: {
     *     // ... the filter for the SpaceAssociations we want to count
     *   }
     * })
    **/
    count<T extends SpaceAssociationCountArgs>(
      args?: Subset<T, SpaceAssociationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceAssociationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpaceAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAssociationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceAssociationAggregateArgs>(args: Subset<T, SpaceAssociationAggregateArgs>): Prisma.PrismaPromise<GetSpaceAssociationAggregateType<T>>

    /**
     * Group by SpaceAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAssociationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceAssociationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceAssociationGroupByArgs['orderBy'] }
        : { orderBy?: SpaceAssociationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceAssociationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceAssociationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpaceAssociation model
   */
  readonly fields: SpaceAssociationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpaceAssociation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceAssociationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpaceAssociation model
   */
  interface SpaceAssociationFieldRefs {
    readonly id: FieldRef<"SpaceAssociation", 'String'>
    readonly seq: FieldRef<"SpaceAssociation", 'Int'>
    readonly createdAt: FieldRef<"SpaceAssociation", 'DateTime'>
    readonly updatedAt: FieldRef<"SpaceAssociation", 'DateTime'>
    readonly removedAt: FieldRef<"SpaceAssociation", 'DateTime'>
    readonly spaceId: FieldRef<"SpaceAssociation", 'String'>
    readonly groupId: FieldRef<"SpaceAssociation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpaceAssociation findUnique
   */
  export type SpaceAssociationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceAssociation to fetch.
     */
    where: SpaceAssociationWhereUniqueInput
  }

  /**
   * SpaceAssociation findUniqueOrThrow
   */
  export type SpaceAssociationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceAssociation to fetch.
     */
    where: SpaceAssociationWhereUniqueInput
  }

  /**
   * SpaceAssociation findFirst
   */
  export type SpaceAssociationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceAssociation to fetch.
     */
    where?: SpaceAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceAssociations to fetch.
     */
    orderBy?: SpaceAssociationOrderByWithRelationInput | SpaceAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceAssociations.
     */
    cursor?: SpaceAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceAssociations.
     */
    distinct?: SpaceAssociationScalarFieldEnum | SpaceAssociationScalarFieldEnum[]
  }

  /**
   * SpaceAssociation findFirstOrThrow
   */
  export type SpaceAssociationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceAssociation to fetch.
     */
    where?: SpaceAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceAssociations to fetch.
     */
    orderBy?: SpaceAssociationOrderByWithRelationInput | SpaceAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceAssociations.
     */
    cursor?: SpaceAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceAssociations.
     */
    distinct?: SpaceAssociationScalarFieldEnum | SpaceAssociationScalarFieldEnum[]
  }

  /**
   * SpaceAssociation findMany
   */
  export type SpaceAssociationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * Filter, which SpaceAssociations to fetch.
     */
    where?: SpaceAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceAssociations to fetch.
     */
    orderBy?: SpaceAssociationOrderByWithRelationInput | SpaceAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpaceAssociations.
     */
    cursor?: SpaceAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceAssociations.
     */
    skip?: number
    distinct?: SpaceAssociationScalarFieldEnum | SpaceAssociationScalarFieldEnum[]
  }

  /**
   * SpaceAssociation create
   */
  export type SpaceAssociationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * The data needed to create a SpaceAssociation.
     */
    data: XOR<SpaceAssociationCreateInput, SpaceAssociationUncheckedCreateInput>
  }

  /**
   * SpaceAssociation createMany
   */
  export type SpaceAssociationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpaceAssociations.
     */
    data: SpaceAssociationCreateManyInput | SpaceAssociationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpaceAssociation createManyAndReturn
   */
  export type SpaceAssociationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * The data used to create many SpaceAssociations.
     */
    data: SpaceAssociationCreateManyInput | SpaceAssociationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpaceAssociation update
   */
  export type SpaceAssociationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * The data needed to update a SpaceAssociation.
     */
    data: XOR<SpaceAssociationUpdateInput, SpaceAssociationUncheckedUpdateInput>
    /**
     * Choose, which SpaceAssociation to update.
     */
    where: SpaceAssociationWhereUniqueInput
  }

  /**
   * SpaceAssociation updateMany
   */
  export type SpaceAssociationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpaceAssociations.
     */
    data: XOR<SpaceAssociationUpdateManyMutationInput, SpaceAssociationUncheckedUpdateManyInput>
    /**
     * Filter which SpaceAssociations to update
     */
    where?: SpaceAssociationWhereInput
    /**
     * Limit how many SpaceAssociations to update.
     */
    limit?: number
  }

  /**
   * SpaceAssociation updateManyAndReturn
   */
  export type SpaceAssociationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * The data used to update SpaceAssociations.
     */
    data: XOR<SpaceAssociationUpdateManyMutationInput, SpaceAssociationUncheckedUpdateManyInput>
    /**
     * Filter which SpaceAssociations to update
     */
    where?: SpaceAssociationWhereInput
    /**
     * Limit how many SpaceAssociations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpaceAssociation upsert
   */
  export type SpaceAssociationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * The filter to search for the SpaceAssociation to update in case it exists.
     */
    where: SpaceAssociationWhereUniqueInput
    /**
     * In case the SpaceAssociation found by the `where` argument doesn't exist, create a new SpaceAssociation with this data.
     */
    create: XOR<SpaceAssociationCreateInput, SpaceAssociationUncheckedCreateInput>
    /**
     * In case the SpaceAssociation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceAssociationUpdateInput, SpaceAssociationUncheckedUpdateInput>
  }

  /**
   * SpaceAssociation delete
   */
  export type SpaceAssociationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
    /**
     * Filter which SpaceAssociation to delete.
     */
    where: SpaceAssociationWhereUniqueInput
  }

  /**
   * SpaceAssociation deleteMany
   */
  export type SpaceAssociationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceAssociations to delete
     */
    where?: SpaceAssociationWhereInput
    /**
     * Limit how many SpaceAssociations to delete.
     */
    limit?: number
  }

  /**
   * SpaceAssociation without action
   */
  export type SpaceAssociationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceAssociation
     */
    select?: SpaceAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaceAssociation
     */
    omit?: SpaceAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceAssociationInclude<ExtArgs> | null
  }


  /**
   * Model Ground
   */

  export type AggregateGround = {
    _count: GroundCountAggregateOutputType | null
    _avg: GroundAvgAggregateOutputType | null
    _sum: GroundSumAggregateOutputType | null
    _min: GroundMinAggregateOutputType | null
    _max: GroundMaxAggregateOutputType | null
  }

  export type GroundAvgAggregateOutputType = {
    seq: number | null
  }

  export type GroundSumAggregateOutputType = {
    seq: number | null
  }

  export type GroundMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    label: string | null
    address: string | null
    phone: string | null
    email: string | null
    businessNo: string | null
    spaceId: string | null
    logoImageFileId: string | null
    imageFileId: string | null
  }

  export type GroundMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    label: string | null
    address: string | null
    phone: string | null
    email: string | null
    businessNo: string | null
    spaceId: string | null
    logoImageFileId: string | null
    imageFileId: string | null
  }

  export type GroundCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    label: number
    address: number
    phone: number
    email: number
    businessNo: number
    spaceId: number
    logoImageFileId: number
    imageFileId: number
    _all: number
  }


  export type GroundAvgAggregateInputType = {
    seq?: true
  }

  export type GroundSumAggregateInputType = {
    seq?: true
  }

  export type GroundMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    label?: true
    address?: true
    phone?: true
    email?: true
    businessNo?: true
    spaceId?: true
    logoImageFileId?: true
    imageFileId?: true
  }

  export type GroundMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    label?: true
    address?: true
    phone?: true
    email?: true
    businessNo?: true
    spaceId?: true
    logoImageFileId?: true
    imageFileId?: true
  }

  export type GroundCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    label?: true
    address?: true
    phone?: true
    email?: true
    businessNo?: true
    spaceId?: true
    logoImageFileId?: true
    imageFileId?: true
    _all?: true
  }

  export type GroundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ground to aggregate.
     */
    where?: GroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grounds to fetch.
     */
    orderBy?: GroundOrderByWithRelationInput | GroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grounds
    **/
    _count?: true | GroundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroundMaxAggregateInputType
  }

  export type GetGroundAggregateType<T extends GroundAggregateArgs> = {
        [P in keyof T & keyof AggregateGround]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGround[P]>
      : GetScalarType<T[P], AggregateGround[P]>
  }




  export type GroundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroundWhereInput
    orderBy?: GroundOrderByWithAggregationInput | GroundOrderByWithAggregationInput[]
    by: GroundScalarFieldEnum[] | GroundScalarFieldEnum
    having?: GroundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroundCountAggregateInputType | true
    _avg?: GroundAvgAggregateInputType
    _sum?: GroundSumAggregateInputType
    _min?: GroundMinAggregateInputType
    _max?: GroundMaxAggregateInputType
  }

  export type GroundGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: string
    label: string | null
    address: string
    phone: string
    email: string
    businessNo: string
    spaceId: string
    logoImageFileId: string | null
    imageFileId: string | null
    _count: GroundCountAggregateOutputType | null
    _avg: GroundAvgAggregateOutputType | null
    _sum: GroundSumAggregateOutputType | null
    _min: GroundMinAggregateOutputType | null
    _max: GroundMaxAggregateOutputType | null
  }

  type GetGroundGroupByPayload<T extends GroundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroundGroupByOutputType[P]>
            : GetScalarType<T[P], GroundGroupByOutputType[P]>
        }
      >
    >


  export type GroundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    businessNo?: boolean
    spaceId?: boolean
    logoImageFileId?: boolean
    imageFileId?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ground"]>

  export type GroundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    businessNo?: boolean
    spaceId?: boolean
    logoImageFileId?: boolean
    imageFileId?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ground"]>

  export type GroundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    businessNo?: boolean
    spaceId?: boolean
    logoImageFileId?: boolean
    imageFileId?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ground"]>

  export type GroundSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    label?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    businessNo?: boolean
    spaceId?: boolean
    logoImageFileId?: boolean
    imageFileId?: boolean
  }

  export type GroundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name" | "label" | "address" | "phone" | "email" | "businessNo" | "spaceId" | "logoImageFileId" | "imageFileId", ExtArgs["result"]["ground"]>
  export type GroundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }
  export type GroundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }
  export type GroundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }

  export type $GroundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ground"
    objects: {
      space: Prisma.$SpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: string
      label: string | null
      address: string
      phone: string
      email: string
      businessNo: string
      spaceId: string
      logoImageFileId: string | null
      imageFileId: string | null
    }, ExtArgs["result"]["ground"]>
    composites: {}
  }

  type GroundGetPayload<S extends boolean | null | undefined | GroundDefaultArgs> = $Result.GetResult<Prisma.$GroundPayload, S>

  type GroundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroundCountAggregateInputType | true
    }

  export interface GroundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ground'], meta: { name: 'Ground' } }
    /**
     * Find zero or one Ground that matches the filter.
     * @param {GroundFindUniqueArgs} args - Arguments to find a Ground
     * @example
     * // Get one Ground
     * const ground = await prisma.ground.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroundFindUniqueArgs>(args: SelectSubset<T, GroundFindUniqueArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ground that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroundFindUniqueOrThrowArgs} args - Arguments to find a Ground
     * @example
     * // Get one Ground
     * const ground = await prisma.ground.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroundFindUniqueOrThrowArgs>(args: SelectSubset<T, GroundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ground that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundFindFirstArgs} args - Arguments to find a Ground
     * @example
     * // Get one Ground
     * const ground = await prisma.ground.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroundFindFirstArgs>(args?: SelectSubset<T, GroundFindFirstArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ground that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundFindFirstOrThrowArgs} args - Arguments to find a Ground
     * @example
     * // Get one Ground
     * const ground = await prisma.ground.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroundFindFirstOrThrowArgs>(args?: SelectSubset<T, GroundFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grounds
     * const grounds = await prisma.ground.findMany()
     * 
     * // Get first 10 Grounds
     * const grounds = await prisma.ground.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groundWithIdOnly = await prisma.ground.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroundFindManyArgs>(args?: SelectSubset<T, GroundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ground.
     * @param {GroundCreateArgs} args - Arguments to create a Ground.
     * @example
     * // Create one Ground
     * const Ground = await prisma.ground.create({
     *   data: {
     *     // ... data to create a Ground
     *   }
     * })
     * 
     */
    create<T extends GroundCreateArgs>(args: SelectSubset<T, GroundCreateArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grounds.
     * @param {GroundCreateManyArgs} args - Arguments to create many Grounds.
     * @example
     * // Create many Grounds
     * const ground = await prisma.ground.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroundCreateManyArgs>(args?: SelectSubset<T, GroundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grounds and returns the data saved in the database.
     * @param {GroundCreateManyAndReturnArgs} args - Arguments to create many Grounds.
     * @example
     * // Create many Grounds
     * const ground = await prisma.ground.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grounds and only return the `id`
     * const groundWithIdOnly = await prisma.ground.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroundCreateManyAndReturnArgs>(args?: SelectSubset<T, GroundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ground.
     * @param {GroundDeleteArgs} args - Arguments to delete one Ground.
     * @example
     * // Delete one Ground
     * const Ground = await prisma.ground.delete({
     *   where: {
     *     // ... filter to delete one Ground
     *   }
     * })
     * 
     */
    delete<T extends GroundDeleteArgs>(args: SelectSubset<T, GroundDeleteArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ground.
     * @param {GroundUpdateArgs} args - Arguments to update one Ground.
     * @example
     * // Update one Ground
     * const ground = await prisma.ground.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroundUpdateArgs>(args: SelectSubset<T, GroundUpdateArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grounds.
     * @param {GroundDeleteManyArgs} args - Arguments to filter Grounds to delete.
     * @example
     * // Delete a few Grounds
     * const { count } = await prisma.ground.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroundDeleteManyArgs>(args?: SelectSubset<T, GroundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grounds
     * const ground = await prisma.ground.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroundUpdateManyArgs>(args: SelectSubset<T, GroundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grounds and returns the data updated in the database.
     * @param {GroundUpdateManyAndReturnArgs} args - Arguments to update many Grounds.
     * @example
     * // Update many Grounds
     * const ground = await prisma.ground.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grounds and only return the `id`
     * const groundWithIdOnly = await prisma.ground.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroundUpdateManyAndReturnArgs>(args: SelectSubset<T, GroundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ground.
     * @param {GroundUpsertArgs} args - Arguments to update or create a Ground.
     * @example
     * // Update or create a Ground
     * const ground = await prisma.ground.upsert({
     *   create: {
     *     // ... data to create a Ground
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ground we want to update
     *   }
     * })
     */
    upsert<T extends GroundUpsertArgs>(args: SelectSubset<T, GroundUpsertArgs<ExtArgs>>): Prisma__GroundClient<$Result.GetResult<Prisma.$GroundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundCountArgs} args - Arguments to filter Grounds to count.
     * @example
     * // Count the number of Grounds
     * const count = await prisma.ground.count({
     *   where: {
     *     // ... the filter for the Grounds we want to count
     *   }
     * })
    **/
    count<T extends GroundCountArgs>(
      args?: Subset<T, GroundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ground.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroundAggregateArgs>(args: Subset<T, GroundAggregateArgs>): Prisma.PrismaPromise<GetGroundAggregateType<T>>

    /**
     * Group by Ground.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroundGroupByArgs['orderBy'] }
        : { orderBy?: GroundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ground model
   */
  readonly fields: GroundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ground.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ground model
   */
  interface GroundFieldRefs {
    readonly id: FieldRef<"Ground", 'String'>
    readonly seq: FieldRef<"Ground", 'Int'>
    readonly createdAt: FieldRef<"Ground", 'DateTime'>
    readonly updatedAt: FieldRef<"Ground", 'DateTime'>
    readonly removedAt: FieldRef<"Ground", 'DateTime'>
    readonly name: FieldRef<"Ground", 'String'>
    readonly label: FieldRef<"Ground", 'String'>
    readonly address: FieldRef<"Ground", 'String'>
    readonly phone: FieldRef<"Ground", 'String'>
    readonly email: FieldRef<"Ground", 'String'>
    readonly businessNo: FieldRef<"Ground", 'String'>
    readonly spaceId: FieldRef<"Ground", 'String'>
    readonly logoImageFileId: FieldRef<"Ground", 'String'>
    readonly imageFileId: FieldRef<"Ground", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ground findUnique
   */
  export type GroundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * Filter, which Ground to fetch.
     */
    where: GroundWhereUniqueInput
  }

  /**
   * Ground findUniqueOrThrow
   */
  export type GroundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * Filter, which Ground to fetch.
     */
    where: GroundWhereUniqueInput
  }

  /**
   * Ground findFirst
   */
  export type GroundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * Filter, which Ground to fetch.
     */
    where?: GroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grounds to fetch.
     */
    orderBy?: GroundOrderByWithRelationInput | GroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grounds.
     */
    cursor?: GroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grounds.
     */
    distinct?: GroundScalarFieldEnum | GroundScalarFieldEnum[]
  }

  /**
   * Ground findFirstOrThrow
   */
  export type GroundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * Filter, which Ground to fetch.
     */
    where?: GroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grounds to fetch.
     */
    orderBy?: GroundOrderByWithRelationInput | GroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grounds.
     */
    cursor?: GroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grounds.
     */
    distinct?: GroundScalarFieldEnum | GroundScalarFieldEnum[]
  }

  /**
   * Ground findMany
   */
  export type GroundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * Filter, which Grounds to fetch.
     */
    where?: GroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grounds to fetch.
     */
    orderBy?: GroundOrderByWithRelationInput | GroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grounds.
     */
    cursor?: GroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grounds.
     */
    skip?: number
    distinct?: GroundScalarFieldEnum | GroundScalarFieldEnum[]
  }

  /**
   * Ground create
   */
  export type GroundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * The data needed to create a Ground.
     */
    data: XOR<GroundCreateInput, GroundUncheckedCreateInput>
  }

  /**
   * Ground createMany
   */
  export type GroundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grounds.
     */
    data: GroundCreateManyInput | GroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ground createManyAndReturn
   */
  export type GroundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * The data used to create many Grounds.
     */
    data: GroundCreateManyInput | GroundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ground update
   */
  export type GroundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * The data needed to update a Ground.
     */
    data: XOR<GroundUpdateInput, GroundUncheckedUpdateInput>
    /**
     * Choose, which Ground to update.
     */
    where: GroundWhereUniqueInput
  }

  /**
   * Ground updateMany
   */
  export type GroundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grounds.
     */
    data: XOR<GroundUpdateManyMutationInput, GroundUncheckedUpdateManyInput>
    /**
     * Filter which Grounds to update
     */
    where?: GroundWhereInput
    /**
     * Limit how many Grounds to update.
     */
    limit?: number
  }

  /**
   * Ground updateManyAndReturn
   */
  export type GroundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * The data used to update Grounds.
     */
    data: XOR<GroundUpdateManyMutationInput, GroundUncheckedUpdateManyInput>
    /**
     * Filter which Grounds to update
     */
    where?: GroundWhereInput
    /**
     * Limit how many Grounds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ground upsert
   */
  export type GroundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * The filter to search for the Ground to update in case it exists.
     */
    where: GroundWhereUniqueInput
    /**
     * In case the Ground found by the `where` argument doesn't exist, create a new Ground with this data.
     */
    create: XOR<GroundCreateInput, GroundUncheckedCreateInput>
    /**
     * In case the Ground was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroundUpdateInput, GroundUncheckedUpdateInput>
  }

  /**
   * Ground delete
   */
  export type GroundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
    /**
     * Filter which Ground to delete.
     */
    where: GroundWhereUniqueInput
  }

  /**
   * Ground deleteMany
   */
  export type GroundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grounds to delete
     */
    where?: GroundWhereInput
    /**
     * Limit how many Grounds to delete.
     */
    limit?: number
  }

  /**
   * Ground without action
   */
  export type GroundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ground
     */
    select?: GroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ground
     */
    omit?: GroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    seq: number | null
  }

  export type UserSumAggregateOutputType = {
    seq: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    seq: number | null
    updatedAt: Date | null
    createdAt: Date | null
    removedAt: Date | null
    phone: string | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    updatedAt: Date | null
    createdAt: Date | null
    removedAt: Date | null
    phone: string | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    seq: number
    updatedAt: number
    createdAt: number
    removedAt: number
    phone: number
    name: number
    email: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    seq?: true
  }

  export type UserSumAggregateInputType = {
    seq?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    seq?: true
    updatedAt?: true
    createdAt?: true
    removedAt?: true
    phone?: true
    name?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    seq?: true
    updatedAt?: true
    createdAt?: true
    removedAt?: true
    phone?: true
    name?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    seq?: true
    updatedAt?: true
    createdAt?: true
    removedAt?: true
    phone?: true
    name?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    seq: number
    updatedAt: Date | null
    createdAt: Date
    removedAt: Date | null
    phone: string
    name: string
    email: string
    password: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    removedAt?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    profiles?: boolean | User$profilesArgs<ExtArgs>
    tenants?: boolean | User$tenantsArgs<ExtArgs>
    classification?: boolean | User$classificationArgs<ExtArgs>
    associations?: boolean | User$associationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    removedAt?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    removedAt?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    seq?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    removedAt?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "updatedAt" | "createdAt" | "removedAt" | "phone" | "name" | "email" | "password", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | User$profilesArgs<ExtArgs>
    tenants?: boolean | User$tenantsArgs<ExtArgs>
    classification?: boolean | User$classificationArgs<ExtArgs>
    associations?: boolean | User$associationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
      tenants: Prisma.$TenantPayload<ExtArgs>[]
      classification: Prisma.$UserClassificationPayload<ExtArgs> | null
      associations: Prisma.$UserAssociationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      updatedAt: Date | null
      createdAt: Date
      removedAt: Date | null
      phone: string
      name: string
      email: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profiles<T extends User$profilesArgs<ExtArgs> = {}>(args?: Subset<T, User$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenants<T extends User$tenantsArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classification<T extends User$classificationArgs<ExtArgs> = {}>(args?: Subset<T, User$classificationArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    associations<T extends User$associationsArgs<ExtArgs> = {}>(args?: Subset<T, User$associationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly seq: FieldRef<"User", 'Int'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly removedAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profiles
   */
  export type User$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * User.tenants
   */
  export type User$tenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * User.classification
   */
  export type User$classificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    where?: UserClassificationWhereInput
  }

  /**
   * User.associations
   */
  export type User$associationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    where?: UserAssociationWhereInput
    orderBy?: UserAssociationOrderByWithRelationInput | UserAssociationOrderByWithRelationInput[]
    cursor?: UserAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAssociationScalarFieldEnum | UserAssociationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserClassification
   */

  export type AggregateUserClassification = {
    _count: UserClassificationCountAggregateOutputType | null
    _avg: UserClassificationAvgAggregateOutputType | null
    _sum: UserClassificationSumAggregateOutputType | null
    _min: UserClassificationMinAggregateOutputType | null
    _max: UserClassificationMaxAggregateOutputType | null
  }

  export type UserClassificationAvgAggregateOutputType = {
    seq: number | null
  }

  export type UserClassificationSumAggregateOutputType = {
    seq: number | null
  }

  export type UserClassificationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type UserClassificationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    categoryId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
  }

  export type UserClassificationCountAggregateOutputType = {
    id: number
    seq: number
    categoryId: number
    userId: number
    createdAt: number
    updatedAt: number
    removedAt: number
    _all: number
  }


  export type UserClassificationAvgAggregateInputType = {
    seq?: true
  }

  export type UserClassificationSumAggregateInputType = {
    seq?: true
  }

  export type UserClassificationMinAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type UserClassificationMaxAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
  }

  export type UserClassificationCountAggregateInputType = {
    id?: true
    seq?: true
    categoryId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    _all?: true
  }

  export type UserClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserClassification to aggregate.
     */
    where?: UserClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassifications to fetch.
     */
    orderBy?: UserClassificationOrderByWithRelationInput | UserClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserClassifications
    **/
    _count?: true | UserClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserClassificationMaxAggregateInputType
  }

  export type GetUserClassificationAggregateType<T extends UserClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserClassification[P]>
      : GetScalarType<T[P], AggregateUserClassification[P]>
  }




  export type UserClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClassificationWhereInput
    orderBy?: UserClassificationOrderByWithAggregationInput | UserClassificationOrderByWithAggregationInput[]
    by: UserClassificationScalarFieldEnum[] | UserClassificationScalarFieldEnum
    having?: UserClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserClassificationCountAggregateInputType | true
    _avg?: UserClassificationAvgAggregateInputType
    _sum?: UserClassificationSumAggregateInputType
    _min?: UserClassificationMinAggregateInputType
    _max?: UserClassificationMaxAggregateInputType
  }

  export type UserClassificationGroupByOutputType = {
    id: string
    seq: number
    categoryId: string
    userId: string
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    _count: UserClassificationCountAggregateOutputType | null
    _avg: UserClassificationAvgAggregateOutputType | null
    _sum: UserClassificationSumAggregateOutputType | null
    _min: UserClassificationMinAggregateOutputType | null
    _max: UserClassificationMaxAggregateOutputType | null
  }

  type GetUserClassificationGroupByPayload<T extends UserClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], UserClassificationGroupByOutputType[P]>
        }
      >
    >


  export type UserClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userClassification"]>

  export type UserClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userClassification"]>

  export type UserClassificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userClassification"]>

  export type UserClassificationSelectScalar = {
    id?: boolean
    seq?: boolean
    categoryId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
  }

  export type UserClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "categoryId" | "userId" | "createdAt" | "updatedAt" | "removedAt", ExtArgs["result"]["userClassification"]>
  export type UserClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserClassificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserClassification"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      categoryId: string
      userId: string
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
    }, ExtArgs["result"]["userClassification"]>
    composites: {}
  }

  type UserClassificationGetPayload<S extends boolean | null | undefined | UserClassificationDefaultArgs> = $Result.GetResult<Prisma.$UserClassificationPayload, S>

  type UserClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserClassificationCountAggregateInputType | true
    }

  export interface UserClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserClassification'], meta: { name: 'UserClassification' } }
    /**
     * Find zero or one UserClassification that matches the filter.
     * @param {UserClassificationFindUniqueArgs} args - Arguments to find a UserClassification
     * @example
     * // Get one UserClassification
     * const userClassification = await prisma.userClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserClassificationFindUniqueArgs>(args: SelectSubset<T, UserClassificationFindUniqueArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserClassificationFindUniqueOrThrowArgs} args - Arguments to find a UserClassification
     * @example
     * // Get one UserClassification
     * const userClassification = await prisma.userClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassificationFindFirstArgs} args - Arguments to find a UserClassification
     * @example
     * // Get one UserClassification
     * const userClassification = await prisma.userClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserClassificationFindFirstArgs>(args?: SelectSubset<T, UserClassificationFindFirstArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassificationFindFirstOrThrowArgs} args - Arguments to find a UserClassification
     * @example
     * // Get one UserClassification
     * const userClassification = await prisma.userClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserClassifications
     * const userClassifications = await prisma.userClassification.findMany()
     * 
     * // Get first 10 UserClassifications
     * const userClassifications = await prisma.userClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userClassificationWithIdOnly = await prisma.userClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserClassificationFindManyArgs>(args?: SelectSubset<T, UserClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserClassification.
     * @param {UserClassificationCreateArgs} args - Arguments to create a UserClassification.
     * @example
     * // Create one UserClassification
     * const UserClassification = await prisma.userClassification.create({
     *   data: {
     *     // ... data to create a UserClassification
     *   }
     * })
     * 
     */
    create<T extends UserClassificationCreateArgs>(args: SelectSubset<T, UserClassificationCreateArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserClassifications.
     * @param {UserClassificationCreateManyArgs} args - Arguments to create many UserClassifications.
     * @example
     * // Create many UserClassifications
     * const userClassification = await prisma.userClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserClassificationCreateManyArgs>(args?: SelectSubset<T, UserClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserClassifications and returns the data saved in the database.
     * @param {UserClassificationCreateManyAndReturnArgs} args - Arguments to create many UserClassifications.
     * @example
     * // Create many UserClassifications
     * const userClassification = await prisma.userClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserClassifications and only return the `id`
     * const userClassificationWithIdOnly = await prisma.userClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserClassification.
     * @param {UserClassificationDeleteArgs} args - Arguments to delete one UserClassification.
     * @example
     * // Delete one UserClassification
     * const UserClassification = await prisma.userClassification.delete({
     *   where: {
     *     // ... filter to delete one UserClassification
     *   }
     * })
     * 
     */
    delete<T extends UserClassificationDeleteArgs>(args: SelectSubset<T, UserClassificationDeleteArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserClassification.
     * @param {UserClassificationUpdateArgs} args - Arguments to update one UserClassification.
     * @example
     * // Update one UserClassification
     * const userClassification = await prisma.userClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserClassificationUpdateArgs>(args: SelectSubset<T, UserClassificationUpdateArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserClassifications.
     * @param {UserClassificationDeleteManyArgs} args - Arguments to filter UserClassifications to delete.
     * @example
     * // Delete a few UserClassifications
     * const { count } = await prisma.userClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserClassificationDeleteManyArgs>(args?: SelectSubset<T, UserClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserClassifications
     * const userClassification = await prisma.userClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserClassificationUpdateManyArgs>(args: SelectSubset<T, UserClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserClassifications and returns the data updated in the database.
     * @param {UserClassificationUpdateManyAndReturnArgs} args - Arguments to update many UserClassifications.
     * @example
     * // Update many UserClassifications
     * const userClassification = await prisma.userClassification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserClassifications and only return the `id`
     * const userClassificationWithIdOnly = await prisma.userClassification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserClassificationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserClassificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserClassification.
     * @param {UserClassificationUpsertArgs} args - Arguments to update or create a UserClassification.
     * @example
     * // Update or create a UserClassification
     * const userClassification = await prisma.userClassification.upsert({
     *   create: {
     *     // ... data to create a UserClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserClassification we want to update
     *   }
     * })
     */
    upsert<T extends UserClassificationUpsertArgs>(args: SelectSubset<T, UserClassificationUpsertArgs<ExtArgs>>): Prisma__UserClassificationClient<$Result.GetResult<Prisma.$UserClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassificationCountArgs} args - Arguments to filter UserClassifications to count.
     * @example
     * // Count the number of UserClassifications
     * const count = await prisma.userClassification.count({
     *   where: {
     *     // ... the filter for the UserClassifications we want to count
     *   }
     * })
    **/
    count<T extends UserClassificationCountArgs>(
      args?: Subset<T, UserClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserClassificationAggregateArgs>(args: Subset<T, UserClassificationAggregateArgs>): Prisma.PrismaPromise<GetUserClassificationAggregateType<T>>

    /**
     * Group by UserClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserClassificationGroupByArgs['orderBy'] }
        : { orderBy?: UserClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserClassification model
   */
  readonly fields: UserClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserClassification model
   */
  interface UserClassificationFieldRefs {
    readonly id: FieldRef<"UserClassification", 'String'>
    readonly seq: FieldRef<"UserClassification", 'Int'>
    readonly categoryId: FieldRef<"UserClassification", 'String'>
    readonly userId: FieldRef<"UserClassification", 'String'>
    readonly createdAt: FieldRef<"UserClassification", 'DateTime'>
    readonly updatedAt: FieldRef<"UserClassification", 'DateTime'>
    readonly removedAt: FieldRef<"UserClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserClassification findUnique
   */
  export type UserClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * Filter, which UserClassification to fetch.
     */
    where: UserClassificationWhereUniqueInput
  }

  /**
   * UserClassification findUniqueOrThrow
   */
  export type UserClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * Filter, which UserClassification to fetch.
     */
    where: UserClassificationWhereUniqueInput
  }

  /**
   * UserClassification findFirst
   */
  export type UserClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * Filter, which UserClassification to fetch.
     */
    where?: UserClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassifications to fetch.
     */
    orderBy?: UserClassificationOrderByWithRelationInput | UserClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserClassifications.
     */
    cursor?: UserClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserClassifications.
     */
    distinct?: UserClassificationScalarFieldEnum | UserClassificationScalarFieldEnum[]
  }

  /**
   * UserClassification findFirstOrThrow
   */
  export type UserClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * Filter, which UserClassification to fetch.
     */
    where?: UserClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassifications to fetch.
     */
    orderBy?: UserClassificationOrderByWithRelationInput | UserClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserClassifications.
     */
    cursor?: UserClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserClassifications.
     */
    distinct?: UserClassificationScalarFieldEnum | UserClassificationScalarFieldEnum[]
  }

  /**
   * UserClassification findMany
   */
  export type UserClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * Filter, which UserClassifications to fetch.
     */
    where?: UserClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassifications to fetch.
     */
    orderBy?: UserClassificationOrderByWithRelationInput | UserClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserClassifications.
     */
    cursor?: UserClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassifications.
     */
    skip?: number
    distinct?: UserClassificationScalarFieldEnum | UserClassificationScalarFieldEnum[]
  }

  /**
   * UserClassification create
   */
  export type UserClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserClassification.
     */
    data: XOR<UserClassificationCreateInput, UserClassificationUncheckedCreateInput>
  }

  /**
   * UserClassification createMany
   */
  export type UserClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserClassifications.
     */
    data: UserClassificationCreateManyInput | UserClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserClassification createManyAndReturn
   */
  export type UserClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many UserClassifications.
     */
    data: UserClassificationCreateManyInput | UserClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserClassification update
   */
  export type UserClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserClassification.
     */
    data: XOR<UserClassificationUpdateInput, UserClassificationUncheckedUpdateInput>
    /**
     * Choose, which UserClassification to update.
     */
    where: UserClassificationWhereUniqueInput
  }

  /**
   * UserClassification updateMany
   */
  export type UserClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserClassifications.
     */
    data: XOR<UserClassificationUpdateManyMutationInput, UserClassificationUncheckedUpdateManyInput>
    /**
     * Filter which UserClassifications to update
     */
    where?: UserClassificationWhereInput
    /**
     * Limit how many UserClassifications to update.
     */
    limit?: number
  }

  /**
   * UserClassification updateManyAndReturn
   */
  export type UserClassificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * The data used to update UserClassifications.
     */
    data: XOR<UserClassificationUpdateManyMutationInput, UserClassificationUncheckedUpdateManyInput>
    /**
     * Filter which UserClassifications to update
     */
    where?: UserClassificationWhereInput
    /**
     * Limit how many UserClassifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserClassification upsert
   */
  export type UserClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserClassification to update in case it exists.
     */
    where: UserClassificationWhereUniqueInput
    /**
     * In case the UserClassification found by the `where` argument doesn't exist, create a new UserClassification with this data.
     */
    create: XOR<UserClassificationCreateInput, UserClassificationUncheckedCreateInput>
    /**
     * In case the UserClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserClassificationUpdateInput, UserClassificationUncheckedUpdateInput>
  }

  /**
   * UserClassification delete
   */
  export type UserClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
    /**
     * Filter which UserClassification to delete.
     */
    where: UserClassificationWhereUniqueInput
  }

  /**
   * UserClassification deleteMany
   */
  export type UserClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserClassifications to delete
     */
    where?: UserClassificationWhereInput
    /**
     * Limit how many UserClassifications to delete.
     */
    limit?: number
  }

  /**
   * UserClassification without action
   */
  export type UserClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassification
     */
    select?: UserClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassification
     */
    omit?: UserClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassificationInclude<ExtArgs> | null
  }


  /**
   * Model UserAssociation
   */

  export type AggregateUserAssociation = {
    _count: UserAssociationCountAggregateOutputType | null
    _avg: UserAssociationAvgAggregateOutputType | null
    _sum: UserAssociationSumAggregateOutputType | null
    _min: UserAssociationMinAggregateOutputType | null
    _max: UserAssociationMaxAggregateOutputType | null
  }

  export type UserAssociationAvgAggregateOutputType = {
    seq: number | null
  }

  export type UserAssociationSumAggregateOutputType = {
    seq: number | null
  }

  export type UserAssociationMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    userId: string | null
    groupId: string | null
  }

  export type UserAssociationMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    userId: string | null
    groupId: string | null
  }

  export type UserAssociationCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    userId: number
    groupId: number
    _all: number
  }


  export type UserAssociationAvgAggregateInputType = {
    seq?: true
  }

  export type UserAssociationSumAggregateInputType = {
    seq?: true
  }

  export type UserAssociationMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    userId?: true
    groupId?: true
  }

  export type UserAssociationMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    userId?: true
    groupId?: true
  }

  export type UserAssociationCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    userId?: true
    groupId?: true
    _all?: true
  }

  export type UserAssociationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAssociation to aggregate.
     */
    where?: UserAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssociations to fetch.
     */
    orderBy?: UserAssociationOrderByWithRelationInput | UserAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAssociations
    **/
    _count?: true | UserAssociationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAssociationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAssociationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAssociationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAssociationMaxAggregateInputType
  }

  export type GetUserAssociationAggregateType<T extends UserAssociationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAssociation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAssociation[P]>
      : GetScalarType<T[P], AggregateUserAssociation[P]>
  }




  export type UserAssociationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssociationWhereInput
    orderBy?: UserAssociationOrderByWithAggregationInput | UserAssociationOrderByWithAggregationInput[]
    by: UserAssociationScalarFieldEnum[] | UserAssociationScalarFieldEnum
    having?: UserAssociationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAssociationCountAggregateInputType | true
    _avg?: UserAssociationAvgAggregateInputType
    _sum?: UserAssociationSumAggregateInputType
    _min?: UserAssociationMinAggregateInputType
    _max?: UserAssociationMaxAggregateInputType
  }

  export type UserAssociationGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    userId: string
    groupId: string
    _count: UserAssociationCountAggregateOutputType | null
    _avg: UserAssociationAvgAggregateOutputType | null
    _sum: UserAssociationSumAggregateOutputType | null
    _min: UserAssociationMinAggregateOutputType | null
    _max: UserAssociationMaxAggregateOutputType | null
  }

  type GetUserAssociationGroupByPayload<T extends UserAssociationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAssociationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAssociationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAssociationGroupByOutputType[P]>
            : GetScalarType<T[P], UserAssociationGroupByOutputType[P]>
        }
      >
    >


  export type UserAssociationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssociation"]>

  export type UserAssociationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssociation"]>

  export type UserAssociationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    groupId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssociation"]>

  export type UserAssociationSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    userId?: boolean
    groupId?: boolean
  }

  export type UserAssociationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "userId" | "groupId", ExtArgs["result"]["userAssociation"]>
  export type UserAssociationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAssociationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAssociationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAssociationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAssociation"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      userId: string
      groupId: string
    }, ExtArgs["result"]["userAssociation"]>
    composites: {}
  }

  type UserAssociationGetPayload<S extends boolean | null | undefined | UserAssociationDefaultArgs> = $Result.GetResult<Prisma.$UserAssociationPayload, S>

  type UserAssociationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAssociationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAssociationCountAggregateInputType | true
    }

  export interface UserAssociationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAssociation'], meta: { name: 'UserAssociation' } }
    /**
     * Find zero or one UserAssociation that matches the filter.
     * @param {UserAssociationFindUniqueArgs} args - Arguments to find a UserAssociation
     * @example
     * // Get one UserAssociation
     * const userAssociation = await prisma.userAssociation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAssociationFindUniqueArgs>(args: SelectSubset<T, UserAssociationFindUniqueArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAssociation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAssociationFindUniqueOrThrowArgs} args - Arguments to find a UserAssociation
     * @example
     * // Get one UserAssociation
     * const userAssociation = await prisma.userAssociation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAssociationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAssociationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAssociation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssociationFindFirstArgs} args - Arguments to find a UserAssociation
     * @example
     * // Get one UserAssociation
     * const userAssociation = await prisma.userAssociation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAssociationFindFirstArgs>(args?: SelectSubset<T, UserAssociationFindFirstArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAssociation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssociationFindFirstOrThrowArgs} args - Arguments to find a UserAssociation
     * @example
     * // Get one UserAssociation
     * const userAssociation = await prisma.userAssociation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAssociationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAssociationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAssociations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssociationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAssociations
     * const userAssociations = await prisma.userAssociation.findMany()
     * 
     * // Get first 10 UserAssociations
     * const userAssociations = await prisma.userAssociation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAssociationWithIdOnly = await prisma.userAssociation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAssociationFindManyArgs>(args?: SelectSubset<T, UserAssociationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAssociation.
     * @param {UserAssociationCreateArgs} args - Arguments to create a UserAssociation.
     * @example
     * // Create one UserAssociation
     * const UserAssociation = await prisma.userAssociation.create({
     *   data: {
     *     // ... data to create a UserAssociation
     *   }
     * })
     * 
     */
    create<T extends UserAssociationCreateArgs>(args: SelectSubset<T, UserAssociationCreateArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAssociations.
     * @param {UserAssociationCreateManyArgs} args - Arguments to create many UserAssociations.
     * @example
     * // Create many UserAssociations
     * const userAssociation = await prisma.userAssociation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAssociationCreateManyArgs>(args?: SelectSubset<T, UserAssociationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAssociations and returns the data saved in the database.
     * @param {UserAssociationCreateManyAndReturnArgs} args - Arguments to create many UserAssociations.
     * @example
     * // Create many UserAssociations
     * const userAssociation = await prisma.userAssociation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAssociations and only return the `id`
     * const userAssociationWithIdOnly = await prisma.userAssociation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAssociationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAssociationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAssociation.
     * @param {UserAssociationDeleteArgs} args - Arguments to delete one UserAssociation.
     * @example
     * // Delete one UserAssociation
     * const UserAssociation = await prisma.userAssociation.delete({
     *   where: {
     *     // ... filter to delete one UserAssociation
     *   }
     * })
     * 
     */
    delete<T extends UserAssociationDeleteArgs>(args: SelectSubset<T, UserAssociationDeleteArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAssociation.
     * @param {UserAssociationUpdateArgs} args - Arguments to update one UserAssociation.
     * @example
     * // Update one UserAssociation
     * const userAssociation = await prisma.userAssociation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAssociationUpdateArgs>(args: SelectSubset<T, UserAssociationUpdateArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAssociations.
     * @param {UserAssociationDeleteManyArgs} args - Arguments to filter UserAssociations to delete.
     * @example
     * // Delete a few UserAssociations
     * const { count } = await prisma.userAssociation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAssociationDeleteManyArgs>(args?: SelectSubset<T, UserAssociationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssociationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAssociations
     * const userAssociation = await prisma.userAssociation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAssociationUpdateManyArgs>(args: SelectSubset<T, UserAssociationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAssociations and returns the data updated in the database.
     * @param {UserAssociationUpdateManyAndReturnArgs} args - Arguments to update many UserAssociations.
     * @example
     * // Update many UserAssociations
     * const userAssociation = await prisma.userAssociation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAssociations and only return the `id`
     * const userAssociationWithIdOnly = await prisma.userAssociation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAssociationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAssociationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAssociation.
     * @param {UserAssociationUpsertArgs} args - Arguments to update or create a UserAssociation.
     * @example
     * // Update or create a UserAssociation
     * const userAssociation = await prisma.userAssociation.upsert({
     *   create: {
     *     // ... data to create a UserAssociation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAssociation we want to update
     *   }
     * })
     */
    upsert<T extends UserAssociationUpsertArgs>(args: SelectSubset<T, UserAssociationUpsertArgs<ExtArgs>>): Prisma__UserAssociationClient<$Result.GetResult<Prisma.$UserAssociationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssociationCountArgs} args - Arguments to filter UserAssociations to count.
     * @example
     * // Count the number of UserAssociations
     * const count = await prisma.userAssociation.count({
     *   where: {
     *     // ... the filter for the UserAssociations we want to count
     *   }
     * })
    **/
    count<T extends UserAssociationCountArgs>(
      args?: Subset<T, UserAssociationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAssociationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssociationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAssociationAggregateArgs>(args: Subset<T, UserAssociationAggregateArgs>): Prisma.PrismaPromise<GetUserAssociationAggregateType<T>>

    /**
     * Group by UserAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssociationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAssociationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAssociationGroupByArgs['orderBy'] }
        : { orderBy?: UserAssociationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAssociationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAssociationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAssociation model
   */
  readonly fields: UserAssociationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAssociation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAssociationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAssociation model
   */
  interface UserAssociationFieldRefs {
    readonly id: FieldRef<"UserAssociation", 'String'>
    readonly seq: FieldRef<"UserAssociation", 'Int'>
    readonly createdAt: FieldRef<"UserAssociation", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAssociation", 'DateTime'>
    readonly removedAt: FieldRef<"UserAssociation", 'DateTime'>
    readonly userId: FieldRef<"UserAssociation", 'String'>
    readonly groupId: FieldRef<"UserAssociation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAssociation findUnique
   */
  export type UserAssociationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * Filter, which UserAssociation to fetch.
     */
    where: UserAssociationWhereUniqueInput
  }

  /**
   * UserAssociation findUniqueOrThrow
   */
  export type UserAssociationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * Filter, which UserAssociation to fetch.
     */
    where: UserAssociationWhereUniqueInput
  }

  /**
   * UserAssociation findFirst
   */
  export type UserAssociationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * Filter, which UserAssociation to fetch.
     */
    where?: UserAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssociations to fetch.
     */
    orderBy?: UserAssociationOrderByWithRelationInput | UserAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAssociations.
     */
    cursor?: UserAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAssociations.
     */
    distinct?: UserAssociationScalarFieldEnum | UserAssociationScalarFieldEnum[]
  }

  /**
   * UserAssociation findFirstOrThrow
   */
  export type UserAssociationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * Filter, which UserAssociation to fetch.
     */
    where?: UserAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssociations to fetch.
     */
    orderBy?: UserAssociationOrderByWithRelationInput | UserAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAssociations.
     */
    cursor?: UserAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAssociations.
     */
    distinct?: UserAssociationScalarFieldEnum | UserAssociationScalarFieldEnum[]
  }

  /**
   * UserAssociation findMany
   */
  export type UserAssociationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * Filter, which UserAssociations to fetch.
     */
    where?: UserAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssociations to fetch.
     */
    orderBy?: UserAssociationOrderByWithRelationInput | UserAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAssociations.
     */
    cursor?: UserAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssociations.
     */
    skip?: number
    distinct?: UserAssociationScalarFieldEnum | UserAssociationScalarFieldEnum[]
  }

  /**
   * UserAssociation create
   */
  export type UserAssociationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAssociation.
     */
    data: XOR<UserAssociationCreateInput, UserAssociationUncheckedCreateInput>
  }

  /**
   * UserAssociation createMany
   */
  export type UserAssociationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAssociations.
     */
    data: UserAssociationCreateManyInput | UserAssociationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAssociation createManyAndReturn
   */
  export type UserAssociationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * The data used to create many UserAssociations.
     */
    data: UserAssociationCreateManyInput | UserAssociationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAssociation update
   */
  export type UserAssociationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAssociation.
     */
    data: XOR<UserAssociationUpdateInput, UserAssociationUncheckedUpdateInput>
    /**
     * Choose, which UserAssociation to update.
     */
    where: UserAssociationWhereUniqueInput
  }

  /**
   * UserAssociation updateMany
   */
  export type UserAssociationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAssociations.
     */
    data: XOR<UserAssociationUpdateManyMutationInput, UserAssociationUncheckedUpdateManyInput>
    /**
     * Filter which UserAssociations to update
     */
    where?: UserAssociationWhereInput
    /**
     * Limit how many UserAssociations to update.
     */
    limit?: number
  }

  /**
   * UserAssociation updateManyAndReturn
   */
  export type UserAssociationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * The data used to update UserAssociations.
     */
    data: XOR<UserAssociationUpdateManyMutationInput, UserAssociationUncheckedUpdateManyInput>
    /**
     * Filter which UserAssociations to update
     */
    where?: UserAssociationWhereInput
    /**
     * Limit how many UserAssociations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAssociation upsert
   */
  export type UserAssociationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAssociation to update in case it exists.
     */
    where: UserAssociationWhereUniqueInput
    /**
     * In case the UserAssociation found by the `where` argument doesn't exist, create a new UserAssociation with this data.
     */
    create: XOR<UserAssociationCreateInput, UserAssociationUncheckedCreateInput>
    /**
     * In case the UserAssociation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAssociationUpdateInput, UserAssociationUncheckedUpdateInput>
  }

  /**
   * UserAssociation delete
   */
  export type UserAssociationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
    /**
     * Filter which UserAssociation to delete.
     */
    where: UserAssociationWhereUniqueInput
  }

  /**
   * UserAssociation deleteMany
   */
  export type UserAssociationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAssociations to delete
     */
    where?: UserAssociationWhereInput
    /**
     * Limit how many UserAssociations to delete.
     */
    limit?: number
  }

  /**
   * UserAssociation without action
   */
  export type UserAssociationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssociation
     */
    select?: UserAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssociation
     */
    omit?: UserAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssociationInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    seq: number | null
  }

  export type ProfileSumAggregateOutputType = {
    seq: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    nickname: string | null
    userId: string | null
    avatarFileId: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    seq: number | null
    createdAt: Date | null
    updatedAt: Date | null
    removedAt: Date | null
    name: string | null
    nickname: string | null
    userId: string | null
    avatarFileId: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    seq: number
    createdAt: number
    updatedAt: number
    removedAt: number
    name: number
    nickname: number
    userId: number
    avatarFileId: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    seq?: true
  }

  export type ProfileSumAggregateInputType = {
    seq?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    nickname?: true
    userId?: true
    avatarFileId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    nickname?: true
    userId?: true
    avatarFileId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    seq?: true
    createdAt?: true
    updatedAt?: true
    removedAt?: true
    name?: true
    nickname?: true
    userId?: true
    avatarFileId?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    seq: number
    createdAt: Date
    updatedAt: Date | null
    removedAt: Date | null
    name: string
    nickname: string
    userId: string
    avatarFileId: string | null
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    nickname?: boolean
    userId?: boolean
    avatarFileId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    nickname?: boolean
    userId?: boolean
    avatarFileId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    nickname?: boolean
    userId?: boolean
    avatarFileId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    removedAt?: boolean
    name?: boolean
    nickname?: boolean
    userId?: boolean
    avatarFileId?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seq" | "createdAt" | "updatedAt" | "removedAt" | "name" | "nickname" | "userId" | "avatarFileId", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seq: number
      createdAt: Date
      updatedAt: Date | null
      removedAt: Date | null
      name: string
      nickname: string
      userId: string
      avatarFileId: string | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly seq: FieldRef<"Profile", 'Int'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly removedAt: FieldRef<"Profile", 'DateTime'>
    readonly name: FieldRef<"Profile", 'String'>
    readonly nickname: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly avatarFileId: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name',
    type: 'type',
    parentId: 'parentId',
    tenantId: 'tenantId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name',
    type: 'type',
    label: 'label',
    tenantId: 'tenantId'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    duration: 'duration',
    count: 'count',
    taskId: 'taskId',
    description: 'description',
    imageFileId: 'imageFileId',
    videoFileId: 'videoFileId',
    name: 'name'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    userId: 'userId',
    spaceId: 'spaceId',
    roleId: 'roleId',
    main: 'main'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TimelineScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    tenantId: 'tenantId'
  };

  export type TimelineScalarFieldEnum = (typeof TimelineScalarFieldEnum)[keyof typeof TimelineScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    type: 'type',
    repeatCycleType: 'repeatCycleType',
    startDateTime: 'startDateTime',
    endDateTime: 'endDateTime',
    recurringDayOfWeek: 'recurringDayOfWeek',
    recurringMonth: 'recurringMonth',
    timelineId: 'timelineId',
    label: 'label',
    name: 'name'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    routineId: 'routineId',
    sessionId: 'sessionId',
    instructorId: 'instructorId',
    capacity: 'capacity'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    routineId: 'routineId',
    taskId: 'taskId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const RoutineScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name',
    label: 'label'
  };

  export type RoutineScalarFieldEnum = (typeof RoutineScalarFieldEnum)[keyof typeof RoutineScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    tenantId: 'tenantId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    roleId: 'roleId',
    tenantId: 'tenantId'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name',
    conditions: 'conditions',
    tenantId: 'tenantId'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name',
    tenantId: 'tenantId'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const AbilityScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    type: 'type',
    roleId: 'roleId',
    description: 'description',
    conditions: 'conditions',
    subjectId: 'subjectId',
    tenantId: 'tenantId'
  };

  export type AbilityScalarFieldEnum = (typeof AbilityScalarFieldEnum)[keyof typeof AbilityScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    contentId: 'contentId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ContentScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    title: 'title',
    description: 'description',
    type: 'type',
    text: 'text',
    fileId: 'fileId',
    tenantId: 'tenantId'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    name: 'name',
    size: 'size',
    parentId: 'parentId',
    mimeType: 'mimeType',
    url: 'url',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const FileClassificationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    categoryId: 'categoryId',
    fileId: 'fileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt'
  };

  export type FileClassificationScalarFieldEnum = (typeof FileClassificationScalarFieldEnum)[keyof typeof FileClassificationScalarFieldEnum]


  export const FileAssociationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    fileId: 'fileId',
    groupId: 'groupId'
  };

  export type FileAssociationScalarFieldEnum = (typeof FileAssociationScalarFieldEnum)[keyof typeof FileAssociationScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RoleAssociationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    roleId: 'roleId',
    groupId: 'groupId'
  };

  export type RoleAssociationScalarFieldEnum = (typeof RoleAssociationScalarFieldEnum)[keyof typeof RoleAssociationScalarFieldEnum]


  export const RoleClassificationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    categoryId: 'categoryId',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt'
  };

  export type RoleClassificationScalarFieldEnum = (typeof RoleClassificationScalarFieldEnum)[keyof typeof RoleClassificationScalarFieldEnum]


  export const SpaceScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt'
  };

  export type SpaceScalarFieldEnum = (typeof SpaceScalarFieldEnum)[keyof typeof SpaceScalarFieldEnum]


  export const SpaceClassificationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    categoryId: 'categoryId',
    spaceId: 'spaceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt'
  };

  export type SpaceClassificationScalarFieldEnum = (typeof SpaceClassificationScalarFieldEnum)[keyof typeof SpaceClassificationScalarFieldEnum]


  export const SpaceAssociationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    spaceId: 'spaceId',
    groupId: 'groupId'
  };

  export type SpaceAssociationScalarFieldEnum = (typeof SpaceAssociationScalarFieldEnum)[keyof typeof SpaceAssociationScalarFieldEnum]


  export const GroundScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name',
    label: 'label',
    address: 'address',
    phone: 'phone',
    email: 'email',
    businessNo: 'businessNo',
    spaceId: 'spaceId',
    logoImageFileId: 'logoImageFileId',
    imageFileId: 'imageFileId'
  };

  export type GroundScalarFieldEnum = (typeof GroundScalarFieldEnum)[keyof typeof GroundScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    removedAt: 'removedAt',
    phone: 'phone',
    name: 'name',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserClassificationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    categoryId: 'categoryId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt'
  };

  export type UserClassificationScalarFieldEnum = (typeof UserClassificationScalarFieldEnum)[keyof typeof UserClassificationScalarFieldEnum]


  export const UserAssociationScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    userId: 'userId',
    groupId: 'groupId'
  };

  export type UserAssociationScalarFieldEnum = (typeof UserAssociationScalarFieldEnum)[keyof typeof UserAssociationScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    removedAt: 'removedAt',
    name: 'name',
    nickname: 'nickname',
    userId: 'userId',
    avatarFileId: 'avatarFileId'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CategoryTypes'
   */
  export type EnumCategoryTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryTypes'>
    


  /**
   * Reference to a field of type 'CategoryTypes[]'
   */
  export type ListEnumCategoryTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryTypes[]'>
    


  /**
   * Reference to a field of type 'GroupTypes'
   */
  export type EnumGroupTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupTypes'>
    


  /**
   * Reference to a field of type 'GroupTypes[]'
   */
  export type ListEnumGroupTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupTypes[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SessionTypes'
   */
  export type EnumSessionTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionTypes'>
    


  /**
   * Reference to a field of type 'SessionTypes[]'
   */
  export type ListEnumSessionTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionTypes[]'>
    


  /**
   * Reference to a field of type 'RepeatCycleTypes'
   */
  export type EnumRepeatCycleTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RepeatCycleTypes'>
    


  /**
   * Reference to a field of type 'RepeatCycleTypes[]'
   */
  export type ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RepeatCycleTypes[]'>
    


  /**
   * Reference to a field of type 'RecurringDayOfWeek'
   */
  export type EnumRecurringDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringDayOfWeek'>
    


  /**
   * Reference to a field of type 'RecurringDayOfWeek[]'
   */
  export type ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringDayOfWeek[]'>
    


  /**
   * Reference to a field of type 'AbilityActions'
   */
  export type EnumAbilityActionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbilityActions'>
    


  /**
   * Reference to a field of type 'AbilityActions[]'
   */
  export type ListEnumAbilityActionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbilityActions[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AbilityTypes'
   */
  export type EnumAbilityTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbilityTypes'>
    


  /**
   * Reference to a field of type 'AbilityTypes[]'
   */
  export type ListEnumAbilityTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbilityTypes[]'>
    


  /**
   * Reference to a field of type 'TextTypes'
   */
  export type EnumTextTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextTypes'>
    


  /**
   * Reference to a field of type 'TextTypes[]'
   */
  export type ListEnumTextTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextTypes[]'>
    


  /**
   * Reference to a field of type 'Roles'
   */
  export type EnumRolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Roles'>
    


  /**
   * Reference to a field of type 'Roles[]'
   */
  export type ListEnumRolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Roles[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    seq?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    name?: StringFilter<"Category"> | string
    type?: EnumCategoryTypesFilter<"Category"> | $Enums.CategoryTypes
    parentId?: StringNullableFilter<"Category"> | string | null
    tenantId?: StringFilter<"Category"> | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    fileClassifications?: FileClassificationListRelationFilter
    roleClassifications?: RoleClassificationListRelationFilter
    spaceClassifications?: SpaceClassificationListRelationFilter
    userClassifications?: UserClassificationListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    fileClassifications?: FileClassificationOrderByRelationAggregateInput
    roleClassifications?: RoleClassificationOrderByRelationAggregateInput
    spaceClassifications?: SpaceClassificationOrderByRelationAggregateInput
    userClassifications?: UserClassificationOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    type?: EnumCategoryTypesFilter<"Category"> | $Enums.CategoryTypes
    parentId?: StringNullableFilter<"Category"> | string | null
    tenantId?: StringFilter<"Category"> | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    fileClassifications?: FileClassificationListRelationFilter
    roleClassifications?: RoleClassificationListRelationFilter
    spaceClassifications?: SpaceClassificationListRelationFilter
    userClassifications?: UserClassificationListRelationFilter
  }, "id" | "seq" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    seq?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    name?: StringWithAggregatesFilter<"Category"> | string
    type?: EnumCategoryTypesWithAggregatesFilter<"Category"> | $Enums.CategoryTypes
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    tenantId?: StringWithAggregatesFilter<"Category"> | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    seq?: IntFilter<"Group"> | number
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Group"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Group"> | Date | string | null
    name?: StringFilter<"Group"> | string
    type?: EnumGroupTypesFilter<"Group"> | $Enums.GroupTypes
    label?: StringNullableFilter<"Group"> | string | null
    tenantId?: StringFilter<"Group"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    fileAssociations?: FileAssociationListRelationFilter
    roleAssociations?: RoleAssociationListRelationFilter
    spaceAssociations?: SpaceAssociationListRelationFilter
    userAssociations?: UserAssociationListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    label?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    fileAssociations?: FileAssociationOrderByRelationAggregateInput
    roleAssociations?: RoleAssociationOrderByRelationAggregateInput
    spaceAssociations?: SpaceAssociationOrderByRelationAggregateInput
    userAssociations?: UserAssociationOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Group"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Group"> | Date | string | null
    name?: StringFilter<"Group"> | string
    type?: EnumGroupTypesFilter<"Group"> | $Enums.GroupTypes
    label?: StringNullableFilter<"Group"> | string | null
    tenantId?: StringFilter<"Group"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    fileAssociations?: FileAssociationListRelationFilter
    roleAssociations?: RoleAssociationListRelationFilter
    spaceAssociations?: SpaceAssociationListRelationFilter
    userAssociations?: UserAssociationListRelationFilter
  }, "id" | "seq">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    label?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    seq?: IntWithAggregatesFilter<"Group"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Group"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Group"> | Date | string | null
    name?: StringWithAggregatesFilter<"Group"> | string
    type?: EnumGroupTypesWithAggregatesFilter<"Group"> | $Enums.GroupTypes
    label?: StringNullableWithAggregatesFilter<"Group"> | string | null
    tenantId?: StringWithAggregatesFilter<"Group"> | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
    seq?: IntFilter<"Exercise"> | number
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    duration?: IntFilter<"Exercise"> | number
    count?: IntFilter<"Exercise"> | number
    taskId?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    imageFileId?: StringNullableFilter<"Exercise"> | string | null
    videoFileId?: StringNullableFilter<"Exercise"> | string | null
    name?: StringFilter<"Exercise"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    duration?: SortOrder
    count?: SortOrder
    taskId?: SortOrder
    description?: SortOrderInput | SortOrder
    imageFileId?: SortOrderInput | SortOrder
    videoFileId?: SortOrderInput | SortOrder
    name?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    taskId?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    duration?: IntFilter<"Exercise"> | number
    count?: IntFilter<"Exercise"> | number
    description?: StringNullableFilter<"Exercise"> | string | null
    imageFileId?: StringNullableFilter<"Exercise"> | string | null
    videoFileId?: StringNullableFilter<"Exercise"> | string | null
    name?: StringFilter<"Exercise"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "seq" | "taskId">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    duration?: SortOrder
    count?: SortOrder
    taskId?: SortOrder
    description?: SortOrderInput | SortOrder
    imageFileId?: SortOrderInput | SortOrder
    videoFileId?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
    seq?: IntWithAggregatesFilter<"Exercise"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Exercise"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Exercise"> | Date | string | null
    duration?: IntWithAggregatesFilter<"Exercise"> | number
    count?: IntWithAggregatesFilter<"Exercise"> | number
    taskId?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    imageFileId?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    videoFileId?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    name?: StringWithAggregatesFilter<"Exercise"> | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    seq?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    userId?: StringFilter<"Tenant"> | string
    spaceId?: StringFilter<"Tenant"> | string
    roleId?: StringFilter<"Tenant"> | string
    main?: BoolFilter<"Tenant"> | boolean
    assignments?: AssignmentListRelationFilter
    categories?: CategoryListRelationFilter
    contents?: ContentListRelationFilter
    files?: FileListRelationFilter
    groups?: GroupListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    timelines?: TimelineListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    roleId?: SortOrder
    main?: SortOrder
    assignments?: AssignmentOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    contents?: ContentOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    groups?: GroupOrderByRelationAggregateInput
    role?: RoleOrderByWithRelationInput
    space?: SpaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    timelines?: TimelineOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    userId?: StringFilter<"Tenant"> | string
    spaceId?: StringFilter<"Tenant"> | string
    roleId?: StringFilter<"Tenant"> | string
    main?: BoolFilter<"Tenant"> | boolean
    assignments?: AssignmentListRelationFilter
    categories?: CategoryListRelationFilter
    contents?: ContentListRelationFilter
    files?: FileListRelationFilter
    groups?: GroupListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    timelines?: TimelineListRelationFilter
  }, "id" | "seq">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    roleId?: SortOrder
    main?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    seq?: IntWithAggregatesFilter<"Tenant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Tenant"> | string
    spaceId?: StringWithAggregatesFilter<"Tenant"> | string
    roleId?: StringWithAggregatesFilter<"Tenant"> | string
    main?: BoolWithAggregatesFilter<"Tenant"> | boolean
  }

  export type TimelineWhereInput = {
    AND?: TimelineWhereInput | TimelineWhereInput[]
    OR?: TimelineWhereInput[]
    NOT?: TimelineWhereInput | TimelineWhereInput[]
    id?: StringFilter<"Timeline"> | string
    seq?: IntFilter<"Timeline"> | number
    createdAt?: DateTimeFilter<"Timeline"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Timeline"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Timeline"> | Date | string | null
    tenantId?: StringFilter<"Timeline"> | string
    sessions?: SessionListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TimelineOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type TimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: TimelineWhereInput | TimelineWhereInput[]
    OR?: TimelineWhereInput[]
    NOT?: TimelineWhereInput | TimelineWhereInput[]
    createdAt?: DateTimeFilter<"Timeline"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Timeline"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Timeline"> | Date | string | null
    tenantId?: StringFilter<"Timeline"> | string
    sessions?: SessionListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "seq">

  export type TimelineOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    _count?: TimelineCountOrderByAggregateInput
    _avg?: TimelineAvgOrderByAggregateInput
    _max?: TimelineMaxOrderByAggregateInput
    _min?: TimelineMinOrderByAggregateInput
    _sum?: TimelineSumOrderByAggregateInput
  }

  export type TimelineScalarWhereWithAggregatesInput = {
    AND?: TimelineScalarWhereWithAggregatesInput | TimelineScalarWhereWithAggregatesInput[]
    OR?: TimelineScalarWhereWithAggregatesInput[]
    NOT?: TimelineScalarWhereWithAggregatesInput | TimelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Timeline"> | string
    seq?: IntWithAggregatesFilter<"Timeline"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Timeline"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Timeline"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Timeline"> | Date | string | null
    tenantId?: StringWithAggregatesFilter<"Timeline"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    seq?: IntFilter<"Session"> | number
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    type?: EnumSessionTypesFilter<"Session"> | $Enums.SessionTypes
    repeatCycleType?: EnumRepeatCycleTypesNullableFilter<"Session"> | $Enums.RepeatCycleTypes | null
    startDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    endDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    recurringDayOfWeek?: EnumRecurringDayOfWeekNullableFilter<"Session"> | $Enums.RecurringDayOfWeek | null
    recurringMonth?: IntNullableFilter<"Session"> | number | null
    timelineId?: StringFilter<"Session"> | string
    label?: StringFilter<"Session"> | string
    name?: StringFilter<"Session"> | string
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    timeline?: XOR<TimelineScalarRelationFilter, TimelineWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    type?: SortOrder
    repeatCycleType?: SortOrderInput | SortOrder
    startDateTime?: SortOrderInput | SortOrder
    endDateTime?: SortOrderInput | SortOrder
    recurringDayOfWeek?: SortOrderInput | SortOrder
    recurringMonth?: SortOrderInput | SortOrder
    timelineId?: SortOrder
    label?: SortOrder
    name?: SortOrder
    program?: ProgramOrderByWithRelationInput
    timeline?: TimelineOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    type?: EnumSessionTypesFilter<"Session"> | $Enums.SessionTypes
    repeatCycleType?: EnumRepeatCycleTypesNullableFilter<"Session"> | $Enums.RepeatCycleTypes | null
    startDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    endDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    recurringDayOfWeek?: EnumRecurringDayOfWeekNullableFilter<"Session"> | $Enums.RecurringDayOfWeek | null
    recurringMonth?: IntNullableFilter<"Session"> | number | null
    timelineId?: StringFilter<"Session"> | string
    label?: StringFilter<"Session"> | string
    name?: StringFilter<"Session"> | string
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    timeline?: XOR<TimelineScalarRelationFilter, TimelineWhereInput>
  }, "id" | "seq">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    type?: SortOrder
    repeatCycleType?: SortOrderInput | SortOrder
    startDateTime?: SortOrderInput | SortOrder
    endDateTime?: SortOrderInput | SortOrder
    recurringDayOfWeek?: SortOrderInput | SortOrder
    recurringMonth?: SortOrderInput | SortOrder
    timelineId?: SortOrder
    label?: SortOrder
    name?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    seq?: IntWithAggregatesFilter<"Session"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    type?: EnumSessionTypesWithAggregatesFilter<"Session"> | $Enums.SessionTypes
    repeatCycleType?: EnumRepeatCycleTypesNullableWithAggregatesFilter<"Session"> | $Enums.RepeatCycleTypes | null
    startDateTime?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    endDateTime?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    recurringDayOfWeek?: EnumRecurringDayOfWeekNullableWithAggregatesFilter<"Session"> | $Enums.RecurringDayOfWeek | null
    recurringMonth?: IntNullableWithAggregatesFilter<"Session"> | number | null
    timelineId?: StringWithAggregatesFilter<"Session"> | string
    label?: StringWithAggregatesFilter<"Session"> | string
    name?: StringWithAggregatesFilter<"Session"> | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    seq?: IntFilter<"Program"> | number
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    routineId?: StringFilter<"Program"> | string
    sessionId?: StringFilter<"Program"> | string
    instructorId?: StringFilter<"Program"> | string
    capacity?: IntFilter<"Program"> | number
    routine?: XOR<RoutineScalarRelationFilter, RoutineWhereInput>
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    routineId?: SortOrder
    sessionId?: SortOrder
    instructorId?: SortOrder
    capacity?: SortOrder
    routine?: RoutineOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    routineId?: string
    sessionId?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    instructorId?: StringFilter<"Program"> | string
    capacity?: IntFilter<"Program"> | number
    routine?: XOR<RoutineScalarRelationFilter, RoutineWhereInput>
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }, "id" | "seq" | "routineId" | "sessionId">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    routineId?: SortOrder
    sessionId?: SortOrder
    instructorId?: SortOrder
    capacity?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    seq?: IntWithAggregatesFilter<"Program"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    routineId?: StringWithAggregatesFilter<"Program"> | string
    sessionId?: StringWithAggregatesFilter<"Program"> | string
    instructorId?: StringWithAggregatesFilter<"Program"> | string
    capacity?: IntWithAggregatesFilter<"Program"> | number
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    seq?: IntFilter<"Activity"> | number
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    routineId?: StringFilter<"Activity"> | string
    taskId?: StringFilter<"Activity"> | string
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    routineId?: SortOrder
    taskId?: SortOrder
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    routineId_taskId?: ActivityRoutineIdTaskIdCompoundUniqueInput
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    routineId?: StringFilter<"Activity"> | string
    taskId?: StringFilter<"Activity"> | string
  }, "id" | "seq" | "routineId_taskId">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    routineId?: SortOrder
    taskId?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    seq?: IntWithAggregatesFilter<"Activity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    routineId?: StringWithAggregatesFilter<"Activity"> | string
    taskId?: StringWithAggregatesFilter<"Activity"> | string
  }

  export type RoutineWhereInput = {
    AND?: RoutineWhereInput | RoutineWhereInput[]
    OR?: RoutineWhereInput[]
    NOT?: RoutineWhereInput | RoutineWhereInput[]
    id?: StringFilter<"Routine"> | string
    seq?: IntFilter<"Routine"> | number
    createdAt?: DateTimeFilter<"Routine"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Routine"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Routine"> | Date | string | null
    name?: StringFilter<"Routine"> | string
    label?: StringFilter<"Routine"> | string
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }

  export type RoutineOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    label?: SortOrder
    program?: ProgramOrderByWithRelationInput
  }

  export type RoutineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: RoutineWhereInput | RoutineWhereInput[]
    OR?: RoutineWhereInput[]
    NOT?: RoutineWhereInput | RoutineWhereInput[]
    createdAt?: DateTimeFilter<"Routine"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Routine"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Routine"> | Date | string | null
    name?: StringFilter<"Routine"> | string
    label?: StringFilter<"Routine"> | string
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }, "id" | "seq">

  export type RoutineOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    label?: SortOrder
    _count?: RoutineCountOrderByAggregateInput
    _avg?: RoutineAvgOrderByAggregateInput
    _max?: RoutineMaxOrderByAggregateInput
    _min?: RoutineMinOrderByAggregateInput
    _sum?: RoutineSumOrderByAggregateInput
  }

  export type RoutineScalarWhereWithAggregatesInput = {
    AND?: RoutineScalarWhereWithAggregatesInput | RoutineScalarWhereWithAggregatesInput[]
    OR?: RoutineScalarWhereWithAggregatesInput[]
    NOT?: RoutineScalarWhereWithAggregatesInput | RoutineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Routine"> | string
    seq?: IntWithAggregatesFilter<"Routine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Routine"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Routine"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Routine"> | Date | string | null
    name?: StringWithAggregatesFilter<"Routine"> | string
    label?: StringWithAggregatesFilter<"Routine"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    seq?: IntFilter<"Task"> | number
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    tenantId?: StringFilter<"Task"> | string
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    tenantId?: StringFilter<"Task"> | string
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
  }, "id" | "seq">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    seq?: IntWithAggregatesFilter<"Task"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    tenantId?: StringWithAggregatesFilter<"Task"> | string
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    seq?: IntFilter<"Assignment"> | number
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    roleId?: StringFilter<"Assignment"> | string
    tenantId?: StringFilter<"Assignment"> | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
    role?: RoleOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    roleId?: StringFilter<"Assignment"> | string
    tenantId?: StringFilter<"Assignment"> | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "seq">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    seq?: IntWithAggregatesFilter<"Assignment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    roleId?: StringWithAggregatesFilter<"Assignment"> | string
    tenantId?: StringWithAggregatesFilter<"Assignment"> | string
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    id?: StringFilter<"Action"> | string
    seq?: IntFilter<"Action"> | number
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Action"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Action"> | Date | string | null
    name?: EnumAbilityActionsFilter<"Action"> | $Enums.AbilityActions
    conditions?: JsonNullableFilter<"Action">
    tenantId?: StringFilter<"Action"> | string
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    conditions?: SortOrderInput | SortOrder
    tenantId?: SortOrder
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Action"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Action"> | Date | string | null
    name?: EnumAbilityActionsFilter<"Action"> | $Enums.AbilityActions
    conditions?: JsonNullableFilter<"Action">
    tenantId?: StringFilter<"Action"> | string
  }, "id" | "seq">

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    conditions?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Action"> | string
    seq?: IntWithAggregatesFilter<"Action"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Action"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Action"> | Date | string | null
    name?: EnumAbilityActionsWithAggregatesFilter<"Action"> | $Enums.AbilityActions
    conditions?: JsonNullableWithAggregatesFilter<"Action">
    tenantId?: StringWithAggregatesFilter<"Action"> | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    seq?: IntFilter<"Subject"> | number
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Subject"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Subject"> | Date | string | null
    name?: StringFilter<"Subject"> | string
    tenantId?: StringFilter<"Subject"> | string
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    tenantId?: SortOrder
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    name?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Subject"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Subject"> | Date | string | null
    tenantId?: StringFilter<"Subject"> | string
  }, "id" | "seq" | "name">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    seq?: IntWithAggregatesFilter<"Subject"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Subject"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Subject"> | Date | string | null
    name?: StringWithAggregatesFilter<"Subject"> | string
    tenantId?: StringWithAggregatesFilter<"Subject"> | string
  }

  export type AbilityWhereInput = {
    AND?: AbilityWhereInput | AbilityWhereInput[]
    OR?: AbilityWhereInput[]
    NOT?: AbilityWhereInput | AbilityWhereInput[]
    id?: StringFilter<"Ability"> | string
    seq?: IntFilter<"Ability"> | number
    createdAt?: DateTimeFilter<"Ability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Ability"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Ability"> | Date | string | null
    type?: EnumAbilityTypesFilter<"Ability"> | $Enums.AbilityTypes
    roleId?: StringFilter<"Ability"> | string
    description?: StringNullableFilter<"Ability"> | string | null
    conditions?: JsonNullableFilter<"Ability">
    subjectId?: StringFilter<"Ability"> | string
    tenantId?: StringFilter<"Ability"> | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type AbilityOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    type?: SortOrder
    roleId?: SortOrder
    description?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    subjectId?: SortOrder
    tenantId?: SortOrder
    role?: RoleOrderByWithRelationInput
  }

  export type AbilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: AbilityWhereInput | AbilityWhereInput[]
    OR?: AbilityWhereInput[]
    NOT?: AbilityWhereInput | AbilityWhereInput[]
    createdAt?: DateTimeFilter<"Ability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Ability"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Ability"> | Date | string | null
    type?: EnumAbilityTypesFilter<"Ability"> | $Enums.AbilityTypes
    roleId?: StringFilter<"Ability"> | string
    description?: StringNullableFilter<"Ability"> | string | null
    conditions?: JsonNullableFilter<"Ability">
    subjectId?: StringFilter<"Ability"> | string
    tenantId?: StringFilter<"Ability"> | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "seq">

  export type AbilityOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    type?: SortOrder
    roleId?: SortOrder
    description?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    subjectId?: SortOrder
    tenantId?: SortOrder
    _count?: AbilityCountOrderByAggregateInput
    _avg?: AbilityAvgOrderByAggregateInput
    _max?: AbilityMaxOrderByAggregateInput
    _min?: AbilityMinOrderByAggregateInput
    _sum?: AbilitySumOrderByAggregateInput
  }

  export type AbilityScalarWhereWithAggregatesInput = {
    AND?: AbilityScalarWhereWithAggregatesInput | AbilityScalarWhereWithAggregatesInput[]
    OR?: AbilityScalarWhereWithAggregatesInput[]
    NOT?: AbilityScalarWhereWithAggregatesInput | AbilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ability"> | string
    seq?: IntWithAggregatesFilter<"Ability"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Ability"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Ability"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Ability"> | Date | string | null
    type?: EnumAbilityTypesWithAggregatesFilter<"Ability"> | $Enums.AbilityTypes
    roleId?: StringWithAggregatesFilter<"Ability"> | string
    description?: StringNullableWithAggregatesFilter<"Ability"> | string | null
    conditions?: JsonNullableWithAggregatesFilter<"Ability">
    subjectId?: StringWithAggregatesFilter<"Ability"> | string
    tenantId?: StringWithAggregatesFilter<"Ability"> | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    seq?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    contentId?: StringFilter<"Post"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    contentId?: SortOrder
    content?: ContentOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    contentId?: StringFilter<"Post"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }, "id" | "seq">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    contentId?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    seq?: IntWithAggregatesFilter<"Post"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    contentId?: StringWithAggregatesFilter<"Post"> | string
  }

  export type ContentWhereInput = {
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    id?: StringFilter<"Content"> | string
    seq?: IntFilter<"Content"> | number
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    title?: StringNullableFilter<"Content"> | string | null
    description?: StringNullableFilter<"Content"> | string | null
    type?: EnumTextTypesFilter<"Content"> | $Enums.TextTypes
    text?: StringNullableFilter<"Content"> | string | null
    fileId?: StringNullableFilter<"Content"> | string | null
    tenantId?: StringFilter<"Content"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    posts?: PostListRelationFilter
  }

  export type ContentOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    text?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type ContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    title?: StringNullableFilter<"Content"> | string | null
    description?: StringNullableFilter<"Content"> | string | null
    type?: EnumTextTypesFilter<"Content"> | $Enums.TextTypes
    text?: StringNullableFilter<"Content"> | string | null
    fileId?: StringNullableFilter<"Content"> | string | null
    tenantId?: StringFilter<"Content"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    posts?: PostListRelationFilter
  }, "id" | "seq">

  export type ContentOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    text?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    _count?: ContentCountOrderByAggregateInput
    _avg?: ContentAvgOrderByAggregateInput
    _max?: ContentMaxOrderByAggregateInput
    _min?: ContentMinOrderByAggregateInput
    _sum?: ContentSumOrderByAggregateInput
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    OR?: ContentScalarWhereWithAggregatesInput[]
    NOT?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Content"> | string
    seq?: IntWithAggregatesFilter<"Content"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Content"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Content"> | Date | string | null
    title?: StringNullableWithAggregatesFilter<"Content"> | string | null
    description?: StringNullableWithAggregatesFilter<"Content"> | string | null
    type?: EnumTextTypesWithAggregatesFilter<"Content"> | $Enums.TextTypes
    text?: StringNullableWithAggregatesFilter<"Content"> | string | null
    fileId?: StringNullableWithAggregatesFilter<"Content"> | string | null
    tenantId?: StringWithAggregatesFilter<"Content"> | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    seq?: IntFilter<"File"> | number
    name?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    parentId?: StringNullableFilter<"File"> | string | null
    mimeType?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    tenantId?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    parent?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    children?: FileListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    associations?: FileAssociationListRelationFilter
    classification?: XOR<FileClassificationNullableScalarRelationFilter, FileClassificationWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    name?: SortOrder
    size?: SortOrder
    parentId?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    parent?: FileOrderByWithRelationInput
    children?: FileOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    associations?: FileAssociationOrderByRelationAggregateInput
    classification?: FileClassificationOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    parentId?: StringNullableFilter<"File"> | string | null
    mimeType?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    tenantId?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    parent?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    children?: FileListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    associations?: FileAssociationListRelationFilter
    classification?: XOR<FileClassificationNullableScalarRelationFilter, FileClassificationWhereInput> | null
  }, "id" | "seq">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    name?: SortOrder
    size?: SortOrder
    parentId?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    seq?: IntWithAggregatesFilter<"File"> | number
    name?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    parentId?: StringNullableWithAggregatesFilter<"File"> | string | null
    mimeType?: StringWithAggregatesFilter<"File"> | string
    url?: StringWithAggregatesFilter<"File"> | string
    tenantId?: StringWithAggregatesFilter<"File"> | string
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null
  }

  export type FileClassificationWhereInput = {
    AND?: FileClassificationWhereInput | FileClassificationWhereInput[]
    OR?: FileClassificationWhereInput[]
    NOT?: FileClassificationWhereInput | FileClassificationWhereInput[]
    id?: StringFilter<"FileClassification"> | string
    seq?: IntFilter<"FileClassification"> | number
    categoryId?: StringFilter<"FileClassification"> | string
    fileId?: StringFilter<"FileClassification"> | string
    createdAt?: DateTimeFilter<"FileClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FileClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"FileClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }

  export type FileClassificationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    file?: FileOrderByWithRelationInput
  }

  export type FileClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    fileId?: string
    categoryId_fileId?: FileClassificationCategoryIdFileIdCompoundUniqueInput
    AND?: FileClassificationWhereInput | FileClassificationWhereInput[]
    OR?: FileClassificationWhereInput[]
    NOT?: FileClassificationWhereInput | FileClassificationWhereInput[]
    categoryId?: StringFilter<"FileClassification"> | string
    createdAt?: DateTimeFilter<"FileClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FileClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"FileClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }, "id" | "seq" | "fileId" | "categoryId_fileId">

  export type FileClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    _count?: FileClassificationCountOrderByAggregateInput
    _avg?: FileClassificationAvgOrderByAggregateInput
    _max?: FileClassificationMaxOrderByAggregateInput
    _min?: FileClassificationMinOrderByAggregateInput
    _sum?: FileClassificationSumOrderByAggregateInput
  }

  export type FileClassificationScalarWhereWithAggregatesInput = {
    AND?: FileClassificationScalarWhereWithAggregatesInput | FileClassificationScalarWhereWithAggregatesInput[]
    OR?: FileClassificationScalarWhereWithAggregatesInput[]
    NOT?: FileClassificationScalarWhereWithAggregatesInput | FileClassificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileClassification"> | string
    seq?: IntWithAggregatesFilter<"FileClassification"> | number
    categoryId?: StringWithAggregatesFilter<"FileClassification"> | string
    fileId?: StringWithAggregatesFilter<"FileClassification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FileClassification"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"FileClassification"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"FileClassification"> | Date | string | null
  }

  export type FileAssociationWhereInput = {
    AND?: FileAssociationWhereInput | FileAssociationWhereInput[]
    OR?: FileAssociationWhereInput[]
    NOT?: FileAssociationWhereInput | FileAssociationWhereInput[]
    id?: StringFilter<"FileAssociation"> | string
    seq?: IntFilter<"FileAssociation"> | number
    createdAt?: DateTimeFilter<"FileAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FileAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"FileAssociation"> | Date | string | null
    fileId?: StringFilter<"FileAssociation"> | string
    groupId?: StringFilter<"FileAssociation"> | string
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type FileAssociationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    fileId?: SortOrder
    groupId?: SortOrder
    file?: FileOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type FileAssociationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    groupId_fileId?: FileAssociationGroupIdFileIdCompoundUniqueInput
    AND?: FileAssociationWhereInput | FileAssociationWhereInput[]
    OR?: FileAssociationWhereInput[]
    NOT?: FileAssociationWhereInput | FileAssociationWhereInput[]
    createdAt?: DateTimeFilter<"FileAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FileAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"FileAssociation"> | Date | string | null
    fileId?: StringFilter<"FileAssociation"> | string
    groupId?: StringFilter<"FileAssociation"> | string
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id" | "seq" | "groupId_fileId">

  export type FileAssociationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    fileId?: SortOrder
    groupId?: SortOrder
    _count?: FileAssociationCountOrderByAggregateInput
    _avg?: FileAssociationAvgOrderByAggregateInput
    _max?: FileAssociationMaxOrderByAggregateInput
    _min?: FileAssociationMinOrderByAggregateInput
    _sum?: FileAssociationSumOrderByAggregateInput
  }

  export type FileAssociationScalarWhereWithAggregatesInput = {
    AND?: FileAssociationScalarWhereWithAggregatesInput | FileAssociationScalarWhereWithAggregatesInput[]
    OR?: FileAssociationScalarWhereWithAggregatesInput[]
    NOT?: FileAssociationScalarWhereWithAggregatesInput | FileAssociationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileAssociation"> | string
    seq?: IntWithAggregatesFilter<"FileAssociation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FileAssociation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"FileAssociation"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"FileAssociation"> | Date | string | null
    fileId?: StringWithAggregatesFilter<"FileAssociation"> | string
    groupId?: StringWithAggregatesFilter<"FileAssociation"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    seq?: IntFilter<"Role"> | number
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    name?: EnumRolesFilter<"Role"> | $Enums.Roles
    abilities?: AbilityListRelationFilter
    assignments?: AssignmentListRelationFilter
    associations?: RoleAssociationListRelationFilter
    classification?: XOR<RoleClassificationNullableScalarRelationFilter, RoleClassificationWhereInput> | null
    tenants?: TenantListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    abilities?: AbilityOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    associations?: RoleAssociationOrderByRelationAggregateInput
    classification?: RoleClassificationOrderByWithRelationInput
    tenants?: TenantOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    name?: $Enums.Roles
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    abilities?: AbilityListRelationFilter
    assignments?: AssignmentListRelationFilter
    associations?: RoleAssociationListRelationFilter
    classification?: XOR<RoleClassificationNullableScalarRelationFilter, RoleClassificationWhereInput> | null
    tenants?: TenantListRelationFilter
  }, "id" | "seq" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    seq?: IntWithAggregatesFilter<"Role"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    name?: EnumRolesWithAggregatesFilter<"Role"> | $Enums.Roles
  }

  export type RoleAssociationWhereInput = {
    AND?: RoleAssociationWhereInput | RoleAssociationWhereInput[]
    OR?: RoleAssociationWhereInput[]
    NOT?: RoleAssociationWhereInput | RoleAssociationWhereInput[]
    id?: StringFilter<"RoleAssociation"> | string
    seq?: IntFilter<"RoleAssociation"> | number
    createdAt?: DateTimeFilter<"RoleAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RoleAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RoleAssociation"> | Date | string | null
    roleId?: StringFilter<"RoleAssociation"> | string
    groupId?: StringFilter<"RoleAssociation"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type RoleAssociationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    groupId?: SortOrder
    group?: GroupOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type RoleAssociationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    roleId?: string
    groupId_roleId?: RoleAssociationGroupIdRoleIdCompoundUniqueInput
    AND?: RoleAssociationWhereInput | RoleAssociationWhereInput[]
    OR?: RoleAssociationWhereInput[]
    NOT?: RoleAssociationWhereInput | RoleAssociationWhereInput[]
    createdAt?: DateTimeFilter<"RoleAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RoleAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RoleAssociation"> | Date | string | null
    groupId?: StringFilter<"RoleAssociation"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "seq" | "roleId" | "groupId_roleId">

  export type RoleAssociationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    groupId?: SortOrder
    _count?: RoleAssociationCountOrderByAggregateInput
    _avg?: RoleAssociationAvgOrderByAggregateInput
    _max?: RoleAssociationMaxOrderByAggregateInput
    _min?: RoleAssociationMinOrderByAggregateInput
    _sum?: RoleAssociationSumOrderByAggregateInput
  }

  export type RoleAssociationScalarWhereWithAggregatesInput = {
    AND?: RoleAssociationScalarWhereWithAggregatesInput | RoleAssociationScalarWhereWithAggregatesInput[]
    OR?: RoleAssociationScalarWhereWithAggregatesInput[]
    NOT?: RoleAssociationScalarWhereWithAggregatesInput | RoleAssociationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleAssociation"> | string
    seq?: IntWithAggregatesFilter<"RoleAssociation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoleAssociation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RoleAssociation"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"RoleAssociation"> | Date | string | null
    roleId?: StringWithAggregatesFilter<"RoleAssociation"> | string
    groupId?: StringWithAggregatesFilter<"RoleAssociation"> | string
  }

  export type RoleClassificationWhereInput = {
    AND?: RoleClassificationWhereInput | RoleClassificationWhereInput[]
    OR?: RoleClassificationWhereInput[]
    NOT?: RoleClassificationWhereInput | RoleClassificationWhereInput[]
    id?: StringFilter<"RoleClassification"> | string
    seq?: IntFilter<"RoleClassification"> | number
    categoryId?: StringFilter<"RoleClassification"> | string
    roleId?: StringFilter<"RoleClassification"> | string
    createdAt?: DateTimeFilter<"RoleClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RoleClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RoleClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type RoleClassificationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type RoleClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    roleId?: string
    categoryId_roleId?: RoleClassificationCategoryIdRoleIdCompoundUniqueInput
    AND?: RoleClassificationWhereInput | RoleClassificationWhereInput[]
    OR?: RoleClassificationWhereInput[]
    NOT?: RoleClassificationWhereInput | RoleClassificationWhereInput[]
    categoryId?: StringFilter<"RoleClassification"> | string
    createdAt?: DateTimeFilter<"RoleClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RoleClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RoleClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "seq" | "roleId" | "categoryId_roleId">

  export type RoleClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    _count?: RoleClassificationCountOrderByAggregateInput
    _avg?: RoleClassificationAvgOrderByAggregateInput
    _max?: RoleClassificationMaxOrderByAggregateInput
    _min?: RoleClassificationMinOrderByAggregateInput
    _sum?: RoleClassificationSumOrderByAggregateInput
  }

  export type RoleClassificationScalarWhereWithAggregatesInput = {
    AND?: RoleClassificationScalarWhereWithAggregatesInput | RoleClassificationScalarWhereWithAggregatesInput[]
    OR?: RoleClassificationScalarWhereWithAggregatesInput[]
    NOT?: RoleClassificationScalarWhereWithAggregatesInput | RoleClassificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleClassification"> | string
    seq?: IntWithAggregatesFilter<"RoleClassification"> | number
    categoryId?: StringWithAggregatesFilter<"RoleClassification"> | string
    roleId?: StringWithAggregatesFilter<"RoleClassification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RoleClassification"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RoleClassification"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"RoleClassification"> | Date | string | null
  }

  export type SpaceWhereInput = {
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    id?: StringFilter<"Space"> | string
    seq?: IntFilter<"Space"> | number
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Space"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Space"> | Date | string | null
    ground?: XOR<GroundNullableScalarRelationFilter, GroundWhereInput> | null
    associations?: SpaceAssociationListRelationFilter
    classification?: XOR<SpaceClassificationNullableScalarRelationFilter, SpaceClassificationWhereInput> | null
    tenants?: TenantListRelationFilter
  }

  export type SpaceOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    ground?: GroundOrderByWithRelationInput
    associations?: SpaceAssociationOrderByRelationAggregateInput
    classification?: SpaceClassificationOrderByWithRelationInput
    tenants?: TenantOrderByRelationAggregateInput
  }

  export type SpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Space"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Space"> | Date | string | null
    ground?: XOR<GroundNullableScalarRelationFilter, GroundWhereInput> | null
    associations?: SpaceAssociationListRelationFilter
    classification?: XOR<SpaceClassificationNullableScalarRelationFilter, SpaceClassificationWhereInput> | null
    tenants?: TenantListRelationFilter
  }, "id" | "seq">

  export type SpaceOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    _count?: SpaceCountOrderByAggregateInput
    _avg?: SpaceAvgOrderByAggregateInput
    _max?: SpaceMaxOrderByAggregateInput
    _min?: SpaceMinOrderByAggregateInput
    _sum?: SpaceSumOrderByAggregateInput
  }

  export type SpaceScalarWhereWithAggregatesInput = {
    AND?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    OR?: SpaceScalarWhereWithAggregatesInput[]
    NOT?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Space"> | string
    seq?: IntWithAggregatesFilter<"Space"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Space"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Space"> | Date | string | null
  }

  export type SpaceClassificationWhereInput = {
    AND?: SpaceClassificationWhereInput | SpaceClassificationWhereInput[]
    OR?: SpaceClassificationWhereInput[]
    NOT?: SpaceClassificationWhereInput | SpaceClassificationWhereInput[]
    id?: StringFilter<"SpaceClassification"> | string
    seq?: IntFilter<"SpaceClassification"> | number
    categoryId?: StringFilter<"SpaceClassification"> | string
    spaceId?: StringFilter<"SpaceClassification"> | string
    createdAt?: DateTimeFilter<"SpaceClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SpaceClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"SpaceClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
  }

  export type SpaceClassificationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    space?: SpaceOrderByWithRelationInput
  }

  export type SpaceClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    spaceId?: string
    categoryId_spaceId?: SpaceClassificationCategoryIdSpaceIdCompoundUniqueInput
    AND?: SpaceClassificationWhereInput | SpaceClassificationWhereInput[]
    OR?: SpaceClassificationWhereInput[]
    NOT?: SpaceClassificationWhereInput | SpaceClassificationWhereInput[]
    categoryId?: StringFilter<"SpaceClassification"> | string
    createdAt?: DateTimeFilter<"SpaceClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SpaceClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"SpaceClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
  }, "id" | "seq" | "spaceId" | "categoryId_spaceId">

  export type SpaceClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    _count?: SpaceClassificationCountOrderByAggregateInput
    _avg?: SpaceClassificationAvgOrderByAggregateInput
    _max?: SpaceClassificationMaxOrderByAggregateInput
    _min?: SpaceClassificationMinOrderByAggregateInput
    _sum?: SpaceClassificationSumOrderByAggregateInput
  }

  export type SpaceClassificationScalarWhereWithAggregatesInput = {
    AND?: SpaceClassificationScalarWhereWithAggregatesInput | SpaceClassificationScalarWhereWithAggregatesInput[]
    OR?: SpaceClassificationScalarWhereWithAggregatesInput[]
    NOT?: SpaceClassificationScalarWhereWithAggregatesInput | SpaceClassificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpaceClassification"> | string
    seq?: IntWithAggregatesFilter<"SpaceClassification"> | number
    categoryId?: StringWithAggregatesFilter<"SpaceClassification"> | string
    spaceId?: StringWithAggregatesFilter<"SpaceClassification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SpaceClassification"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SpaceClassification"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"SpaceClassification"> | Date | string | null
  }

  export type SpaceAssociationWhereInput = {
    AND?: SpaceAssociationWhereInput | SpaceAssociationWhereInput[]
    OR?: SpaceAssociationWhereInput[]
    NOT?: SpaceAssociationWhereInput | SpaceAssociationWhereInput[]
    id?: StringFilter<"SpaceAssociation"> | string
    seq?: IntFilter<"SpaceAssociation"> | number
    createdAt?: DateTimeFilter<"SpaceAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SpaceAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"SpaceAssociation"> | Date | string | null
    spaceId?: StringFilter<"SpaceAssociation"> | string
    groupId?: StringFilter<"SpaceAssociation"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
  }

  export type SpaceAssociationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    spaceId?: SortOrder
    groupId?: SortOrder
    group?: GroupOrderByWithRelationInput
    space?: SpaceOrderByWithRelationInput
  }

  export type SpaceAssociationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    spaceId_groupId?: SpaceAssociationSpaceIdGroupIdCompoundUniqueInput
    AND?: SpaceAssociationWhereInput | SpaceAssociationWhereInput[]
    OR?: SpaceAssociationWhereInput[]
    NOT?: SpaceAssociationWhereInput | SpaceAssociationWhereInput[]
    createdAt?: DateTimeFilter<"SpaceAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SpaceAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"SpaceAssociation"> | Date | string | null
    spaceId?: StringFilter<"SpaceAssociation"> | string
    groupId?: StringFilter<"SpaceAssociation"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
  }, "id" | "seq" | "spaceId_groupId">

  export type SpaceAssociationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    spaceId?: SortOrder
    groupId?: SortOrder
    _count?: SpaceAssociationCountOrderByAggregateInput
    _avg?: SpaceAssociationAvgOrderByAggregateInput
    _max?: SpaceAssociationMaxOrderByAggregateInput
    _min?: SpaceAssociationMinOrderByAggregateInput
    _sum?: SpaceAssociationSumOrderByAggregateInput
  }

  export type SpaceAssociationScalarWhereWithAggregatesInput = {
    AND?: SpaceAssociationScalarWhereWithAggregatesInput | SpaceAssociationScalarWhereWithAggregatesInput[]
    OR?: SpaceAssociationScalarWhereWithAggregatesInput[]
    NOT?: SpaceAssociationScalarWhereWithAggregatesInput | SpaceAssociationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpaceAssociation"> | string
    seq?: IntWithAggregatesFilter<"SpaceAssociation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SpaceAssociation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SpaceAssociation"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"SpaceAssociation"> | Date | string | null
    spaceId?: StringWithAggregatesFilter<"SpaceAssociation"> | string
    groupId?: StringWithAggregatesFilter<"SpaceAssociation"> | string
  }

  export type GroundWhereInput = {
    AND?: GroundWhereInput | GroundWhereInput[]
    OR?: GroundWhereInput[]
    NOT?: GroundWhereInput | GroundWhereInput[]
    id?: StringFilter<"Ground"> | string
    seq?: IntFilter<"Ground"> | number
    createdAt?: DateTimeFilter<"Ground"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Ground"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Ground"> | Date | string | null
    name?: StringFilter<"Ground"> | string
    label?: StringNullableFilter<"Ground"> | string | null
    address?: StringFilter<"Ground"> | string
    phone?: StringFilter<"Ground"> | string
    email?: StringFilter<"Ground"> | string
    businessNo?: StringFilter<"Ground"> | string
    spaceId?: StringFilter<"Ground"> | string
    logoImageFileId?: StringNullableFilter<"Ground"> | string | null
    imageFileId?: StringNullableFilter<"Ground"> | string | null
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
  }

  export type GroundOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    businessNo?: SortOrder
    spaceId?: SortOrder
    logoImageFileId?: SortOrderInput | SortOrder
    imageFileId?: SortOrderInput | SortOrder
    space?: SpaceOrderByWithRelationInput
  }

  export type GroundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    businessNo?: string
    spaceId?: string
    AND?: GroundWhereInput | GroundWhereInput[]
    OR?: GroundWhereInput[]
    NOT?: GroundWhereInput | GroundWhereInput[]
    createdAt?: DateTimeFilter<"Ground"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Ground"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Ground"> | Date | string | null
    name?: StringFilter<"Ground"> | string
    label?: StringNullableFilter<"Ground"> | string | null
    address?: StringFilter<"Ground"> | string
    phone?: StringFilter<"Ground"> | string
    email?: StringFilter<"Ground"> | string
    logoImageFileId?: StringNullableFilter<"Ground"> | string | null
    imageFileId?: StringNullableFilter<"Ground"> | string | null
    space?: XOR<SpaceScalarRelationFilter, SpaceWhereInput>
  }, "id" | "seq" | "businessNo" | "spaceId">

  export type GroundOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    businessNo?: SortOrder
    spaceId?: SortOrder
    logoImageFileId?: SortOrderInput | SortOrder
    imageFileId?: SortOrderInput | SortOrder
    _count?: GroundCountOrderByAggregateInput
    _avg?: GroundAvgOrderByAggregateInput
    _max?: GroundMaxOrderByAggregateInput
    _min?: GroundMinOrderByAggregateInput
    _sum?: GroundSumOrderByAggregateInput
  }

  export type GroundScalarWhereWithAggregatesInput = {
    AND?: GroundScalarWhereWithAggregatesInput | GroundScalarWhereWithAggregatesInput[]
    OR?: GroundScalarWhereWithAggregatesInput[]
    NOT?: GroundScalarWhereWithAggregatesInput | GroundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ground"> | string
    seq?: IntWithAggregatesFilter<"Ground"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Ground"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Ground"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Ground"> | Date | string | null
    name?: StringWithAggregatesFilter<"Ground"> | string
    label?: StringNullableWithAggregatesFilter<"Ground"> | string | null
    address?: StringWithAggregatesFilter<"Ground"> | string
    phone?: StringWithAggregatesFilter<"Ground"> | string
    email?: StringWithAggregatesFilter<"Ground"> | string
    businessNo?: StringWithAggregatesFilter<"Ground"> | string
    spaceId?: StringWithAggregatesFilter<"Ground"> | string
    logoImageFileId?: StringNullableWithAggregatesFilter<"Ground"> | string | null
    imageFileId?: StringNullableWithAggregatesFilter<"Ground"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    seq?: IntFilter<"User"> | number
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    removedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    phone?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profiles?: ProfileListRelationFilter
    tenants?: TenantListRelationFilter
    classification?: XOR<UserClassificationNullableScalarRelationFilter, UserClassificationWhereInput> | null
    associations?: UserAssociationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profiles?: ProfileOrderByRelationAggregateInput
    tenants?: TenantOrderByRelationAggregateInput
    classification?: UserClassificationOrderByWithRelationInput
    associations?: UserAssociationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    phone?: string
    name?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    removedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringFilter<"User"> | string
    profiles?: ProfileListRelationFilter
    tenants?: TenantListRelationFilter
    classification?: XOR<UserClassificationNullableScalarRelationFilter, UserClassificationWhereInput> | null
    associations?: UserAssociationListRelationFilter
  }, "id" | "seq" | "phone" | "name" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    seq?: IntWithAggregatesFilter<"User"> | number
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    removedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phone?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type UserClassificationWhereInput = {
    AND?: UserClassificationWhereInput | UserClassificationWhereInput[]
    OR?: UserClassificationWhereInput[]
    NOT?: UserClassificationWhereInput | UserClassificationWhereInput[]
    id?: StringFilter<"UserClassification"> | string
    seq?: IntFilter<"UserClassification"> | number
    categoryId?: StringFilter<"UserClassification"> | string
    userId?: StringFilter<"UserClassification"> | string
    createdAt?: DateTimeFilter<"UserClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"UserClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserClassificationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    userId?: string
    categoryId_userId?: UserClassificationCategoryIdUserIdCompoundUniqueInput
    AND?: UserClassificationWhereInput | UserClassificationWhereInput[]
    OR?: UserClassificationWhereInput[]
    NOT?: UserClassificationWhereInput | UserClassificationWhereInput[]
    categoryId?: StringFilter<"UserClassification"> | string
    createdAt?: DateTimeFilter<"UserClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"UserClassification"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "seq" | "userId" | "categoryId_userId">

  export type UserClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    _count?: UserClassificationCountOrderByAggregateInput
    _avg?: UserClassificationAvgOrderByAggregateInput
    _max?: UserClassificationMaxOrderByAggregateInput
    _min?: UserClassificationMinOrderByAggregateInput
    _sum?: UserClassificationSumOrderByAggregateInput
  }

  export type UserClassificationScalarWhereWithAggregatesInput = {
    AND?: UserClassificationScalarWhereWithAggregatesInput | UserClassificationScalarWhereWithAggregatesInput[]
    OR?: UserClassificationScalarWhereWithAggregatesInput[]
    NOT?: UserClassificationScalarWhereWithAggregatesInput | UserClassificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserClassification"> | string
    seq?: IntWithAggregatesFilter<"UserClassification"> | number
    categoryId?: StringWithAggregatesFilter<"UserClassification"> | string
    userId?: StringWithAggregatesFilter<"UserClassification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserClassification"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserClassification"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"UserClassification"> | Date | string | null
  }

  export type UserAssociationWhereInput = {
    AND?: UserAssociationWhereInput | UserAssociationWhereInput[]
    OR?: UserAssociationWhereInput[]
    NOT?: UserAssociationWhereInput | UserAssociationWhereInput[]
    id?: StringFilter<"UserAssociation"> | string
    seq?: IntFilter<"UserAssociation"> | number
    createdAt?: DateTimeFilter<"UserAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"UserAssociation"> | Date | string | null
    userId?: StringFilter<"UserAssociation"> | string
    groupId?: StringFilter<"UserAssociation"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAssociationOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserAssociationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    AND?: UserAssociationWhereInput | UserAssociationWhereInput[]
    OR?: UserAssociationWhereInput[]
    NOT?: UserAssociationWhereInput | UserAssociationWhereInput[]
    createdAt?: DateTimeFilter<"UserAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"UserAssociation"> | Date | string | null
    userId?: StringFilter<"UserAssociation"> | string
    groupId?: StringFilter<"UserAssociation"> | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "seq">

  export type UserAssociationOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    _count?: UserAssociationCountOrderByAggregateInput
    _avg?: UserAssociationAvgOrderByAggregateInput
    _max?: UserAssociationMaxOrderByAggregateInput
    _min?: UserAssociationMinOrderByAggregateInput
    _sum?: UserAssociationSumOrderByAggregateInput
  }

  export type UserAssociationScalarWhereWithAggregatesInput = {
    AND?: UserAssociationScalarWhereWithAggregatesInput | UserAssociationScalarWhereWithAggregatesInput[]
    OR?: UserAssociationScalarWhereWithAggregatesInput[]
    NOT?: UserAssociationScalarWhereWithAggregatesInput | UserAssociationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAssociation"> | string
    seq?: IntWithAggregatesFilter<"UserAssociation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserAssociation"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserAssociation"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"UserAssociation"> | Date | string | null
    userId?: StringWithAggregatesFilter<"UserAssociation"> | string
    groupId?: StringWithAggregatesFilter<"UserAssociation"> | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    seq?: IntFilter<"Profile"> | number
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    name?: StringFilter<"Profile"> | string
    nickname?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    avatarFileId?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    nickname?: SortOrder
    userId?: SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seq?: number
    nickname?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    name?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    avatarFileId?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "seq" | "nickname">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    name?: SortOrder
    nickname?: SortOrder
    userId?: SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    seq?: IntWithAggregatesFilter<"Profile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    name?: StringWithAggregatesFilter<"Profile"> | string
    nickname?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    avatarFileId?: StringNullableWithAggregatesFilter<"Profile"> | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    fileClassifications?: FileClassificationCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    tenantId: string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    fileClassifications?: FileClassificationUncheckedCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    fileClassifications?: FileClassificationUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    fileClassifications?: FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    tenantId: string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenant: TenantCreateNestedOneWithoutGroupsInput
    fileAssociations?: FileAssociationCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenantId: string
    fileAssociations?: FileAssociationUncheckedCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationUncheckedCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationUncheckedCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutGroupsNestedInput
    fileAssociations?: FileAssociationUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    fileAssociations?: FileAssociationUncheckedUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUncheckedUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUncheckedUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenantId: string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    duration: number
    count: number
    description?: string | null
    imageFileId?: string | null
    videoFileId?: string | null
    name: string
    task: TaskCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    duration: number
    count: number
    taskId: string
    description?: string | null
    imageFileId?: string | null
    videoFileId?: string | null
    name: string
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoFileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    taskId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoFileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    duration: number
    count: number
    taskId: string
    description?: string | null
    imageFileId?: string | null
    videoFileId?: string | null
    name: string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoFileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    taskId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoFileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TenantCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TimelineCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutTimelineInput
    tenant: TenantCreateNestedOneWithoutTimelinesInput
  }

  export type TimelineUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
    sessions?: SessionUncheckedCreateNestedManyWithoutTimelineInput
  }

  export type TimelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutTimelineNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTimelinesNestedInput
  }

  export type TimelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutTimelineNestedInput
  }

  export type TimelineCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
  }

  export type TimelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    label: string
    name: string
    program?: ProgramCreateNestedOneWithoutSessionInput
    timeline: TimelineCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    timelineId: string
    label: string
    name: string
    program?: ProgramUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    program?: ProgramUpdateOneWithoutSessionNestedInput
    timeline?: TimelineUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    timelineId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    program?: ProgramUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    timelineId: string
    label: string
    name: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    timelineId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    instructorId: string
    capacity: number
    routine: RoutineCreateNestedOneWithoutProgramInput
    session: SessionCreateNestedOneWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    routineId: string
    sessionId: string
    instructorId: string
    capacity: number
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    routine?: RoutineUpdateOneRequiredWithoutProgramNestedInput
    session?: SessionUpdateOneRequiredWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routineId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    routineId: string
    sessionId: string
    instructorId: string
    capacity: number
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routineId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    routineId: string
    taskId: string
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    routineId: string
    taskId: string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routineId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routineId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    routineId: string
    taskId: string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routineId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routineId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type RoutineCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label: string
    program?: ProgramCreateNestedOneWithoutRoutineInput
  }

  export type RoutineUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label: string
    program?: ProgramUncheckedCreateNestedOneWithoutRoutineInput
  }

  export type RoutineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    program?: ProgramUpdateOneWithoutRoutineNestedInput
  }

  export type RoutineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    program?: ProgramUncheckedUpdateOneWithoutRoutineNestedInput
  }

  export type RoutineCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label: string
  }

  export type RoutineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type RoutineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
    exercise?: ExerciseCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
    exercise?: ExerciseUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    exercise?: ExerciseUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    exercise?: ExerciseUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutAssignmentsInput
    tenant: TenantCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
    tenantId: string
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutAssignmentsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
    tenantId: string
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.AbilityActions
    conditions?: NullableJsonNullValueInput | InputJsonValue
    tenantId: string
  }

  export type ActionUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.AbilityActions
    conditions?: NullableJsonNullValueInput | InputJsonValue
    tenantId: string
  }

  export type ActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumAbilityActionsFieldUpdateOperationsInput | $Enums.AbilityActions
    conditions?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumAbilityActionsFieldUpdateOperationsInput | $Enums.AbilityActions
    conditions?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.AbilityActions
    conditions?: NullableJsonNullValueInput | InputJsonValue
    tenantId: string
  }

  export type ActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumAbilityActionsFieldUpdateOperationsInput | $Enums.AbilityActions
    conditions?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumAbilityActionsFieldUpdateOperationsInput | $Enums.AbilityActions
    conditions?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    tenantId: string
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    tenantId: string
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    tenantId: string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type: $Enums.AbilityTypes
    description?: string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId: string
    tenantId: string
    role: RoleCreateNestedOneWithoutAbilitiesInput
  }

  export type AbilityUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type: $Enums.AbilityTypes
    roleId: string
    description?: string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId: string
    tenantId: string
  }

  export type AbilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAbilityTypesFieldUpdateOperationsInput | $Enums.AbilityTypes
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutAbilitiesNestedInput
  }

  export type AbilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAbilityTypesFieldUpdateOperationsInput | $Enums.AbilityTypes
    roleId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type: $Enums.AbilityTypes
    roleId: string
    description?: string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId: string
    tenantId: string
  }

  export type AbilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAbilityTypesFieldUpdateOperationsInput | $Enums.AbilityTypes
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAbilityTypesFieldUpdateOperationsInput | $Enums.AbilityTypes
    roleId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    content: ContentCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    contentId: string
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: ContentUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    contentId: string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
    tenant: TenantCreateNestedOneWithoutContentsInput
    posts?: PostCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
    tenantId: string
    posts?: PostUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutContentsNestedInput
    posts?: PostUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    posts?: PostUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
    tenantId: string
  }

  export type ContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    parent?: FileCreateNestedOneWithoutChildrenInput
    children?: FileCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutFilesInput
    associations?: FileAssociationCreateNestedManyWithoutFileInput
    classification?: FileClassificationCreateNestedOneWithoutFileInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    seq?: number
    name: string
    size: number
    parentId?: string | null
    mimeType: string
    url: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    children?: FileUncheckedCreateNestedManyWithoutParentInput
    associations?: FileAssociationUncheckedCreateNestedManyWithoutFileInput
    classification?: FileClassificationUncheckedCreateNestedOneWithoutFileInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: FileUpdateOneWithoutChildrenNestedInput
    children?: FileUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutFilesNestedInput
    associations?: FileAssociationUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUpdateOneWithoutFileNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: FileUncheckedUpdateManyWithoutParentNestedInput
    associations?: FileAssociationUncheckedUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUncheckedUpdateOneWithoutFileNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    seq?: number
    name: string
    size: number
    parentId?: string | null
    mimeType: string
    url: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileClassificationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutFileClassificationsInput
    file: FileCreateNestedOneWithoutClassificationInput
  }

  export type FileClassificationUncheckedCreateInput = {
    id?: string
    seq?: number
    categoryId: string
    fileId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type FileClassificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutFileClassificationsNestedInput
    file?: FileUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type FileClassificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileClassificationCreateManyInput = {
    id?: string
    seq?: number
    categoryId: string
    fileId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type FileClassificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileClassificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileAssociationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    file: FileCreateNestedOneWithoutAssociationsInput
    group: GroupCreateNestedOneWithoutFileAssociationsInput
  }

  export type FileAssociationUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    fileId: string
    groupId: string
  }

  export type FileAssociationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneRequiredWithoutAssociationsNestedInput
    group?: GroupUpdateOneRequiredWithoutFileAssociationsNestedInput
  }

  export type FileAssociationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type FileAssociationCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    fileId: string
    groupId: string
  }

  export type FileAssociationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileAssociationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityCreateNestedManyWithoutRoleInput
    assignments?: AssignmentCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationCreateNestedOneWithoutRoleInput
    tenants?: TenantCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityUncheckedCreateNestedManyWithoutRoleInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationUncheckedCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationUncheckedCreateNestedOneWithoutRoleInput
    tenants?: TenantUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUpdateOneWithoutRoleNestedInput
    tenants?: TenantUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUncheckedUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUncheckedUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUncheckedUpdateOneWithoutRoleNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
  }

  export type RoleAssociationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutRoleAssociationsInput
    role: RoleCreateNestedOneWithoutAssociationsInput
  }

  export type RoleAssociationUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
    groupId: string
  }

  export type RoleAssociationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutRoleAssociationsNestedInput
    role?: RoleUpdateOneRequiredWithoutAssociationsNestedInput
  }

  export type RoleAssociationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleAssociationCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
    groupId: string
  }

  export type RoleAssociationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleAssociationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleClassificationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutRoleClassificationsInput
    role: RoleCreateNestedOneWithoutClassificationInput
  }

  export type RoleClassificationUncheckedCreateInput = {
    id?: string
    seq?: number
    categoryId: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type RoleClassificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutRoleClassificationsNestedInput
    role?: RoleUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type RoleClassificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleClassificationCreateManyInput = {
    id?: string
    seq?: number
    categoryId: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type RoleClassificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleClassificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundCreateNestedOneWithoutSpaceInput
    associations?: SpaceAssociationCreateNestedManyWithoutSpaceInput
    classification?: SpaceClassificationCreateNestedOneWithoutSpaceInput
    tenants?: TenantCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundUncheckedCreateNestedOneWithoutSpaceInput
    associations?: SpaceAssociationUncheckedCreateNestedManyWithoutSpaceInput
    classification?: SpaceClassificationUncheckedCreateNestedOneWithoutSpaceInput
    tenants?: TenantUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUpdateOneWithoutSpaceNestedInput
    associations?: SpaceAssociationUpdateManyWithoutSpaceNestedInput
    classification?: SpaceClassificationUpdateOneWithoutSpaceNestedInput
    tenants?: TenantUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUncheckedUpdateOneWithoutSpaceNestedInput
    associations?: SpaceAssociationUncheckedUpdateManyWithoutSpaceNestedInput
    classification?: SpaceClassificationUncheckedUpdateOneWithoutSpaceNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type SpaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceClassificationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutSpaceClassificationsInput
    space: SpaceCreateNestedOneWithoutClassificationInput
  }

  export type SpaceClassificationUncheckedCreateInput = {
    id?: string
    seq?: number
    categoryId: string
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type SpaceClassificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutSpaceClassificationsNestedInput
    space?: SpaceUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type SpaceClassificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceClassificationCreateManyInput = {
    id?: string
    seq?: number
    categoryId: string
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type SpaceClassificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceClassificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceAssociationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutSpaceAssociationsInput
    space: SpaceCreateNestedOneWithoutAssociationsInput
  }

  export type SpaceAssociationUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    spaceId: string
    groupId: string
  }

  export type SpaceAssociationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutSpaceAssociationsNestedInput
    space?: SpaceUpdateOneRequiredWithoutAssociationsNestedInput
  }

  export type SpaceAssociationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceAssociationCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    spaceId: string
    groupId: string
  }

  export type SpaceAssociationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceAssociationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type GroundCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label?: string | null
    address: string
    phone: string
    email: string
    businessNo: string
    logoImageFileId?: string | null
    imageFileId?: string | null
    space: SpaceCreateNestedOneWithoutGroundInput
  }

  export type GroundUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label?: string | null
    address: string
    phone: string
    email: string
    businessNo: string
    spaceId: string
    logoImageFileId?: string | null
    imageFileId?: string | null
  }

  export type GroundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    businessNo?: StringFieldUpdateOperationsInput | string
    logoImageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    space?: SpaceUpdateOneRequiredWithoutGroundNestedInput
  }

  export type GroundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    businessNo?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    logoImageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroundCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label?: string | null
    address: string
    phone: string
    email: string
    businessNo: string
    spaceId: string
    logoImageFileId?: string | null
    imageFileId?: string | null
  }

  export type GroundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    businessNo?: StringFieldUpdateOperationsInput | string
    logoImageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    businessNo?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    logoImageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileCreateNestedManyWithoutUserInput
    tenants?: TenantCreateNestedManyWithoutUserInput
    classification?: UserClassificationCreateNestedOneWithoutUserInput
    associations?: UserAssociationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileUncheckedCreateNestedManyWithoutUserInput
    tenants?: TenantUncheckedCreateNestedManyWithoutUserInput
    classification?: UserClassificationUncheckedCreateNestedOneWithoutUserInput
    associations?: UserAssociationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUpdateManyWithoutUserNestedInput
    tenants?: TenantUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUpdateOneWithoutUserNestedInput
    associations?: UserAssociationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUncheckedUpdateOneWithoutUserNestedInput
    associations?: UserAssociationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserClassificationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutUserClassificationsInput
    user: UserCreateNestedOneWithoutClassificationInput
  }

  export type UserClassificationUncheckedCreateInput = {
    id?: string
    seq?: number
    categoryId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type UserClassificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutUserClassificationsNestedInput
    user?: UserUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type UserClassificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserClassificationCreateManyInput = {
    id?: string
    seq?: number
    categoryId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type UserClassificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserClassificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAssociationCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutUserAssociationsInput
    user: UserCreateNestedOneWithoutAssociationsInput
  }

  export type UserAssociationUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    groupId: string
  }

  export type UserAssociationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutUserAssociationsNestedInput
    user?: UserUpdateOneRequiredWithoutAssociationsNestedInput
  }

  export type UserAssociationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAssociationCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    groupId: string
  }

  export type UserAssociationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAssociationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    nickname: string
    avatarFileId?: string | null
    user: UserCreateNestedOneWithoutProfilesInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    nickname: string
    userId: string
    avatarFileId?: string | null
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProfilesNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateManyInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    nickname: string
    userId: string
    avatarFileId?: string | null
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumCategoryTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryTypes | EnumCategoryTypesFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypesFilter<$PrismaModel> | $Enums.CategoryTypes
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type FileClassificationListRelationFilter = {
    every?: FileClassificationWhereInput
    some?: FileClassificationWhereInput
    none?: FileClassificationWhereInput
  }

  export type RoleClassificationListRelationFilter = {
    every?: RoleClassificationWhereInput
    some?: RoleClassificationWhereInput
    none?: RoleClassificationWhereInput
  }

  export type SpaceClassificationListRelationFilter = {
    every?: SpaceClassificationWhereInput
    some?: SpaceClassificationWhereInput
    none?: SpaceClassificationWhereInput
  }

  export type UserClassificationListRelationFilter = {
    every?: UserClassificationWhereInput
    some?: UserClassificationWhereInput
    none?: UserClassificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaceClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    tenantId?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    tenantId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    tenantId?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCategoryTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryTypes | EnumCategoryTypesFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypesWithAggregatesFilter<$PrismaModel> | $Enums.CategoryTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypesFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypesFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGroupTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupTypes | EnumGroupTypesFieldRefInput<$PrismaModel>
    in?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypesFilter<$PrismaModel> | $Enums.GroupTypes
  }

  export type FileAssociationListRelationFilter = {
    every?: FileAssociationWhereInput
    some?: FileAssociationWhereInput
    none?: FileAssociationWhereInput
  }

  export type RoleAssociationListRelationFilter = {
    every?: RoleAssociationWhereInput
    some?: RoleAssociationWhereInput
    none?: RoleAssociationWhereInput
  }

  export type SpaceAssociationListRelationFilter = {
    every?: SpaceAssociationWhereInput
    some?: SpaceAssociationWhereInput
    none?: SpaceAssociationWhereInput
  }

  export type UserAssociationListRelationFilter = {
    every?: UserAssociationWhereInput
    some?: UserAssociationWhereInput
    none?: UserAssociationWhereInput
  }

  export type FileAssociationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleAssociationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaceAssociationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAssociationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    label?: SortOrder
    tenantId?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    label?: SortOrder
    tenantId?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    label?: SortOrder
    tenantId?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumGroupTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupTypes | EnumGroupTypesFieldRefInput<$PrismaModel>
    in?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypesWithAggregatesFilter<$PrismaModel> | $Enums.GroupTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupTypesFilter<$PrismaModel>
    _max?: NestedEnumGroupTypesFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    duration?: SortOrder
    count?: SortOrder
    taskId?: SortOrder
    description?: SortOrder
    imageFileId?: SortOrder
    videoFileId?: SortOrder
    name?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    seq?: SortOrder
    duration?: SortOrder
    count?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    duration?: SortOrder
    count?: SortOrder
    taskId?: SortOrder
    description?: SortOrder
    imageFileId?: SortOrder
    videoFileId?: SortOrder
    name?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    duration?: SortOrder
    count?: SortOrder
    taskId?: SortOrder
    description?: SortOrder
    imageFileId?: SortOrder
    videoFileId?: SortOrder
    name?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    seq?: SortOrder
    duration?: SortOrder
    count?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type ContentListRelationFilter = {
    every?: ContentWhereInput
    some?: ContentWhereInput
    none?: ContentWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type SpaceScalarRelationFilter = {
    is?: SpaceWhereInput
    isNot?: SpaceWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TimelineListRelationFilter = {
    every?: TimelineWhereInput
    some?: TimelineWhereInput
    none?: TimelineWhereInput
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    roleId?: SortOrder
    main?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    roleId?: SortOrder
    main?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    roleId?: SortOrder
    main?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimelineCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TimelineAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type TimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TimelineMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TimelineSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumSessionTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionTypes | EnumSessionTypesFieldRefInput<$PrismaModel>
    in?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypesFilter<$PrismaModel> | $Enums.SessionTypes
  }

  export type EnumRepeatCycleTypesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatCycleTypes | EnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    in?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRepeatCycleTypesNullableFilter<$PrismaModel> | $Enums.RepeatCycleTypes | null
  }

  export type EnumRecurringDayOfWeekNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringDayOfWeek | EnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurringDayOfWeekNullableFilter<$PrismaModel> | $Enums.RecurringDayOfWeek | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProgramNullableScalarRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type TimelineScalarRelationFilter = {
    is?: TimelineWhereInput
    isNot?: TimelineWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    type?: SortOrder
    repeatCycleType?: SortOrder
    startDateTime?: SortOrder
    endDateTime?: SortOrder
    recurringDayOfWeek?: SortOrder
    recurringMonth?: SortOrder
    timelineId?: SortOrder
    label?: SortOrder
    name?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    seq?: SortOrder
    recurringMonth?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    type?: SortOrder
    repeatCycleType?: SortOrder
    startDateTime?: SortOrder
    endDateTime?: SortOrder
    recurringDayOfWeek?: SortOrder
    recurringMonth?: SortOrder
    timelineId?: SortOrder
    label?: SortOrder
    name?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    type?: SortOrder
    repeatCycleType?: SortOrder
    startDateTime?: SortOrder
    endDateTime?: SortOrder
    recurringDayOfWeek?: SortOrder
    recurringMonth?: SortOrder
    timelineId?: SortOrder
    label?: SortOrder
    name?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    seq?: SortOrder
    recurringMonth?: SortOrder
  }

  export type EnumSessionTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionTypes | EnumSessionTypesFieldRefInput<$PrismaModel>
    in?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypesWithAggregatesFilter<$PrismaModel> | $Enums.SessionTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypesFilter<$PrismaModel>
    _max?: NestedEnumSessionTypesFilter<$PrismaModel>
  }

  export type EnumRepeatCycleTypesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatCycleTypes | EnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    in?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRepeatCycleTypesNullableWithAggregatesFilter<$PrismaModel> | $Enums.RepeatCycleTypes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRepeatCycleTypesNullableFilter<$PrismaModel>
    _max?: NestedEnumRepeatCycleTypesNullableFilter<$PrismaModel>
  }

  export type EnumRecurringDayOfWeekNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringDayOfWeek | EnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurringDayOfWeekNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurringDayOfWeek | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurringDayOfWeekNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurringDayOfWeekNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RoutineScalarRelationFilter = {
    is?: RoutineWhereInput
    isNot?: RoutineWhereInput
  }

  export type SessionScalarRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    routineId?: SortOrder
    sessionId?: SortOrder
    instructorId?: SortOrder
    capacity?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    seq?: SortOrder
    capacity?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    routineId?: SortOrder
    sessionId?: SortOrder
    instructorId?: SortOrder
    capacity?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    routineId?: SortOrder
    sessionId?: SortOrder
    instructorId?: SortOrder
    capacity?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    seq?: SortOrder
    capacity?: SortOrder
  }

  export type ActivityRoutineIdTaskIdCompoundUniqueInput = {
    routineId: string
    taskId: string
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    routineId?: SortOrder
    taskId?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    routineId?: SortOrder
    taskId?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    routineId?: SortOrder
    taskId?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type RoutineCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    label?: SortOrder
  }

  export type RoutineAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type RoutineMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    label?: SortOrder
  }

  export type RoutineMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    label?: SortOrder
  }

  export type RoutineSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type ExerciseNullableScalarRelationFilter = {
    is?: ExerciseWhereInput | null
    isNot?: ExerciseWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumAbilityActionsFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityActions | EnumAbilityActionsFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityActionsFilter<$PrismaModel> | $Enums.AbilityActions
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    conditions?: SortOrder
    tenantId?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumAbilityActionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityActions | EnumAbilityActionsFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityActionsWithAggregatesFilter<$PrismaModel> | $Enums.AbilityActions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbilityActionsFilter<$PrismaModel>
    _max?: NestedEnumAbilityActionsFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumAbilityTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityTypes | EnumAbilityTypesFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityTypesFilter<$PrismaModel> | $Enums.AbilityTypes
  }

  export type AbilityCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    type?: SortOrder
    roleId?: SortOrder
    description?: SortOrder
    conditions?: SortOrder
    subjectId?: SortOrder
    tenantId?: SortOrder
  }

  export type AbilityAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type AbilityMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    type?: SortOrder
    roleId?: SortOrder
    description?: SortOrder
    subjectId?: SortOrder
    tenantId?: SortOrder
  }

  export type AbilityMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    type?: SortOrder
    roleId?: SortOrder
    description?: SortOrder
    subjectId?: SortOrder
    tenantId?: SortOrder
  }

  export type AbilitySumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumAbilityTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityTypes | EnumAbilityTypesFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityTypesWithAggregatesFilter<$PrismaModel> | $Enums.AbilityTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbilityTypesFilter<$PrismaModel>
    _max?: NestedEnumAbilityTypesFilter<$PrismaModel>
  }

  export type ContentScalarRelationFilter = {
    is?: ContentWhereInput
    isNot?: ContentWhereInput
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    contentId?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    contentId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    contentId?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumTextTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextTypes | EnumTextTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypesFilter<$PrismaModel> | $Enums.TextTypes
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    text?: SortOrder
    fileId?: SortOrder
    tenantId?: SortOrder
  }

  export type ContentAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type ContentMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    text?: SortOrder
    fileId?: SortOrder
    tenantId?: SortOrder
  }

  export type ContentMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    text?: SortOrder
    fileId?: SortOrder
    tenantId?: SortOrder
  }

  export type ContentSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumTextTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextTypes | EnumTextTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypesWithAggregatesFilter<$PrismaModel> | $Enums.TextTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextTypesFilter<$PrismaModel>
    _max?: NestedEnumTextTypesFilter<$PrismaModel>
  }

  export type FileNullableScalarRelationFilter = {
    is?: FileWhereInput | null
    isNot?: FileWhereInput | null
  }

  export type FileClassificationNullableScalarRelationFilter = {
    is?: FileClassificationWhereInput | null
    isNot?: FileClassificationWhereInput | null
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    name?: SortOrder
    size?: SortOrder
    parentId?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    seq?: SortOrder
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    name?: SortOrder
    size?: SortOrder
    parentId?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    name?: SortOrder
    size?: SortOrder
    parentId?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    seq?: SortOrder
    size?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type FileScalarRelationFilter = {
    is?: FileWhereInput
    isNot?: FileWhereInput
  }

  export type FileClassificationCategoryIdFileIdCompoundUniqueInput = {
    categoryId: string
    fileId: string
  }

  export type FileClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type FileClassificationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type FileClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type FileClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type FileClassificationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type FileAssociationGroupIdFileIdCompoundUniqueInput = {
    groupId: string
    fileId: string
  }

  export type FileAssociationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    fileId?: SortOrder
    groupId?: SortOrder
  }

  export type FileAssociationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type FileAssociationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    fileId?: SortOrder
    groupId?: SortOrder
  }

  export type FileAssociationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    fileId?: SortOrder
    groupId?: SortOrder
  }

  export type FileAssociationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumRolesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    not?: NestedEnumRolesFilter<$PrismaModel> | $Enums.Roles
  }

  export type AbilityListRelationFilter = {
    every?: AbilityWhereInput
    some?: AbilityWhereInput
    none?: AbilityWhereInput
  }

  export type RoleClassificationNullableScalarRelationFilter = {
    is?: RoleClassificationWhereInput | null
    isNot?: RoleClassificationWhereInput | null
  }

  export type TenantListRelationFilter = {
    every?: TenantWhereInput
    some?: TenantWhereInput
    none?: TenantWhereInput
  }

  export type AbilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type EnumRolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    not?: NestedEnumRolesWithAggregatesFilter<$PrismaModel> | $Enums.Roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolesFilter<$PrismaModel>
    _max?: NestedEnumRolesFilter<$PrismaModel>
  }

  export type RoleAssociationGroupIdRoleIdCompoundUniqueInput = {
    groupId: string
    roleId: string
  }

  export type RoleAssociationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    roleId?: SortOrder
    groupId?: SortOrder
  }

  export type RoleAssociationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type RoleAssociationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    roleId?: SortOrder
    groupId?: SortOrder
  }

  export type RoleAssociationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    roleId?: SortOrder
    groupId?: SortOrder
  }

  export type RoleAssociationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type RoleClassificationCategoryIdRoleIdCompoundUniqueInput = {
    categoryId: string
    roleId: string
  }

  export type RoleClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type RoleClassificationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type RoleClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type RoleClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type RoleClassificationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type GroundNullableScalarRelationFilter = {
    is?: GroundWhereInput | null
    isNot?: GroundWhereInput | null
  }

  export type SpaceClassificationNullableScalarRelationFilter = {
    is?: SpaceClassificationWhereInput | null
    isNot?: SpaceClassificationWhereInput | null
  }

  export type SpaceCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type SpaceAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type SpaceMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type SpaceSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SpaceClassificationCategoryIdSpaceIdCompoundUniqueInput = {
    categoryId: string
    spaceId: string
  }

  export type SpaceClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type SpaceClassificationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SpaceClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type SpaceClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type SpaceClassificationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SpaceAssociationSpaceIdGroupIdCompoundUniqueInput = {
    spaceId: string
    groupId: string
  }

  export type SpaceAssociationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    spaceId?: SortOrder
    groupId?: SortOrder
  }

  export type SpaceAssociationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SpaceAssociationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    spaceId?: SortOrder
    groupId?: SortOrder
  }

  export type SpaceAssociationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    spaceId?: SortOrder
    groupId?: SortOrder
  }

  export type SpaceAssociationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type GroundCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    label?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    businessNo?: SortOrder
    spaceId?: SortOrder
    logoImageFileId?: SortOrder
    imageFileId?: SortOrder
  }

  export type GroundAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type GroundMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    label?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    businessNo?: SortOrder
    spaceId?: SortOrder
    logoImageFileId?: SortOrder
    imageFileId?: SortOrder
  }

  export type GroundMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    label?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    businessNo?: SortOrder
    spaceId?: SortOrder
    logoImageFileId?: SortOrder
    imageFileId?: SortOrder
  }

  export type GroundSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type UserClassificationNullableScalarRelationFilter = {
    is?: UserClassificationWhereInput | null
    isNot?: UserClassificationWhereInput | null
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type UserClassificationCategoryIdUserIdCompoundUniqueInput = {
    categoryId: string
    userId: string
  }

  export type UserClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type UserClassificationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type UserClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type UserClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type UserClassificationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type UserAssociationCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type UserAssociationAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type UserAssociationMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type UserAssociationMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type UserAssociationSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    userId?: SortOrder
    avatarFileId?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    userId?: SortOrder
    avatarFileId?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    removedAt?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    userId?: SortOrder
    avatarFileId?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCategoriesInput
    connect?: TenantWhereUniqueInput
  }

  export type FileClassificationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<FileClassificationCreateWithoutCategoryInput, FileClassificationUncheckedCreateWithoutCategoryInput> | FileClassificationCreateWithoutCategoryInput[] | FileClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FileClassificationCreateOrConnectWithoutCategoryInput | FileClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: FileClassificationCreateManyCategoryInputEnvelope
    connect?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
  }

  export type RoleClassificationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RoleClassificationCreateWithoutCategoryInput, RoleClassificationUncheckedCreateWithoutCategoryInput> | RoleClassificationCreateWithoutCategoryInput[] | RoleClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutCategoryInput | RoleClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: RoleClassificationCreateManyCategoryInputEnvelope
    connect?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
  }

  export type SpaceClassificationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SpaceClassificationCreateWithoutCategoryInput, SpaceClassificationUncheckedCreateWithoutCategoryInput> | SpaceClassificationCreateWithoutCategoryInput[] | SpaceClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutCategoryInput | SpaceClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: SpaceClassificationCreateManyCategoryInputEnvelope
    connect?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
  }

  export type UserClassificationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<UserClassificationCreateWithoutCategoryInput, UserClassificationUncheckedCreateWithoutCategoryInput> | UserClassificationCreateWithoutCategoryInput[] | UserClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: UserClassificationCreateOrConnectWithoutCategoryInput | UserClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: UserClassificationCreateManyCategoryInputEnvelope
    connect?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type FileClassificationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<FileClassificationCreateWithoutCategoryInput, FileClassificationUncheckedCreateWithoutCategoryInput> | FileClassificationCreateWithoutCategoryInput[] | FileClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FileClassificationCreateOrConnectWithoutCategoryInput | FileClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: FileClassificationCreateManyCategoryInputEnvelope
    connect?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
  }

  export type RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RoleClassificationCreateWithoutCategoryInput, RoleClassificationUncheckedCreateWithoutCategoryInput> | RoleClassificationCreateWithoutCategoryInput[] | RoleClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutCategoryInput | RoleClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: RoleClassificationCreateManyCategoryInputEnvelope
    connect?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
  }

  export type SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SpaceClassificationCreateWithoutCategoryInput, SpaceClassificationUncheckedCreateWithoutCategoryInput> | SpaceClassificationCreateWithoutCategoryInput[] | SpaceClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutCategoryInput | SpaceClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: SpaceClassificationCreateManyCategoryInputEnvelope
    connect?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
  }

  export type UserClassificationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<UserClassificationCreateWithoutCategoryInput, UserClassificationUncheckedCreateWithoutCategoryInput> | UserClassificationCreateWithoutCategoryInput[] | UserClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: UserClassificationCreateOrConnectWithoutCategoryInput | UserClassificationCreateOrConnectWithoutCategoryInput[]
    createMany?: UserClassificationCreateManyCategoryInputEnvelope
    connect?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumCategoryTypesFieldUpdateOperationsInput = {
    set?: $Enums.CategoryTypes
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCategoriesInput
    upsert?: TenantUpsertWithoutCategoriesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCategoriesInput, TenantUpdateWithoutCategoriesInput>, TenantUncheckedUpdateWithoutCategoriesInput>
  }

  export type FileClassificationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<FileClassificationCreateWithoutCategoryInput, FileClassificationUncheckedCreateWithoutCategoryInput> | FileClassificationCreateWithoutCategoryInput[] | FileClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FileClassificationCreateOrConnectWithoutCategoryInput | FileClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: FileClassificationUpsertWithWhereUniqueWithoutCategoryInput | FileClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: FileClassificationCreateManyCategoryInputEnvelope
    set?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    disconnect?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    delete?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    connect?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    update?: FileClassificationUpdateWithWhereUniqueWithoutCategoryInput | FileClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: FileClassificationUpdateManyWithWhereWithoutCategoryInput | FileClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: FileClassificationScalarWhereInput | FileClassificationScalarWhereInput[]
  }

  export type RoleClassificationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RoleClassificationCreateWithoutCategoryInput, RoleClassificationUncheckedCreateWithoutCategoryInput> | RoleClassificationCreateWithoutCategoryInput[] | RoleClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutCategoryInput | RoleClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: RoleClassificationUpsertWithWhereUniqueWithoutCategoryInput | RoleClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RoleClassificationCreateManyCategoryInputEnvelope
    set?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    disconnect?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    delete?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    connect?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    update?: RoleClassificationUpdateWithWhereUniqueWithoutCategoryInput | RoleClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RoleClassificationUpdateManyWithWhereWithoutCategoryInput | RoleClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RoleClassificationScalarWhereInput | RoleClassificationScalarWhereInput[]
  }

  export type SpaceClassificationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SpaceClassificationCreateWithoutCategoryInput, SpaceClassificationUncheckedCreateWithoutCategoryInput> | SpaceClassificationCreateWithoutCategoryInput[] | SpaceClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutCategoryInput | SpaceClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: SpaceClassificationUpsertWithWhereUniqueWithoutCategoryInput | SpaceClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SpaceClassificationCreateManyCategoryInputEnvelope
    set?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    disconnect?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    delete?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    connect?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    update?: SpaceClassificationUpdateWithWhereUniqueWithoutCategoryInput | SpaceClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SpaceClassificationUpdateManyWithWhereWithoutCategoryInput | SpaceClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SpaceClassificationScalarWhereInput | SpaceClassificationScalarWhereInput[]
  }

  export type UserClassificationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<UserClassificationCreateWithoutCategoryInput, UserClassificationUncheckedCreateWithoutCategoryInput> | UserClassificationCreateWithoutCategoryInput[] | UserClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: UserClassificationCreateOrConnectWithoutCategoryInput | UserClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: UserClassificationUpsertWithWhereUniqueWithoutCategoryInput | UserClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: UserClassificationCreateManyCategoryInputEnvelope
    set?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    disconnect?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    delete?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    connect?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    update?: UserClassificationUpdateWithWhereUniqueWithoutCategoryInput | UserClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: UserClassificationUpdateManyWithWhereWithoutCategoryInput | UserClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: UserClassificationScalarWhereInput | UserClassificationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<FileClassificationCreateWithoutCategoryInput, FileClassificationUncheckedCreateWithoutCategoryInput> | FileClassificationCreateWithoutCategoryInput[] | FileClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FileClassificationCreateOrConnectWithoutCategoryInput | FileClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: FileClassificationUpsertWithWhereUniqueWithoutCategoryInput | FileClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: FileClassificationCreateManyCategoryInputEnvelope
    set?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    disconnect?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    delete?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    connect?: FileClassificationWhereUniqueInput | FileClassificationWhereUniqueInput[]
    update?: FileClassificationUpdateWithWhereUniqueWithoutCategoryInput | FileClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: FileClassificationUpdateManyWithWhereWithoutCategoryInput | FileClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: FileClassificationScalarWhereInput | FileClassificationScalarWhereInput[]
  }

  export type RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RoleClassificationCreateWithoutCategoryInput, RoleClassificationUncheckedCreateWithoutCategoryInput> | RoleClassificationCreateWithoutCategoryInput[] | RoleClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutCategoryInput | RoleClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: RoleClassificationUpsertWithWhereUniqueWithoutCategoryInput | RoleClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RoleClassificationCreateManyCategoryInputEnvelope
    set?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    disconnect?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    delete?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    connect?: RoleClassificationWhereUniqueInput | RoleClassificationWhereUniqueInput[]
    update?: RoleClassificationUpdateWithWhereUniqueWithoutCategoryInput | RoleClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RoleClassificationUpdateManyWithWhereWithoutCategoryInput | RoleClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RoleClassificationScalarWhereInput | RoleClassificationScalarWhereInput[]
  }

  export type SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SpaceClassificationCreateWithoutCategoryInput, SpaceClassificationUncheckedCreateWithoutCategoryInput> | SpaceClassificationCreateWithoutCategoryInput[] | SpaceClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutCategoryInput | SpaceClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: SpaceClassificationUpsertWithWhereUniqueWithoutCategoryInput | SpaceClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SpaceClassificationCreateManyCategoryInputEnvelope
    set?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    disconnect?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    delete?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    connect?: SpaceClassificationWhereUniqueInput | SpaceClassificationWhereUniqueInput[]
    update?: SpaceClassificationUpdateWithWhereUniqueWithoutCategoryInput | SpaceClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SpaceClassificationUpdateManyWithWhereWithoutCategoryInput | SpaceClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SpaceClassificationScalarWhereInput | SpaceClassificationScalarWhereInput[]
  }

  export type UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<UserClassificationCreateWithoutCategoryInput, UserClassificationUncheckedCreateWithoutCategoryInput> | UserClassificationCreateWithoutCategoryInput[] | UserClassificationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: UserClassificationCreateOrConnectWithoutCategoryInput | UserClassificationCreateOrConnectWithoutCategoryInput[]
    upsert?: UserClassificationUpsertWithWhereUniqueWithoutCategoryInput | UserClassificationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: UserClassificationCreateManyCategoryInputEnvelope
    set?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    disconnect?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    delete?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    connect?: UserClassificationWhereUniqueInput | UserClassificationWhereUniqueInput[]
    update?: UserClassificationUpdateWithWhereUniqueWithoutCategoryInput | UserClassificationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: UserClassificationUpdateManyWithWhereWithoutCategoryInput | UserClassificationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: UserClassificationScalarWhereInput | UserClassificationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutGroupsInput = {
    create?: XOR<TenantCreateWithoutGroupsInput, TenantUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGroupsInput
    connect?: TenantWhereUniqueInput
  }

  export type FileAssociationCreateNestedManyWithoutGroupInput = {
    create?: XOR<FileAssociationCreateWithoutGroupInput, FileAssociationUncheckedCreateWithoutGroupInput> | FileAssociationCreateWithoutGroupInput[] | FileAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutGroupInput | FileAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: FileAssociationCreateManyGroupInputEnvelope
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
  }

  export type RoleAssociationCreateNestedManyWithoutGroupInput = {
    create?: XOR<RoleAssociationCreateWithoutGroupInput, RoleAssociationUncheckedCreateWithoutGroupInput> | RoleAssociationCreateWithoutGroupInput[] | RoleAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutGroupInput | RoleAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: RoleAssociationCreateManyGroupInputEnvelope
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
  }

  export type SpaceAssociationCreateNestedManyWithoutGroupInput = {
    create?: XOR<SpaceAssociationCreateWithoutGroupInput, SpaceAssociationUncheckedCreateWithoutGroupInput> | SpaceAssociationCreateWithoutGroupInput[] | SpaceAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutGroupInput | SpaceAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: SpaceAssociationCreateManyGroupInputEnvelope
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
  }

  export type UserAssociationCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserAssociationCreateWithoutGroupInput, UserAssociationUncheckedCreateWithoutGroupInput> | UserAssociationCreateWithoutGroupInput[] | UserAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutGroupInput | UserAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: UserAssociationCreateManyGroupInputEnvelope
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
  }

  export type FileAssociationUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<FileAssociationCreateWithoutGroupInput, FileAssociationUncheckedCreateWithoutGroupInput> | FileAssociationCreateWithoutGroupInput[] | FileAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutGroupInput | FileAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: FileAssociationCreateManyGroupInputEnvelope
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
  }

  export type RoleAssociationUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<RoleAssociationCreateWithoutGroupInput, RoleAssociationUncheckedCreateWithoutGroupInput> | RoleAssociationCreateWithoutGroupInput[] | RoleAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutGroupInput | RoleAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: RoleAssociationCreateManyGroupInputEnvelope
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
  }

  export type SpaceAssociationUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<SpaceAssociationCreateWithoutGroupInput, SpaceAssociationUncheckedCreateWithoutGroupInput> | SpaceAssociationCreateWithoutGroupInput[] | SpaceAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutGroupInput | SpaceAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: SpaceAssociationCreateManyGroupInputEnvelope
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
  }

  export type UserAssociationUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserAssociationCreateWithoutGroupInput, UserAssociationUncheckedCreateWithoutGroupInput> | UserAssociationCreateWithoutGroupInput[] | UserAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutGroupInput | UserAssociationCreateOrConnectWithoutGroupInput[]
    createMany?: UserAssociationCreateManyGroupInputEnvelope
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
  }

  export type EnumGroupTypesFieldUpdateOperationsInput = {
    set?: $Enums.GroupTypes
  }

  export type TenantUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<TenantCreateWithoutGroupsInput, TenantUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGroupsInput
    upsert?: TenantUpsertWithoutGroupsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutGroupsInput, TenantUpdateWithoutGroupsInput>, TenantUncheckedUpdateWithoutGroupsInput>
  }

  export type FileAssociationUpdateManyWithoutGroupNestedInput = {
    create?: XOR<FileAssociationCreateWithoutGroupInput, FileAssociationUncheckedCreateWithoutGroupInput> | FileAssociationCreateWithoutGroupInput[] | FileAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutGroupInput | FileAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: FileAssociationUpsertWithWhereUniqueWithoutGroupInput | FileAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: FileAssociationCreateManyGroupInputEnvelope
    set?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    disconnect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    delete?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    update?: FileAssociationUpdateWithWhereUniqueWithoutGroupInput | FileAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: FileAssociationUpdateManyWithWhereWithoutGroupInput | FileAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: FileAssociationScalarWhereInput | FileAssociationScalarWhereInput[]
  }

  export type RoleAssociationUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RoleAssociationCreateWithoutGroupInput, RoleAssociationUncheckedCreateWithoutGroupInput> | RoleAssociationCreateWithoutGroupInput[] | RoleAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutGroupInput | RoleAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: RoleAssociationUpsertWithWhereUniqueWithoutGroupInput | RoleAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RoleAssociationCreateManyGroupInputEnvelope
    set?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    disconnect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    delete?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    update?: RoleAssociationUpdateWithWhereUniqueWithoutGroupInput | RoleAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RoleAssociationUpdateManyWithWhereWithoutGroupInput | RoleAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RoleAssociationScalarWhereInput | RoleAssociationScalarWhereInput[]
  }

  export type SpaceAssociationUpdateManyWithoutGroupNestedInput = {
    create?: XOR<SpaceAssociationCreateWithoutGroupInput, SpaceAssociationUncheckedCreateWithoutGroupInput> | SpaceAssociationCreateWithoutGroupInput[] | SpaceAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutGroupInput | SpaceAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: SpaceAssociationUpsertWithWhereUniqueWithoutGroupInput | SpaceAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: SpaceAssociationCreateManyGroupInputEnvelope
    set?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    disconnect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    delete?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    update?: SpaceAssociationUpdateWithWhereUniqueWithoutGroupInput | SpaceAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: SpaceAssociationUpdateManyWithWhereWithoutGroupInput | SpaceAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: SpaceAssociationScalarWhereInput | SpaceAssociationScalarWhereInput[]
  }

  export type UserAssociationUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserAssociationCreateWithoutGroupInput, UserAssociationUncheckedCreateWithoutGroupInput> | UserAssociationCreateWithoutGroupInput[] | UserAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutGroupInput | UserAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: UserAssociationUpsertWithWhereUniqueWithoutGroupInput | UserAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserAssociationCreateManyGroupInputEnvelope
    set?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    disconnect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    delete?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    update?: UserAssociationUpdateWithWhereUniqueWithoutGroupInput | UserAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserAssociationUpdateManyWithWhereWithoutGroupInput | UserAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserAssociationScalarWhereInput | UserAssociationScalarWhereInput[]
  }

  export type FileAssociationUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<FileAssociationCreateWithoutGroupInput, FileAssociationUncheckedCreateWithoutGroupInput> | FileAssociationCreateWithoutGroupInput[] | FileAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutGroupInput | FileAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: FileAssociationUpsertWithWhereUniqueWithoutGroupInput | FileAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: FileAssociationCreateManyGroupInputEnvelope
    set?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    disconnect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    delete?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    update?: FileAssociationUpdateWithWhereUniqueWithoutGroupInput | FileAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: FileAssociationUpdateManyWithWhereWithoutGroupInput | FileAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: FileAssociationScalarWhereInput | FileAssociationScalarWhereInput[]
  }

  export type RoleAssociationUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RoleAssociationCreateWithoutGroupInput, RoleAssociationUncheckedCreateWithoutGroupInput> | RoleAssociationCreateWithoutGroupInput[] | RoleAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutGroupInput | RoleAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: RoleAssociationUpsertWithWhereUniqueWithoutGroupInput | RoleAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RoleAssociationCreateManyGroupInputEnvelope
    set?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    disconnect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    delete?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    update?: RoleAssociationUpdateWithWhereUniqueWithoutGroupInput | RoleAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RoleAssociationUpdateManyWithWhereWithoutGroupInput | RoleAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RoleAssociationScalarWhereInput | RoleAssociationScalarWhereInput[]
  }

  export type SpaceAssociationUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<SpaceAssociationCreateWithoutGroupInput, SpaceAssociationUncheckedCreateWithoutGroupInput> | SpaceAssociationCreateWithoutGroupInput[] | SpaceAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutGroupInput | SpaceAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: SpaceAssociationUpsertWithWhereUniqueWithoutGroupInput | SpaceAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: SpaceAssociationCreateManyGroupInputEnvelope
    set?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    disconnect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    delete?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    update?: SpaceAssociationUpdateWithWhereUniqueWithoutGroupInput | SpaceAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: SpaceAssociationUpdateManyWithWhereWithoutGroupInput | SpaceAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: SpaceAssociationScalarWhereInput | SpaceAssociationScalarWhereInput[]
  }

  export type UserAssociationUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserAssociationCreateWithoutGroupInput, UserAssociationUncheckedCreateWithoutGroupInput> | UserAssociationCreateWithoutGroupInput[] | UserAssociationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutGroupInput | UserAssociationCreateOrConnectWithoutGroupInput[]
    upsert?: UserAssociationUpsertWithWhereUniqueWithoutGroupInput | UserAssociationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserAssociationCreateManyGroupInputEnvelope
    set?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    disconnect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    delete?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    update?: UserAssociationUpdateWithWhereUniqueWithoutGroupInput | UserAssociationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserAssociationUpdateManyWithWhereWithoutGroupInput | UserAssociationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserAssociationScalarWhereInput | UserAssociationScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutExerciseInput = {
    create?: XOR<TaskCreateWithoutExerciseInput, TaskUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: TaskCreateOrConnectWithoutExerciseInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutExerciseNestedInput = {
    create?: XOR<TaskCreateWithoutExerciseInput, TaskUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: TaskCreateOrConnectWithoutExerciseInput
    upsert?: TaskUpsertWithoutExerciseInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutExerciseInput, TaskUpdateWithoutExerciseInput>, TaskUncheckedUpdateWithoutExerciseInput>
  }

  export type AssignmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<AssignmentCreateWithoutTenantInput, AssignmentUncheckedCreateWithoutTenantInput> | AssignmentCreateWithoutTenantInput[] | AssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTenantInput | AssignmentCreateOrConnectWithoutTenantInput[]
    createMany?: AssignmentCreateManyTenantInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutTenantInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContentCreateWithoutTenantInput, ContentUncheckedCreateWithoutTenantInput> | ContentCreateWithoutTenantInput[] | ContentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutTenantInput | ContentCreateOrConnectWithoutTenantInput[]
    createMany?: ContentCreateManyTenantInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutTenantInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutTenantInput = {
    create?: XOR<GroupCreateWithoutTenantInput, GroupUncheckedCreateWithoutTenantInput> | GroupCreateWithoutTenantInput[] | GroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutTenantInput | GroupCreateOrConnectWithoutTenantInput[]
    createMany?: GroupCreateManyTenantInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutTenantsInput = {
    create?: XOR<RoleCreateWithoutTenantsInput, RoleUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutTenantsInput
    connect?: RoleWhereUniqueInput
  }

  export type SpaceCreateNestedOneWithoutTenantsInput = {
    create?: XOR<SpaceCreateWithoutTenantsInput, SpaceUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutTenantsInput
    connect?: SpaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTenantsInput = {
    create?: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantsInput
    connect?: UserWhereUniqueInput
  }

  export type TimelineCreateNestedManyWithoutTenantInput = {
    create?: XOR<TimelineCreateWithoutTenantInput, TimelineUncheckedCreateWithoutTenantInput> | TimelineCreateWithoutTenantInput[] | TimelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TimelineCreateOrConnectWithoutTenantInput | TimelineCreateOrConnectWithoutTenantInput[]
    createMany?: TimelineCreateManyTenantInputEnvelope
    connect?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AssignmentCreateWithoutTenantInput, AssignmentUncheckedCreateWithoutTenantInput> | AssignmentCreateWithoutTenantInput[] | AssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTenantInput | AssignmentCreateOrConnectWithoutTenantInput[]
    createMany?: AssignmentCreateManyTenantInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContentCreateWithoutTenantInput, ContentUncheckedCreateWithoutTenantInput> | ContentCreateWithoutTenantInput[] | ContentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutTenantInput | ContentCreateOrConnectWithoutTenantInput[]
    createMany?: ContentCreateManyTenantInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<GroupCreateWithoutTenantInput, GroupUncheckedCreateWithoutTenantInput> | GroupCreateWithoutTenantInput[] | GroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutTenantInput | GroupCreateOrConnectWithoutTenantInput[]
    createMany?: GroupCreateManyTenantInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type TimelineUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TimelineCreateWithoutTenantInput, TimelineUncheckedCreateWithoutTenantInput> | TimelineCreateWithoutTenantInput[] | TimelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TimelineCreateOrConnectWithoutTenantInput | TimelineCreateOrConnectWithoutTenantInput[]
    createMany?: TimelineCreateManyTenantInputEnvelope
    connect?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AssignmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AssignmentCreateWithoutTenantInput, AssignmentUncheckedCreateWithoutTenantInput> | AssignmentCreateWithoutTenantInput[] | AssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTenantInput | AssignmentCreateOrConnectWithoutTenantInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutTenantInput | AssignmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AssignmentCreateManyTenantInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutTenantInput | AssignmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutTenantInput | AssignmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTenantInput | CategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTenantInput | CategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTenantInput | CategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContentCreateWithoutTenantInput, ContentUncheckedCreateWithoutTenantInput> | ContentCreateWithoutTenantInput[] | ContentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutTenantInput | ContentCreateOrConnectWithoutTenantInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutTenantInput | ContentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContentCreateManyTenantInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutTenantInput | ContentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutTenantInput | ContentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type FileUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutTenantInput | FileUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutTenantInput | FileUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FileUpdateManyWithWhereWithoutTenantInput | FileUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutTenantNestedInput = {
    create?: XOR<GroupCreateWithoutTenantInput, GroupUncheckedCreateWithoutTenantInput> | GroupCreateWithoutTenantInput[] | GroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutTenantInput | GroupCreateOrConnectWithoutTenantInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutTenantInput | GroupUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: GroupCreateManyTenantInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutTenantInput | GroupUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutTenantInput | GroupUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type RoleUpdateOneRequiredWithoutTenantsNestedInput = {
    create?: XOR<RoleCreateWithoutTenantsInput, RoleUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutTenantsInput
    upsert?: RoleUpsertWithoutTenantsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutTenantsInput, RoleUpdateWithoutTenantsInput>, RoleUncheckedUpdateWithoutTenantsInput>
  }

  export type SpaceUpdateOneRequiredWithoutTenantsNestedInput = {
    create?: XOR<SpaceCreateWithoutTenantsInput, SpaceUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutTenantsInput
    upsert?: SpaceUpsertWithoutTenantsInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutTenantsInput, SpaceUpdateWithoutTenantsInput>, SpaceUncheckedUpdateWithoutTenantsInput>
  }

  export type UserUpdateOneRequiredWithoutTenantsNestedInput = {
    create?: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantsInput
    upsert?: UserUpsertWithoutTenantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTenantsInput, UserUpdateWithoutTenantsInput>, UserUncheckedUpdateWithoutTenantsInput>
  }

  export type TimelineUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TimelineCreateWithoutTenantInput, TimelineUncheckedCreateWithoutTenantInput> | TimelineCreateWithoutTenantInput[] | TimelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TimelineCreateOrConnectWithoutTenantInput | TimelineCreateOrConnectWithoutTenantInput[]
    upsert?: TimelineUpsertWithWhereUniqueWithoutTenantInput | TimelineUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TimelineCreateManyTenantInputEnvelope
    set?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    disconnect?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    delete?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    connect?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    update?: TimelineUpdateWithWhereUniqueWithoutTenantInput | TimelineUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TimelineUpdateManyWithWhereWithoutTenantInput | TimelineUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TimelineScalarWhereInput | TimelineScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AssignmentCreateWithoutTenantInput, AssignmentUncheckedCreateWithoutTenantInput> | AssignmentCreateWithoutTenantInput[] | AssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTenantInput | AssignmentCreateOrConnectWithoutTenantInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutTenantInput | AssignmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AssignmentCreateManyTenantInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutTenantInput | AssignmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutTenantInput | AssignmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTenantInput | CategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTenantInput | CategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTenantInput | CategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContentCreateWithoutTenantInput, ContentUncheckedCreateWithoutTenantInput> | ContentCreateWithoutTenantInput[] | ContentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutTenantInput | ContentCreateOrConnectWithoutTenantInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutTenantInput | ContentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContentCreateManyTenantInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutTenantInput | ContentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutTenantInput | ContentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutTenantInput | FileUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutTenantInput | FileUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FileUpdateManyWithWhereWithoutTenantInput | FileUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<GroupCreateWithoutTenantInput, GroupUncheckedCreateWithoutTenantInput> | GroupCreateWithoutTenantInput[] | GroupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutTenantInput | GroupCreateOrConnectWithoutTenantInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutTenantInput | GroupUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: GroupCreateManyTenantInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutTenantInput | GroupUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutTenantInput | GroupUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type TimelineUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TimelineCreateWithoutTenantInput, TimelineUncheckedCreateWithoutTenantInput> | TimelineCreateWithoutTenantInput[] | TimelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TimelineCreateOrConnectWithoutTenantInput | TimelineCreateOrConnectWithoutTenantInput[]
    upsert?: TimelineUpsertWithWhereUniqueWithoutTenantInput | TimelineUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TimelineCreateManyTenantInputEnvelope
    set?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    disconnect?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    delete?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    connect?: TimelineWhereUniqueInput | TimelineWhereUniqueInput[]
    update?: TimelineUpdateWithWhereUniqueWithoutTenantInput | TimelineUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TimelineUpdateManyWithWhereWithoutTenantInput | TimelineUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TimelineScalarWhereInput | TimelineScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutTimelineInput = {
    create?: XOR<SessionCreateWithoutTimelineInput, SessionUncheckedCreateWithoutTimelineInput> | SessionCreateWithoutTimelineInput[] | SessionUncheckedCreateWithoutTimelineInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTimelineInput | SessionCreateOrConnectWithoutTimelineInput[]
    createMany?: SessionCreateManyTimelineInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutTimelinesInput = {
    create?: XOR<TenantCreateWithoutTimelinesInput, TenantUncheckedCreateWithoutTimelinesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTimelinesInput
    connect?: TenantWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutTimelineInput = {
    create?: XOR<SessionCreateWithoutTimelineInput, SessionUncheckedCreateWithoutTimelineInput> | SessionCreateWithoutTimelineInput[] | SessionUncheckedCreateWithoutTimelineInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTimelineInput | SessionCreateOrConnectWithoutTimelineInput[]
    createMany?: SessionCreateManyTimelineInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutTimelineNestedInput = {
    create?: XOR<SessionCreateWithoutTimelineInput, SessionUncheckedCreateWithoutTimelineInput> | SessionCreateWithoutTimelineInput[] | SessionUncheckedCreateWithoutTimelineInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTimelineInput | SessionCreateOrConnectWithoutTimelineInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTimelineInput | SessionUpsertWithWhereUniqueWithoutTimelineInput[]
    createMany?: SessionCreateManyTimelineInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTimelineInput | SessionUpdateWithWhereUniqueWithoutTimelineInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTimelineInput | SessionUpdateManyWithWhereWithoutTimelineInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutTimelinesNestedInput = {
    create?: XOR<TenantCreateWithoutTimelinesInput, TenantUncheckedCreateWithoutTimelinesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTimelinesInput
    upsert?: TenantUpsertWithoutTimelinesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTimelinesInput, TenantUpdateWithoutTimelinesInput>, TenantUncheckedUpdateWithoutTimelinesInput>
  }

  export type SessionUncheckedUpdateManyWithoutTimelineNestedInput = {
    create?: XOR<SessionCreateWithoutTimelineInput, SessionUncheckedCreateWithoutTimelineInput> | SessionCreateWithoutTimelineInput[] | SessionUncheckedCreateWithoutTimelineInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTimelineInput | SessionCreateOrConnectWithoutTimelineInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTimelineInput | SessionUpsertWithWhereUniqueWithoutTimelineInput[]
    createMany?: SessionCreateManyTimelineInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTimelineInput | SessionUpdateWithWhereUniqueWithoutTimelineInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTimelineInput | SessionUpdateManyWithWhereWithoutTimelineInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutSessionInput = {
    create?: XOR<ProgramCreateWithoutSessionInput, ProgramUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionInput
    connect?: ProgramWhereUniqueInput
  }

  export type TimelineCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TimelineCreateWithoutSessionsInput, TimelineUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TimelineCreateOrConnectWithoutSessionsInput
    connect?: TimelineWhereUniqueInput
  }

  export type ProgramUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<ProgramCreateWithoutSessionInput, ProgramUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionInput
    connect?: ProgramWhereUniqueInput
  }

  export type EnumSessionTypesFieldUpdateOperationsInput = {
    set?: $Enums.SessionTypes
  }

  export type NullableEnumRepeatCycleTypesFieldUpdateOperationsInput = {
    set?: $Enums.RepeatCycleTypes | null
  }

  export type NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.RecurringDayOfWeek | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProgramUpdateOneWithoutSessionNestedInput = {
    create?: XOR<ProgramCreateWithoutSessionInput, ProgramUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionInput
    upsert?: ProgramUpsertWithoutSessionInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutSessionInput, ProgramUpdateWithoutSessionInput>, ProgramUncheckedUpdateWithoutSessionInput>
  }

  export type TimelineUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TimelineCreateWithoutSessionsInput, TimelineUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TimelineCreateOrConnectWithoutSessionsInput
    upsert?: TimelineUpsertWithoutSessionsInput
    connect?: TimelineWhereUniqueInput
    update?: XOR<XOR<TimelineUpdateToOneWithWhereWithoutSessionsInput, TimelineUpdateWithoutSessionsInput>, TimelineUncheckedUpdateWithoutSessionsInput>
  }

  export type ProgramUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<ProgramCreateWithoutSessionInput, ProgramUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionInput
    upsert?: ProgramUpsertWithoutSessionInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutSessionInput, ProgramUpdateWithoutSessionInput>, ProgramUncheckedUpdateWithoutSessionInput>
  }

  export type RoutineCreateNestedOneWithoutProgramInput = {
    create?: XOR<RoutineCreateWithoutProgramInput, RoutineUncheckedCreateWithoutProgramInput>
    connectOrCreate?: RoutineCreateOrConnectWithoutProgramInput
    connect?: RoutineWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutProgramInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput
    connect?: SessionWhereUniqueInput
  }

  export type RoutineUpdateOneRequiredWithoutProgramNestedInput = {
    create?: XOR<RoutineCreateWithoutProgramInput, RoutineUncheckedCreateWithoutProgramInput>
    connectOrCreate?: RoutineCreateOrConnectWithoutProgramInput
    upsert?: RoutineUpsertWithoutProgramInput
    connect?: RoutineWhereUniqueInput
    update?: XOR<XOR<RoutineUpdateToOneWithWhereWithoutProgramInput, RoutineUpdateWithoutProgramInput>, RoutineUncheckedUpdateWithoutProgramInput>
  }

  export type SessionUpdateOneRequiredWithoutProgramNestedInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput
    upsert?: SessionUpsertWithoutProgramInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutProgramInput, SessionUpdateWithoutProgramInput>, SessionUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramCreateNestedOneWithoutRoutineInput = {
    create?: XOR<ProgramCreateWithoutRoutineInput, ProgramUncheckedCreateWithoutRoutineInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutRoutineInput
    connect?: ProgramWhereUniqueInput
  }

  export type ProgramUncheckedCreateNestedOneWithoutRoutineInput = {
    create?: XOR<ProgramCreateWithoutRoutineInput, ProgramUncheckedCreateWithoutRoutineInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutRoutineInput
    connect?: ProgramWhereUniqueInput
  }

  export type ProgramUpdateOneWithoutRoutineNestedInput = {
    create?: XOR<ProgramCreateWithoutRoutineInput, ProgramUncheckedCreateWithoutRoutineInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutRoutineInput
    upsert?: ProgramUpsertWithoutRoutineInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutRoutineInput, ProgramUpdateWithoutRoutineInput>, ProgramUncheckedUpdateWithoutRoutineInput>
  }

  export type ProgramUncheckedUpdateOneWithoutRoutineNestedInput = {
    create?: XOR<ProgramCreateWithoutRoutineInput, ProgramUncheckedCreateWithoutRoutineInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutRoutineInput
    upsert?: ProgramUpsertWithoutRoutineInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutRoutineInput, ProgramUpdateWithoutRoutineInput>, ProgramUncheckedUpdateWithoutRoutineInput>
  }

  export type ExerciseCreateNestedOneWithoutTaskInput = {
    create?: XOR<ExerciseCreateWithoutTaskInput, ExerciseUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutTaskInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExerciseUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<ExerciseCreateWithoutTaskInput, ExerciseUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutTaskInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExerciseUpdateOneWithoutTaskNestedInput = {
    create?: XOR<ExerciseCreateWithoutTaskInput, ExerciseUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutTaskInput
    upsert?: ExerciseUpsertWithoutTaskInput
    disconnect?: ExerciseWhereInput | boolean
    delete?: ExerciseWhereInput | boolean
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutTaskInput, ExerciseUpdateWithoutTaskInput>, ExerciseUncheckedUpdateWithoutTaskInput>
  }

  export type ExerciseUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<ExerciseCreateWithoutTaskInput, ExerciseUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutTaskInput
    upsert?: ExerciseUpsertWithoutTaskInput
    disconnect?: ExerciseWhereInput | boolean
    delete?: ExerciseWhereInput | boolean
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutTaskInput, ExerciseUpdateWithoutTaskInput>, ExerciseUncheckedUpdateWithoutTaskInput>
  }

  export type RoleCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<RoleCreateWithoutAssignmentsInput, RoleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAssignmentsInput
    connect?: RoleWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<TenantCreateWithoutAssignmentsInput, TenantUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAssignmentsInput
    connect?: TenantWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<RoleCreateWithoutAssignmentsInput, RoleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAssignmentsInput
    upsert?: RoleUpsertWithoutAssignmentsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutAssignmentsInput, RoleUpdateWithoutAssignmentsInput>, RoleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TenantUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<TenantCreateWithoutAssignmentsInput, TenantUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAssignmentsInput
    upsert?: TenantUpsertWithoutAssignmentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAssignmentsInput, TenantUpdateWithoutAssignmentsInput>, TenantUncheckedUpdateWithoutAssignmentsInput>
  }

  export type EnumAbilityActionsFieldUpdateOperationsInput = {
    set?: $Enums.AbilityActions
  }

  export type RoleCreateNestedOneWithoutAbilitiesInput = {
    create?: XOR<RoleCreateWithoutAbilitiesInput, RoleUncheckedCreateWithoutAbilitiesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAbilitiesInput
    connect?: RoleWhereUniqueInput
  }

  export type EnumAbilityTypesFieldUpdateOperationsInput = {
    set?: $Enums.AbilityTypes
  }

  export type RoleUpdateOneRequiredWithoutAbilitiesNestedInput = {
    create?: XOR<RoleCreateWithoutAbilitiesInput, RoleUncheckedCreateWithoutAbilitiesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAbilitiesInput
    upsert?: RoleUpsertWithoutAbilitiesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutAbilitiesInput, RoleUpdateWithoutAbilitiesInput>, RoleUncheckedUpdateWithoutAbilitiesInput>
  }

  export type ContentCreateNestedOneWithoutPostsInput = {
    create?: XOR<ContentCreateWithoutPostsInput, ContentUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutPostsInput
    connect?: ContentWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ContentCreateWithoutPostsInput, ContentUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutPostsInput
    upsert?: ContentUpsertWithoutPostsInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutPostsInput, ContentUpdateWithoutPostsInput>, ContentUncheckedUpdateWithoutPostsInput>
  }

  export type TenantCreateNestedOneWithoutContentsInput = {
    create?: XOR<TenantCreateWithoutContentsInput, TenantUncheckedCreateWithoutContentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContentsInput
    connect?: TenantWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutContentInput = {
    create?: XOR<PostCreateWithoutContentInput, PostUncheckedCreateWithoutContentInput> | PostCreateWithoutContentInput[] | PostUncheckedCreateWithoutContentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutContentInput | PostCreateOrConnectWithoutContentInput[]
    createMany?: PostCreateManyContentInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<PostCreateWithoutContentInput, PostUncheckedCreateWithoutContentInput> | PostCreateWithoutContentInput[] | PostUncheckedCreateWithoutContentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutContentInput | PostCreateOrConnectWithoutContentInput[]
    createMany?: PostCreateManyContentInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type EnumTextTypesFieldUpdateOperationsInput = {
    set?: $Enums.TextTypes
  }

  export type TenantUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<TenantCreateWithoutContentsInput, TenantUncheckedCreateWithoutContentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContentsInput
    upsert?: TenantUpsertWithoutContentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutContentsInput, TenantUpdateWithoutContentsInput>, TenantUncheckedUpdateWithoutContentsInput>
  }

  export type PostUpdateManyWithoutContentNestedInput = {
    create?: XOR<PostCreateWithoutContentInput, PostUncheckedCreateWithoutContentInput> | PostCreateWithoutContentInput[] | PostUncheckedCreateWithoutContentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutContentInput | PostCreateOrConnectWithoutContentInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutContentInput | PostUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: PostCreateManyContentInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutContentInput | PostUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: PostUpdateManyWithWhereWithoutContentInput | PostUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<PostCreateWithoutContentInput, PostUncheckedCreateWithoutContentInput> | PostCreateWithoutContentInput[] | PostUncheckedCreateWithoutContentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutContentInput | PostCreateOrConnectWithoutContentInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutContentInput | PostUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: PostCreateManyContentInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutContentInput | PostUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: PostUpdateManyWithWhereWithoutContentInput | PostUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FileCreateWithoutChildrenInput, FileUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FileCreateOrConnectWithoutChildrenInput
    connect?: FileWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutParentInput = {
    create?: XOR<FileCreateWithoutParentInput, FileUncheckedCreateWithoutParentInput> | FileCreateWithoutParentInput[] | FileUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutParentInput | FileCreateOrConnectWithoutParentInput[]
    createMany?: FileCreateManyParentInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutFilesInput = {
    create?: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFilesInput
    connect?: TenantWhereUniqueInput
  }

  export type FileAssociationCreateNestedManyWithoutFileInput = {
    create?: XOR<FileAssociationCreateWithoutFileInput, FileAssociationUncheckedCreateWithoutFileInput> | FileAssociationCreateWithoutFileInput[] | FileAssociationUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutFileInput | FileAssociationCreateOrConnectWithoutFileInput[]
    createMany?: FileAssociationCreateManyFileInputEnvelope
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
  }

  export type FileClassificationCreateNestedOneWithoutFileInput = {
    create?: XOR<FileClassificationCreateWithoutFileInput, FileClassificationUncheckedCreateWithoutFileInput>
    connectOrCreate?: FileClassificationCreateOrConnectWithoutFileInput
    connect?: FileClassificationWhereUniqueInput
  }

  export type FileUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FileCreateWithoutParentInput, FileUncheckedCreateWithoutParentInput> | FileCreateWithoutParentInput[] | FileUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutParentInput | FileCreateOrConnectWithoutParentInput[]
    createMany?: FileCreateManyParentInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileAssociationUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<FileAssociationCreateWithoutFileInput, FileAssociationUncheckedCreateWithoutFileInput> | FileAssociationCreateWithoutFileInput[] | FileAssociationUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutFileInput | FileAssociationCreateOrConnectWithoutFileInput[]
    createMany?: FileAssociationCreateManyFileInputEnvelope
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
  }

  export type FileClassificationUncheckedCreateNestedOneWithoutFileInput = {
    create?: XOR<FileClassificationCreateWithoutFileInput, FileClassificationUncheckedCreateWithoutFileInput>
    connectOrCreate?: FileClassificationCreateOrConnectWithoutFileInput
    connect?: FileClassificationWhereUniqueInput
  }

  export type FileUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FileCreateWithoutChildrenInput, FileUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FileCreateOrConnectWithoutChildrenInput
    upsert?: FileUpsertWithoutChildrenInput
    disconnect?: FileWhereInput | boolean
    delete?: FileWhereInput | boolean
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutChildrenInput, FileUpdateWithoutChildrenInput>, FileUncheckedUpdateWithoutChildrenInput>
  }

  export type FileUpdateManyWithoutParentNestedInput = {
    create?: XOR<FileCreateWithoutParentInput, FileUncheckedCreateWithoutParentInput> | FileCreateWithoutParentInput[] | FileUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutParentInput | FileCreateOrConnectWithoutParentInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutParentInput | FileUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FileCreateManyParentInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutParentInput | FileUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FileUpdateManyWithWhereWithoutParentInput | FileUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFilesInput
    upsert?: TenantUpsertWithoutFilesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutFilesInput, TenantUpdateWithoutFilesInput>, TenantUncheckedUpdateWithoutFilesInput>
  }

  export type FileAssociationUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileAssociationCreateWithoutFileInput, FileAssociationUncheckedCreateWithoutFileInput> | FileAssociationCreateWithoutFileInput[] | FileAssociationUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutFileInput | FileAssociationCreateOrConnectWithoutFileInput[]
    upsert?: FileAssociationUpsertWithWhereUniqueWithoutFileInput | FileAssociationUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileAssociationCreateManyFileInputEnvelope
    set?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    disconnect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    delete?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    update?: FileAssociationUpdateWithWhereUniqueWithoutFileInput | FileAssociationUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileAssociationUpdateManyWithWhereWithoutFileInput | FileAssociationUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileAssociationScalarWhereInput | FileAssociationScalarWhereInput[]
  }

  export type FileClassificationUpdateOneWithoutFileNestedInput = {
    create?: XOR<FileClassificationCreateWithoutFileInput, FileClassificationUncheckedCreateWithoutFileInput>
    connectOrCreate?: FileClassificationCreateOrConnectWithoutFileInput
    upsert?: FileClassificationUpsertWithoutFileInput
    disconnect?: FileClassificationWhereInput | boolean
    delete?: FileClassificationWhereInput | boolean
    connect?: FileClassificationWhereUniqueInput
    update?: XOR<XOR<FileClassificationUpdateToOneWithWhereWithoutFileInput, FileClassificationUpdateWithoutFileInput>, FileClassificationUncheckedUpdateWithoutFileInput>
  }

  export type FileUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FileCreateWithoutParentInput, FileUncheckedCreateWithoutParentInput> | FileCreateWithoutParentInput[] | FileUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutParentInput | FileCreateOrConnectWithoutParentInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutParentInput | FileUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FileCreateManyParentInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutParentInput | FileUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FileUpdateManyWithWhereWithoutParentInput | FileUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileAssociationUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileAssociationCreateWithoutFileInput, FileAssociationUncheckedCreateWithoutFileInput> | FileAssociationCreateWithoutFileInput[] | FileAssociationUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileAssociationCreateOrConnectWithoutFileInput | FileAssociationCreateOrConnectWithoutFileInput[]
    upsert?: FileAssociationUpsertWithWhereUniqueWithoutFileInput | FileAssociationUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileAssociationCreateManyFileInputEnvelope
    set?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    disconnect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    delete?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    connect?: FileAssociationWhereUniqueInput | FileAssociationWhereUniqueInput[]
    update?: FileAssociationUpdateWithWhereUniqueWithoutFileInput | FileAssociationUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileAssociationUpdateManyWithWhereWithoutFileInput | FileAssociationUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileAssociationScalarWhereInput | FileAssociationScalarWhereInput[]
  }

  export type FileClassificationUncheckedUpdateOneWithoutFileNestedInput = {
    create?: XOR<FileClassificationCreateWithoutFileInput, FileClassificationUncheckedCreateWithoutFileInput>
    connectOrCreate?: FileClassificationCreateOrConnectWithoutFileInput
    upsert?: FileClassificationUpsertWithoutFileInput
    disconnect?: FileClassificationWhereInput | boolean
    delete?: FileClassificationWhereInput | boolean
    connect?: FileClassificationWhereUniqueInput
    update?: XOR<XOR<FileClassificationUpdateToOneWithWhereWithoutFileInput, FileClassificationUpdateWithoutFileInput>, FileClassificationUncheckedUpdateWithoutFileInput>
  }

  export type CategoryCreateNestedOneWithoutFileClassificationsInput = {
    create?: XOR<CategoryCreateWithoutFileClassificationsInput, CategoryUncheckedCreateWithoutFileClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutFileClassificationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type FileCreateNestedOneWithoutClassificationInput = {
    create?: XOR<FileCreateWithoutClassificationInput, FileUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: FileCreateOrConnectWithoutClassificationInput
    connect?: FileWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutFileClassificationsNestedInput = {
    create?: XOR<CategoryCreateWithoutFileClassificationsInput, CategoryUncheckedCreateWithoutFileClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutFileClassificationsInput
    upsert?: CategoryUpsertWithoutFileClassificationsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutFileClassificationsInput, CategoryUpdateWithoutFileClassificationsInput>, CategoryUncheckedUpdateWithoutFileClassificationsInput>
  }

  export type FileUpdateOneRequiredWithoutClassificationNestedInput = {
    create?: XOR<FileCreateWithoutClassificationInput, FileUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: FileCreateOrConnectWithoutClassificationInput
    upsert?: FileUpsertWithoutClassificationInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutClassificationInput, FileUpdateWithoutClassificationInput>, FileUncheckedUpdateWithoutClassificationInput>
  }

  export type FileCreateNestedOneWithoutAssociationsInput = {
    create?: XOR<FileCreateWithoutAssociationsInput, FileUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: FileCreateOrConnectWithoutAssociationsInput
    connect?: FileWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutFileAssociationsInput = {
    create?: XOR<GroupCreateWithoutFileAssociationsInput, GroupUncheckedCreateWithoutFileAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutFileAssociationsInput
    connect?: GroupWhereUniqueInput
  }

  export type FileUpdateOneRequiredWithoutAssociationsNestedInput = {
    create?: XOR<FileCreateWithoutAssociationsInput, FileUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: FileCreateOrConnectWithoutAssociationsInput
    upsert?: FileUpsertWithoutAssociationsInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutAssociationsInput, FileUpdateWithoutAssociationsInput>, FileUncheckedUpdateWithoutAssociationsInput>
  }

  export type GroupUpdateOneRequiredWithoutFileAssociationsNestedInput = {
    create?: XOR<GroupCreateWithoutFileAssociationsInput, GroupUncheckedCreateWithoutFileAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutFileAssociationsInput
    upsert?: GroupUpsertWithoutFileAssociationsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutFileAssociationsInput, GroupUpdateWithoutFileAssociationsInput>, GroupUncheckedUpdateWithoutFileAssociationsInput>
  }

  export type AbilityCreateNestedManyWithoutRoleInput = {
    create?: XOR<AbilityCreateWithoutRoleInput, AbilityUncheckedCreateWithoutRoleInput> | AbilityCreateWithoutRoleInput[] | AbilityUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutRoleInput | AbilityCreateOrConnectWithoutRoleInput[]
    createMany?: AbilityCreateManyRoleInputEnvelope
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutRoleInput = {
    create?: XOR<AssignmentCreateWithoutRoleInput, AssignmentUncheckedCreateWithoutRoleInput> | AssignmentCreateWithoutRoleInput[] | AssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutRoleInput | AssignmentCreateOrConnectWithoutRoleInput[]
    createMany?: AssignmentCreateManyRoleInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type RoleAssociationCreateNestedManyWithoutRoleInput = {
    create?: XOR<RoleAssociationCreateWithoutRoleInput, RoleAssociationUncheckedCreateWithoutRoleInput> | RoleAssociationCreateWithoutRoleInput[] | RoleAssociationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutRoleInput | RoleAssociationCreateOrConnectWithoutRoleInput[]
    createMany?: RoleAssociationCreateManyRoleInputEnvelope
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
  }

  export type RoleClassificationCreateNestedOneWithoutRoleInput = {
    create?: XOR<RoleClassificationCreateWithoutRoleInput, RoleClassificationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutRoleInput
    connect?: RoleClassificationWhereUniqueInput
  }

  export type TenantCreateNestedManyWithoutRoleInput = {
    create?: XOR<TenantCreateWithoutRoleInput, TenantUncheckedCreateWithoutRoleInput> | TenantCreateWithoutRoleInput[] | TenantUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutRoleInput | TenantCreateOrConnectWithoutRoleInput[]
    createMany?: TenantCreateManyRoleInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type AbilityUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<AbilityCreateWithoutRoleInput, AbilityUncheckedCreateWithoutRoleInput> | AbilityCreateWithoutRoleInput[] | AbilityUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutRoleInput | AbilityCreateOrConnectWithoutRoleInput[]
    createMany?: AbilityCreateManyRoleInputEnvelope
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<AssignmentCreateWithoutRoleInput, AssignmentUncheckedCreateWithoutRoleInput> | AssignmentCreateWithoutRoleInput[] | AssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutRoleInput | AssignmentCreateOrConnectWithoutRoleInput[]
    createMany?: AssignmentCreateManyRoleInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type RoleAssociationUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RoleAssociationCreateWithoutRoleInput, RoleAssociationUncheckedCreateWithoutRoleInput> | RoleAssociationCreateWithoutRoleInput[] | RoleAssociationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutRoleInput | RoleAssociationCreateOrConnectWithoutRoleInput[]
    createMany?: RoleAssociationCreateManyRoleInputEnvelope
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
  }

  export type RoleClassificationUncheckedCreateNestedOneWithoutRoleInput = {
    create?: XOR<RoleClassificationCreateWithoutRoleInput, RoleClassificationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutRoleInput
    connect?: RoleClassificationWhereUniqueInput
  }

  export type TenantUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<TenantCreateWithoutRoleInput, TenantUncheckedCreateWithoutRoleInput> | TenantCreateWithoutRoleInput[] | TenantUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutRoleInput | TenantCreateOrConnectWithoutRoleInput[]
    createMany?: TenantCreateManyRoleInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type EnumRolesFieldUpdateOperationsInput = {
    set?: $Enums.Roles
  }

  export type AbilityUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AbilityCreateWithoutRoleInput, AbilityUncheckedCreateWithoutRoleInput> | AbilityCreateWithoutRoleInput[] | AbilityUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutRoleInput | AbilityCreateOrConnectWithoutRoleInput[]
    upsert?: AbilityUpsertWithWhereUniqueWithoutRoleInput | AbilityUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AbilityCreateManyRoleInputEnvelope
    set?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    disconnect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    delete?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    update?: AbilityUpdateWithWhereUniqueWithoutRoleInput | AbilityUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AbilityUpdateManyWithWhereWithoutRoleInput | AbilityUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AssignmentCreateWithoutRoleInput, AssignmentUncheckedCreateWithoutRoleInput> | AssignmentCreateWithoutRoleInput[] | AssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutRoleInput | AssignmentCreateOrConnectWithoutRoleInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutRoleInput | AssignmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AssignmentCreateManyRoleInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutRoleInput | AssignmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutRoleInput | AssignmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type RoleAssociationUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RoleAssociationCreateWithoutRoleInput, RoleAssociationUncheckedCreateWithoutRoleInput> | RoleAssociationCreateWithoutRoleInput[] | RoleAssociationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutRoleInput | RoleAssociationCreateOrConnectWithoutRoleInput[]
    upsert?: RoleAssociationUpsertWithWhereUniqueWithoutRoleInput | RoleAssociationUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RoleAssociationCreateManyRoleInputEnvelope
    set?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    disconnect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    delete?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    update?: RoleAssociationUpdateWithWhereUniqueWithoutRoleInput | RoleAssociationUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RoleAssociationUpdateManyWithWhereWithoutRoleInput | RoleAssociationUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RoleAssociationScalarWhereInput | RoleAssociationScalarWhereInput[]
  }

  export type RoleClassificationUpdateOneWithoutRoleNestedInput = {
    create?: XOR<RoleClassificationCreateWithoutRoleInput, RoleClassificationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutRoleInput
    upsert?: RoleClassificationUpsertWithoutRoleInput
    disconnect?: RoleClassificationWhereInput | boolean
    delete?: RoleClassificationWhereInput | boolean
    connect?: RoleClassificationWhereUniqueInput
    update?: XOR<XOR<RoleClassificationUpdateToOneWithWhereWithoutRoleInput, RoleClassificationUpdateWithoutRoleInput>, RoleClassificationUncheckedUpdateWithoutRoleInput>
  }

  export type TenantUpdateManyWithoutRoleNestedInput = {
    create?: XOR<TenantCreateWithoutRoleInput, TenantUncheckedCreateWithoutRoleInput> | TenantCreateWithoutRoleInput[] | TenantUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutRoleInput | TenantCreateOrConnectWithoutRoleInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutRoleInput | TenantUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: TenantCreateManyRoleInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutRoleInput | TenantUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutRoleInput | TenantUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type AbilityUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AbilityCreateWithoutRoleInput, AbilityUncheckedCreateWithoutRoleInput> | AbilityCreateWithoutRoleInput[] | AbilityUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutRoleInput | AbilityCreateOrConnectWithoutRoleInput[]
    upsert?: AbilityUpsertWithWhereUniqueWithoutRoleInput | AbilityUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AbilityCreateManyRoleInputEnvelope
    set?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    disconnect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    delete?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    update?: AbilityUpdateWithWhereUniqueWithoutRoleInput | AbilityUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AbilityUpdateManyWithWhereWithoutRoleInput | AbilityUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AssignmentCreateWithoutRoleInput, AssignmentUncheckedCreateWithoutRoleInput> | AssignmentCreateWithoutRoleInput[] | AssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutRoleInput | AssignmentCreateOrConnectWithoutRoleInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutRoleInput | AssignmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AssignmentCreateManyRoleInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutRoleInput | AssignmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutRoleInput | AssignmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type RoleAssociationUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RoleAssociationCreateWithoutRoleInput, RoleAssociationUncheckedCreateWithoutRoleInput> | RoleAssociationCreateWithoutRoleInput[] | RoleAssociationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleAssociationCreateOrConnectWithoutRoleInput | RoleAssociationCreateOrConnectWithoutRoleInput[]
    upsert?: RoleAssociationUpsertWithWhereUniqueWithoutRoleInput | RoleAssociationUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RoleAssociationCreateManyRoleInputEnvelope
    set?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    disconnect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    delete?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    connect?: RoleAssociationWhereUniqueInput | RoleAssociationWhereUniqueInput[]
    update?: RoleAssociationUpdateWithWhereUniqueWithoutRoleInput | RoleAssociationUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RoleAssociationUpdateManyWithWhereWithoutRoleInput | RoleAssociationUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RoleAssociationScalarWhereInput | RoleAssociationScalarWhereInput[]
  }

  export type RoleClassificationUncheckedUpdateOneWithoutRoleNestedInput = {
    create?: XOR<RoleClassificationCreateWithoutRoleInput, RoleClassificationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleClassificationCreateOrConnectWithoutRoleInput
    upsert?: RoleClassificationUpsertWithoutRoleInput
    disconnect?: RoleClassificationWhereInput | boolean
    delete?: RoleClassificationWhereInput | boolean
    connect?: RoleClassificationWhereUniqueInput
    update?: XOR<XOR<RoleClassificationUpdateToOneWithWhereWithoutRoleInput, RoleClassificationUpdateWithoutRoleInput>, RoleClassificationUncheckedUpdateWithoutRoleInput>
  }

  export type TenantUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<TenantCreateWithoutRoleInput, TenantUncheckedCreateWithoutRoleInput> | TenantCreateWithoutRoleInput[] | TenantUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutRoleInput | TenantCreateOrConnectWithoutRoleInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutRoleInput | TenantUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: TenantCreateManyRoleInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutRoleInput | TenantUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutRoleInput | TenantUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutRoleAssociationsInput = {
    create?: XOR<GroupCreateWithoutRoleAssociationsInput, GroupUncheckedCreateWithoutRoleAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutRoleAssociationsInput
    connect?: GroupWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutAssociationsInput = {
    create?: XOR<RoleCreateWithoutAssociationsInput, RoleUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAssociationsInput
    connect?: RoleWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutRoleAssociationsNestedInput = {
    create?: XOR<GroupCreateWithoutRoleAssociationsInput, GroupUncheckedCreateWithoutRoleAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutRoleAssociationsInput
    upsert?: GroupUpsertWithoutRoleAssociationsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutRoleAssociationsInput, GroupUpdateWithoutRoleAssociationsInput>, GroupUncheckedUpdateWithoutRoleAssociationsInput>
  }

  export type RoleUpdateOneRequiredWithoutAssociationsNestedInput = {
    create?: XOR<RoleCreateWithoutAssociationsInput, RoleUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAssociationsInput
    upsert?: RoleUpsertWithoutAssociationsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutAssociationsInput, RoleUpdateWithoutAssociationsInput>, RoleUncheckedUpdateWithoutAssociationsInput>
  }

  export type CategoryCreateNestedOneWithoutRoleClassificationsInput = {
    create?: XOR<CategoryCreateWithoutRoleClassificationsInput, CategoryUncheckedCreateWithoutRoleClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRoleClassificationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutClassificationInput = {
    create?: XOR<RoleCreateWithoutClassificationInput, RoleUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: RoleCreateOrConnectWithoutClassificationInput
    connect?: RoleWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutRoleClassificationsNestedInput = {
    create?: XOR<CategoryCreateWithoutRoleClassificationsInput, CategoryUncheckedCreateWithoutRoleClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRoleClassificationsInput
    upsert?: CategoryUpsertWithoutRoleClassificationsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutRoleClassificationsInput, CategoryUpdateWithoutRoleClassificationsInput>, CategoryUncheckedUpdateWithoutRoleClassificationsInput>
  }

  export type RoleUpdateOneRequiredWithoutClassificationNestedInput = {
    create?: XOR<RoleCreateWithoutClassificationInput, RoleUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: RoleCreateOrConnectWithoutClassificationInput
    upsert?: RoleUpsertWithoutClassificationInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutClassificationInput, RoleUpdateWithoutClassificationInput>, RoleUncheckedUpdateWithoutClassificationInput>
  }

  export type GroundCreateNestedOneWithoutSpaceInput = {
    create?: XOR<GroundCreateWithoutSpaceInput, GroundUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: GroundCreateOrConnectWithoutSpaceInput
    connect?: GroundWhereUniqueInput
  }

  export type SpaceAssociationCreateNestedManyWithoutSpaceInput = {
    create?: XOR<SpaceAssociationCreateWithoutSpaceInput, SpaceAssociationUncheckedCreateWithoutSpaceInput> | SpaceAssociationCreateWithoutSpaceInput[] | SpaceAssociationUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutSpaceInput | SpaceAssociationCreateOrConnectWithoutSpaceInput[]
    createMany?: SpaceAssociationCreateManySpaceInputEnvelope
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
  }

  export type SpaceClassificationCreateNestedOneWithoutSpaceInput = {
    create?: XOR<SpaceClassificationCreateWithoutSpaceInput, SpaceClassificationUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutSpaceInput
    connect?: SpaceClassificationWhereUniqueInput
  }

  export type TenantCreateNestedManyWithoutSpaceInput = {
    create?: XOR<TenantCreateWithoutSpaceInput, TenantUncheckedCreateWithoutSpaceInput> | TenantCreateWithoutSpaceInput[] | TenantUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSpaceInput | TenantCreateOrConnectWithoutSpaceInput[]
    createMany?: TenantCreateManySpaceInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type GroundUncheckedCreateNestedOneWithoutSpaceInput = {
    create?: XOR<GroundCreateWithoutSpaceInput, GroundUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: GroundCreateOrConnectWithoutSpaceInput
    connect?: GroundWhereUniqueInput
  }

  export type SpaceAssociationUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<SpaceAssociationCreateWithoutSpaceInput, SpaceAssociationUncheckedCreateWithoutSpaceInput> | SpaceAssociationCreateWithoutSpaceInput[] | SpaceAssociationUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutSpaceInput | SpaceAssociationCreateOrConnectWithoutSpaceInput[]
    createMany?: SpaceAssociationCreateManySpaceInputEnvelope
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
  }

  export type SpaceClassificationUncheckedCreateNestedOneWithoutSpaceInput = {
    create?: XOR<SpaceClassificationCreateWithoutSpaceInput, SpaceClassificationUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutSpaceInput
    connect?: SpaceClassificationWhereUniqueInput
  }

  export type TenantUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<TenantCreateWithoutSpaceInput, TenantUncheckedCreateWithoutSpaceInput> | TenantCreateWithoutSpaceInput[] | TenantUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSpaceInput | TenantCreateOrConnectWithoutSpaceInput[]
    createMany?: TenantCreateManySpaceInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type GroundUpdateOneWithoutSpaceNestedInput = {
    create?: XOR<GroundCreateWithoutSpaceInput, GroundUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: GroundCreateOrConnectWithoutSpaceInput
    upsert?: GroundUpsertWithoutSpaceInput
    disconnect?: GroundWhereInput | boolean
    delete?: GroundWhereInput | boolean
    connect?: GroundWhereUniqueInput
    update?: XOR<XOR<GroundUpdateToOneWithWhereWithoutSpaceInput, GroundUpdateWithoutSpaceInput>, GroundUncheckedUpdateWithoutSpaceInput>
  }

  export type SpaceAssociationUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<SpaceAssociationCreateWithoutSpaceInput, SpaceAssociationUncheckedCreateWithoutSpaceInput> | SpaceAssociationCreateWithoutSpaceInput[] | SpaceAssociationUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutSpaceInput | SpaceAssociationCreateOrConnectWithoutSpaceInput[]
    upsert?: SpaceAssociationUpsertWithWhereUniqueWithoutSpaceInput | SpaceAssociationUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: SpaceAssociationCreateManySpaceInputEnvelope
    set?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    disconnect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    delete?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    update?: SpaceAssociationUpdateWithWhereUniqueWithoutSpaceInput | SpaceAssociationUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: SpaceAssociationUpdateManyWithWhereWithoutSpaceInput | SpaceAssociationUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: SpaceAssociationScalarWhereInput | SpaceAssociationScalarWhereInput[]
  }

  export type SpaceClassificationUpdateOneWithoutSpaceNestedInput = {
    create?: XOR<SpaceClassificationCreateWithoutSpaceInput, SpaceClassificationUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutSpaceInput
    upsert?: SpaceClassificationUpsertWithoutSpaceInput
    disconnect?: SpaceClassificationWhereInput | boolean
    delete?: SpaceClassificationWhereInput | boolean
    connect?: SpaceClassificationWhereUniqueInput
    update?: XOR<XOR<SpaceClassificationUpdateToOneWithWhereWithoutSpaceInput, SpaceClassificationUpdateWithoutSpaceInput>, SpaceClassificationUncheckedUpdateWithoutSpaceInput>
  }

  export type TenantUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<TenantCreateWithoutSpaceInput, TenantUncheckedCreateWithoutSpaceInput> | TenantCreateWithoutSpaceInput[] | TenantUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSpaceInput | TenantCreateOrConnectWithoutSpaceInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutSpaceInput | TenantUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: TenantCreateManySpaceInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutSpaceInput | TenantUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutSpaceInput | TenantUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type GroundUncheckedUpdateOneWithoutSpaceNestedInput = {
    create?: XOR<GroundCreateWithoutSpaceInput, GroundUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: GroundCreateOrConnectWithoutSpaceInput
    upsert?: GroundUpsertWithoutSpaceInput
    disconnect?: GroundWhereInput | boolean
    delete?: GroundWhereInput | boolean
    connect?: GroundWhereUniqueInput
    update?: XOR<XOR<GroundUpdateToOneWithWhereWithoutSpaceInput, GroundUpdateWithoutSpaceInput>, GroundUncheckedUpdateWithoutSpaceInput>
  }

  export type SpaceAssociationUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<SpaceAssociationCreateWithoutSpaceInput, SpaceAssociationUncheckedCreateWithoutSpaceInput> | SpaceAssociationCreateWithoutSpaceInput[] | SpaceAssociationUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceAssociationCreateOrConnectWithoutSpaceInput | SpaceAssociationCreateOrConnectWithoutSpaceInput[]
    upsert?: SpaceAssociationUpsertWithWhereUniqueWithoutSpaceInput | SpaceAssociationUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: SpaceAssociationCreateManySpaceInputEnvelope
    set?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    disconnect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    delete?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    connect?: SpaceAssociationWhereUniqueInput | SpaceAssociationWhereUniqueInput[]
    update?: SpaceAssociationUpdateWithWhereUniqueWithoutSpaceInput | SpaceAssociationUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: SpaceAssociationUpdateManyWithWhereWithoutSpaceInput | SpaceAssociationUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: SpaceAssociationScalarWhereInput | SpaceAssociationScalarWhereInput[]
  }

  export type SpaceClassificationUncheckedUpdateOneWithoutSpaceNestedInput = {
    create?: XOR<SpaceClassificationCreateWithoutSpaceInput, SpaceClassificationUncheckedCreateWithoutSpaceInput>
    connectOrCreate?: SpaceClassificationCreateOrConnectWithoutSpaceInput
    upsert?: SpaceClassificationUpsertWithoutSpaceInput
    disconnect?: SpaceClassificationWhereInput | boolean
    delete?: SpaceClassificationWhereInput | boolean
    connect?: SpaceClassificationWhereUniqueInput
    update?: XOR<XOR<SpaceClassificationUpdateToOneWithWhereWithoutSpaceInput, SpaceClassificationUpdateWithoutSpaceInput>, SpaceClassificationUncheckedUpdateWithoutSpaceInput>
  }

  export type TenantUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<TenantCreateWithoutSpaceInput, TenantUncheckedCreateWithoutSpaceInput> | TenantCreateWithoutSpaceInput[] | TenantUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSpaceInput | TenantCreateOrConnectWithoutSpaceInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutSpaceInput | TenantUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: TenantCreateManySpaceInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutSpaceInput | TenantUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutSpaceInput | TenantUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSpaceClassificationsInput = {
    create?: XOR<CategoryCreateWithoutSpaceClassificationsInput, CategoryUncheckedCreateWithoutSpaceClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSpaceClassificationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SpaceCreateNestedOneWithoutClassificationInput = {
    create?: XOR<SpaceCreateWithoutClassificationInput, SpaceUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutClassificationInput
    connect?: SpaceWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutSpaceClassificationsNestedInput = {
    create?: XOR<CategoryCreateWithoutSpaceClassificationsInput, CategoryUncheckedCreateWithoutSpaceClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSpaceClassificationsInput
    upsert?: CategoryUpsertWithoutSpaceClassificationsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSpaceClassificationsInput, CategoryUpdateWithoutSpaceClassificationsInput>, CategoryUncheckedUpdateWithoutSpaceClassificationsInput>
  }

  export type SpaceUpdateOneRequiredWithoutClassificationNestedInput = {
    create?: XOR<SpaceCreateWithoutClassificationInput, SpaceUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutClassificationInput
    upsert?: SpaceUpsertWithoutClassificationInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutClassificationInput, SpaceUpdateWithoutClassificationInput>, SpaceUncheckedUpdateWithoutClassificationInput>
  }

  export type GroupCreateNestedOneWithoutSpaceAssociationsInput = {
    create?: XOR<GroupCreateWithoutSpaceAssociationsInput, GroupUncheckedCreateWithoutSpaceAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutSpaceAssociationsInput
    connect?: GroupWhereUniqueInput
  }

  export type SpaceCreateNestedOneWithoutAssociationsInput = {
    create?: XOR<SpaceCreateWithoutAssociationsInput, SpaceUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutAssociationsInput
    connect?: SpaceWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutSpaceAssociationsNestedInput = {
    create?: XOR<GroupCreateWithoutSpaceAssociationsInput, GroupUncheckedCreateWithoutSpaceAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutSpaceAssociationsInput
    upsert?: GroupUpsertWithoutSpaceAssociationsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutSpaceAssociationsInput, GroupUpdateWithoutSpaceAssociationsInput>, GroupUncheckedUpdateWithoutSpaceAssociationsInput>
  }

  export type SpaceUpdateOneRequiredWithoutAssociationsNestedInput = {
    create?: XOR<SpaceCreateWithoutAssociationsInput, SpaceUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutAssociationsInput
    upsert?: SpaceUpsertWithoutAssociationsInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutAssociationsInput, SpaceUpdateWithoutAssociationsInput>, SpaceUncheckedUpdateWithoutAssociationsInput>
  }

  export type SpaceCreateNestedOneWithoutGroundInput = {
    create?: XOR<SpaceCreateWithoutGroundInput, SpaceUncheckedCreateWithoutGroundInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutGroundInput
    connect?: SpaceWhereUniqueInput
  }

  export type SpaceUpdateOneRequiredWithoutGroundNestedInput = {
    create?: XOR<SpaceCreateWithoutGroundInput, SpaceUncheckedCreateWithoutGroundInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutGroundInput
    upsert?: SpaceUpsertWithoutGroundInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutGroundInput, SpaceUpdateWithoutGroundInput>, SpaceUncheckedUpdateWithoutGroundInput>
  }

  export type ProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type TenantCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type UserClassificationCreateNestedOneWithoutUserInput = {
    create?: XOR<UserClassificationCreateWithoutUserInput, UserClassificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserClassificationCreateOrConnectWithoutUserInput
    connect?: UserClassificationWhereUniqueInput
  }

  export type UserAssociationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAssociationCreateWithoutUserInput, UserAssociationUncheckedCreateWithoutUserInput> | UserAssociationCreateWithoutUserInput[] | UserAssociationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutUserInput | UserAssociationCreateOrConnectWithoutUserInput[]
    createMany?: UserAssociationCreateManyUserInputEnvelope
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type TenantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type UserClassificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserClassificationCreateWithoutUserInput, UserClassificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserClassificationCreateOrConnectWithoutUserInput
    connect?: UserClassificationWhereUniqueInput
  }

  export type UserAssociationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAssociationCreateWithoutUserInput, UserAssociationUncheckedCreateWithoutUserInput> | UserAssociationCreateWithoutUserInput[] | UserAssociationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutUserInput | UserAssociationCreateOrConnectWithoutUserInput[]
    createMany?: UserAssociationCreateManyUserInputEnvelope
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
  }

  export type ProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type TenantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutUserInput | TenantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutUserInput | TenantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutUserInput | TenantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type UserClassificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserClassificationCreateWithoutUserInput, UserClassificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserClassificationCreateOrConnectWithoutUserInput
    upsert?: UserClassificationUpsertWithoutUserInput
    disconnect?: UserClassificationWhereInput | boolean
    delete?: UserClassificationWhereInput | boolean
    connect?: UserClassificationWhereUniqueInput
    update?: XOR<XOR<UserClassificationUpdateToOneWithWhereWithoutUserInput, UserClassificationUpdateWithoutUserInput>, UserClassificationUncheckedUpdateWithoutUserInput>
  }

  export type UserAssociationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAssociationCreateWithoutUserInput, UserAssociationUncheckedCreateWithoutUserInput> | UserAssociationCreateWithoutUserInput[] | UserAssociationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutUserInput | UserAssociationCreateOrConnectWithoutUserInput[]
    upsert?: UserAssociationUpsertWithWhereUniqueWithoutUserInput | UserAssociationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAssociationCreateManyUserInputEnvelope
    set?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    disconnect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    delete?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    update?: UserAssociationUpdateWithWhereUniqueWithoutUserInput | UserAssociationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAssociationUpdateManyWithWhereWithoutUserInput | UserAssociationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAssociationScalarWhereInput | UserAssociationScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type TenantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutUserInput | TenantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutUserInput | TenantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutUserInput | TenantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type UserClassificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserClassificationCreateWithoutUserInput, UserClassificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserClassificationCreateOrConnectWithoutUserInput
    upsert?: UserClassificationUpsertWithoutUserInput
    disconnect?: UserClassificationWhereInput | boolean
    delete?: UserClassificationWhereInput | boolean
    connect?: UserClassificationWhereUniqueInput
    update?: XOR<XOR<UserClassificationUpdateToOneWithWhereWithoutUserInput, UserClassificationUpdateWithoutUserInput>, UserClassificationUncheckedUpdateWithoutUserInput>
  }

  export type UserAssociationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAssociationCreateWithoutUserInput, UserAssociationUncheckedCreateWithoutUserInput> | UserAssociationCreateWithoutUserInput[] | UserAssociationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssociationCreateOrConnectWithoutUserInput | UserAssociationCreateOrConnectWithoutUserInput[]
    upsert?: UserAssociationUpsertWithWhereUniqueWithoutUserInput | UserAssociationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAssociationCreateManyUserInputEnvelope
    set?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    disconnect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    delete?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    connect?: UserAssociationWhereUniqueInput | UserAssociationWhereUniqueInput[]
    update?: UserAssociationUpdateWithWhereUniqueWithoutUserInput | UserAssociationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAssociationUpdateManyWithWhereWithoutUserInput | UserAssociationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAssociationScalarWhereInput | UserAssociationScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutUserClassificationsInput = {
    create?: XOR<CategoryCreateWithoutUserClassificationsInput, CategoryUncheckedCreateWithoutUserClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutUserClassificationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassificationInput = {
    create?: XOR<UserCreateWithoutClassificationInput, UserUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassificationInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutUserClassificationsNestedInput = {
    create?: XOR<CategoryCreateWithoutUserClassificationsInput, CategoryUncheckedCreateWithoutUserClassificationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutUserClassificationsInput
    upsert?: CategoryUpsertWithoutUserClassificationsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutUserClassificationsInput, CategoryUpdateWithoutUserClassificationsInput>, CategoryUncheckedUpdateWithoutUserClassificationsInput>
  }

  export type UserUpdateOneRequiredWithoutClassificationNestedInput = {
    create?: XOR<UserCreateWithoutClassificationInput, UserUncheckedCreateWithoutClassificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassificationInput
    upsert?: UserUpsertWithoutClassificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassificationInput, UserUpdateWithoutClassificationInput>, UserUncheckedUpdateWithoutClassificationInput>
  }

  export type GroupCreateNestedOneWithoutUserAssociationsInput = {
    create?: XOR<GroupCreateWithoutUserAssociationsInput, GroupUncheckedCreateWithoutUserAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUserAssociationsInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssociationsInput = {
    create?: XOR<UserCreateWithoutAssociationsInput, UserUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssociationsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutUserAssociationsNestedInput = {
    create?: XOR<GroupCreateWithoutUserAssociationsInput, GroupUncheckedCreateWithoutUserAssociationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUserAssociationsInput
    upsert?: GroupUpsertWithoutUserAssociationsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutUserAssociationsInput, GroupUpdateWithoutUserAssociationsInput>, GroupUncheckedUpdateWithoutUserAssociationsInput>
  }

  export type UserUpdateOneRequiredWithoutAssociationsNestedInput = {
    create?: XOR<UserCreateWithoutAssociationsInput, UserUncheckedCreateWithoutAssociationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssociationsInput
    upsert?: UserUpsertWithoutAssociationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssociationsInput, UserUpdateWithoutAssociationsInput>, UserUncheckedUpdateWithoutAssociationsInput>
  }

  export type UserCreateNestedOneWithoutProfilesInput = {
    create?: XOR<UserCreateWithoutProfilesInput, UserUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfilesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<UserCreateWithoutProfilesInput, UserUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfilesInput
    upsert?: UserUpsertWithoutProfilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfilesInput, UserUpdateWithoutProfilesInput>, UserUncheckedUpdateWithoutProfilesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCategoryTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryTypes | EnumCategoryTypesFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypesFilter<$PrismaModel> | $Enums.CategoryTypes
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCategoryTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryTypes | EnumCategoryTypesFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryTypes[] | ListEnumCategoryTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypesWithAggregatesFilter<$PrismaModel> | $Enums.CategoryTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypesFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypesFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumGroupTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupTypes | EnumGroupTypesFieldRefInput<$PrismaModel>
    in?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypesFilter<$PrismaModel> | $Enums.GroupTypes
  }

  export type NestedEnumGroupTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupTypes | EnumGroupTypesFieldRefInput<$PrismaModel>
    in?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupTypes[] | ListEnumGroupTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypesWithAggregatesFilter<$PrismaModel> | $Enums.GroupTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupTypesFilter<$PrismaModel>
    _max?: NestedEnumGroupTypesFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSessionTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionTypes | EnumSessionTypesFieldRefInput<$PrismaModel>
    in?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypesFilter<$PrismaModel> | $Enums.SessionTypes
  }

  export type NestedEnumRepeatCycleTypesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatCycleTypes | EnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    in?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRepeatCycleTypesNullableFilter<$PrismaModel> | $Enums.RepeatCycleTypes | null
  }

  export type NestedEnumRecurringDayOfWeekNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringDayOfWeek | EnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurringDayOfWeekNullableFilter<$PrismaModel> | $Enums.RecurringDayOfWeek | null
  }

  export type NestedEnumSessionTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionTypes | EnumSessionTypesFieldRefInput<$PrismaModel>
    in?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionTypes[] | ListEnumSessionTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypesWithAggregatesFilter<$PrismaModel> | $Enums.SessionTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypesFilter<$PrismaModel>
    _max?: NestedEnumSessionTypesFilter<$PrismaModel>
  }

  export type NestedEnumRepeatCycleTypesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatCycleTypes | EnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    in?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RepeatCycleTypes[] | ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRepeatCycleTypesNullableWithAggregatesFilter<$PrismaModel> | $Enums.RepeatCycleTypes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRepeatCycleTypesNullableFilter<$PrismaModel>
    _max?: NestedEnumRepeatCycleTypesNullableFilter<$PrismaModel>
  }

  export type NestedEnumRecurringDayOfWeekNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringDayOfWeek | EnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurringDayOfWeek[] | ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurringDayOfWeekNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurringDayOfWeek | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurringDayOfWeekNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurringDayOfWeekNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAbilityActionsFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityActions | EnumAbilityActionsFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityActionsFilter<$PrismaModel> | $Enums.AbilityActions
  }

  export type NestedEnumAbilityActionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityActions | EnumAbilityActionsFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityActions[] | ListEnumAbilityActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityActionsWithAggregatesFilter<$PrismaModel> | $Enums.AbilityActions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbilityActionsFilter<$PrismaModel>
    _max?: NestedEnumAbilityActionsFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAbilityTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityTypes | EnumAbilityTypesFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityTypesFilter<$PrismaModel> | $Enums.AbilityTypes
  }

  export type NestedEnumAbilityTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbilityTypes | EnumAbilityTypesFieldRefInput<$PrismaModel>
    in?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbilityTypes[] | ListEnumAbilityTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityTypesWithAggregatesFilter<$PrismaModel> | $Enums.AbilityTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbilityTypesFilter<$PrismaModel>
    _max?: NestedEnumAbilityTypesFilter<$PrismaModel>
  }

  export type NestedEnumTextTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextTypes | EnumTextTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypesFilter<$PrismaModel> | $Enums.TextTypes
  }

  export type NestedEnumTextTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextTypes | EnumTextTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextTypes[] | ListEnumTextTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypesWithAggregatesFilter<$PrismaModel> | $Enums.TextTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextTypesFilter<$PrismaModel>
    _max?: NestedEnumTextTypesFilter<$PrismaModel>
  }

  export type NestedEnumRolesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    not?: NestedEnumRolesFilter<$PrismaModel> | $Enums.Roles
  }

  export type NestedEnumRolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Roles[] | ListEnumRolesFieldRefInput<$PrismaModel>
    not?: NestedEnumRolesWithAggregatesFilter<$PrismaModel> | $Enums.Roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolesFilter<$PrismaModel>
    _max?: NestedEnumRolesFilter<$PrismaModel>
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    fileClassifications?: FileClassificationCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    tenantId: string
    fileClassifications?: FileClassificationUncheckedCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    children?: CategoryCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    fileClassifications?: FileClassificationCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    tenantId: string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    fileClassifications?: FileClassificationUncheckedCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutCategoriesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCategoriesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCategoriesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
  }

  export type FileClassificationCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    file: FileCreateNestedOneWithoutClassificationInput
  }

  export type FileClassificationUncheckedCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    fileId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type FileClassificationCreateOrConnectWithoutCategoryInput = {
    where: FileClassificationWhereUniqueInput
    create: XOR<FileClassificationCreateWithoutCategoryInput, FileClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type FileClassificationCreateManyCategoryInputEnvelope = {
    data: FileClassificationCreateManyCategoryInput | FileClassificationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type RoleClassificationCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutClassificationInput
  }

  export type RoleClassificationUncheckedCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type RoleClassificationCreateOrConnectWithoutCategoryInput = {
    where: RoleClassificationWhereUniqueInput
    create: XOR<RoleClassificationCreateWithoutCategoryInput, RoleClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type RoleClassificationCreateManyCategoryInputEnvelope = {
    data: RoleClassificationCreateManyCategoryInput | RoleClassificationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SpaceClassificationCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    space: SpaceCreateNestedOneWithoutClassificationInput
  }

  export type SpaceClassificationUncheckedCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type SpaceClassificationCreateOrConnectWithoutCategoryInput = {
    where: SpaceClassificationWhereUniqueInput
    create: XOR<SpaceClassificationCreateWithoutCategoryInput, SpaceClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type SpaceClassificationCreateManyCategoryInputEnvelope = {
    data: SpaceClassificationCreateManyCategoryInput | SpaceClassificationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserClassificationCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    user: UserCreateNestedOneWithoutClassificationInput
  }

  export type UserClassificationUncheckedCreateWithoutCategoryInput = {
    id?: string
    seq?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type UserClassificationCreateOrConnectWithoutCategoryInput = {
    where: UserClassificationWhereUniqueInput
    create: XOR<UserClassificationCreateWithoutCategoryInput, UserClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type UserClassificationCreateManyCategoryInputEnvelope = {
    data: UserClassificationCreateManyCategoryInput | UserClassificationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    fileClassifications?: FileClassificationUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    fileClassifications?: FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    seq?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    name?: StringFilter<"Category"> | string
    type?: EnumCategoryTypesFilter<"Category"> | $Enums.CategoryTypes
    parentId?: StringNullableFilter<"Category"> | string | null
    tenantId?: StringFilter<"Category"> | string
  }

  export type TenantUpsertWithoutCategoriesInput = {
    update: XOR<TenantUpdateWithoutCategoriesInput, TenantUncheckedUpdateWithoutCategoriesInput>
    create: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCategoriesInput, TenantUncheckedUpdateWithoutCategoriesInput>
  }

  export type TenantUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type FileClassificationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: FileClassificationWhereUniqueInput
    update: XOR<FileClassificationUpdateWithoutCategoryInput, FileClassificationUncheckedUpdateWithoutCategoryInput>
    create: XOR<FileClassificationCreateWithoutCategoryInput, FileClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type FileClassificationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: FileClassificationWhereUniqueInput
    data: XOR<FileClassificationUpdateWithoutCategoryInput, FileClassificationUncheckedUpdateWithoutCategoryInput>
  }

  export type FileClassificationUpdateManyWithWhereWithoutCategoryInput = {
    where: FileClassificationScalarWhereInput
    data: XOR<FileClassificationUpdateManyMutationInput, FileClassificationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type FileClassificationScalarWhereInput = {
    AND?: FileClassificationScalarWhereInput | FileClassificationScalarWhereInput[]
    OR?: FileClassificationScalarWhereInput[]
    NOT?: FileClassificationScalarWhereInput | FileClassificationScalarWhereInput[]
    id?: StringFilter<"FileClassification"> | string
    seq?: IntFilter<"FileClassification"> | number
    categoryId?: StringFilter<"FileClassification"> | string
    fileId?: StringFilter<"FileClassification"> | string
    createdAt?: DateTimeFilter<"FileClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FileClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"FileClassification"> | Date | string | null
  }

  export type RoleClassificationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: RoleClassificationWhereUniqueInput
    update: XOR<RoleClassificationUpdateWithoutCategoryInput, RoleClassificationUncheckedUpdateWithoutCategoryInput>
    create: XOR<RoleClassificationCreateWithoutCategoryInput, RoleClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type RoleClassificationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: RoleClassificationWhereUniqueInput
    data: XOR<RoleClassificationUpdateWithoutCategoryInput, RoleClassificationUncheckedUpdateWithoutCategoryInput>
  }

  export type RoleClassificationUpdateManyWithWhereWithoutCategoryInput = {
    where: RoleClassificationScalarWhereInput
    data: XOR<RoleClassificationUpdateManyMutationInput, RoleClassificationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type RoleClassificationScalarWhereInput = {
    AND?: RoleClassificationScalarWhereInput | RoleClassificationScalarWhereInput[]
    OR?: RoleClassificationScalarWhereInput[]
    NOT?: RoleClassificationScalarWhereInput | RoleClassificationScalarWhereInput[]
    id?: StringFilter<"RoleClassification"> | string
    seq?: IntFilter<"RoleClassification"> | number
    categoryId?: StringFilter<"RoleClassification"> | string
    roleId?: StringFilter<"RoleClassification"> | string
    createdAt?: DateTimeFilter<"RoleClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RoleClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RoleClassification"> | Date | string | null
  }

  export type SpaceClassificationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SpaceClassificationWhereUniqueInput
    update: XOR<SpaceClassificationUpdateWithoutCategoryInput, SpaceClassificationUncheckedUpdateWithoutCategoryInput>
    create: XOR<SpaceClassificationCreateWithoutCategoryInput, SpaceClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type SpaceClassificationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SpaceClassificationWhereUniqueInput
    data: XOR<SpaceClassificationUpdateWithoutCategoryInput, SpaceClassificationUncheckedUpdateWithoutCategoryInput>
  }

  export type SpaceClassificationUpdateManyWithWhereWithoutCategoryInput = {
    where: SpaceClassificationScalarWhereInput
    data: XOR<SpaceClassificationUpdateManyMutationInput, SpaceClassificationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SpaceClassificationScalarWhereInput = {
    AND?: SpaceClassificationScalarWhereInput | SpaceClassificationScalarWhereInput[]
    OR?: SpaceClassificationScalarWhereInput[]
    NOT?: SpaceClassificationScalarWhereInput | SpaceClassificationScalarWhereInput[]
    id?: StringFilter<"SpaceClassification"> | string
    seq?: IntFilter<"SpaceClassification"> | number
    categoryId?: StringFilter<"SpaceClassification"> | string
    spaceId?: StringFilter<"SpaceClassification"> | string
    createdAt?: DateTimeFilter<"SpaceClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SpaceClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"SpaceClassification"> | Date | string | null
  }

  export type UserClassificationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: UserClassificationWhereUniqueInput
    update: XOR<UserClassificationUpdateWithoutCategoryInput, UserClassificationUncheckedUpdateWithoutCategoryInput>
    create: XOR<UserClassificationCreateWithoutCategoryInput, UserClassificationUncheckedCreateWithoutCategoryInput>
  }

  export type UserClassificationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: UserClassificationWhereUniqueInput
    data: XOR<UserClassificationUpdateWithoutCategoryInput, UserClassificationUncheckedUpdateWithoutCategoryInput>
  }

  export type UserClassificationUpdateManyWithWhereWithoutCategoryInput = {
    where: UserClassificationScalarWhereInput
    data: XOR<UserClassificationUpdateManyMutationInput, UserClassificationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserClassificationScalarWhereInput = {
    AND?: UserClassificationScalarWhereInput | UserClassificationScalarWhereInput[]
    OR?: UserClassificationScalarWhereInput[]
    NOT?: UserClassificationScalarWhereInput | UserClassificationScalarWhereInput[]
    id?: StringFilter<"UserClassification"> | string
    seq?: IntFilter<"UserClassification"> | number
    categoryId?: StringFilter<"UserClassification"> | string
    userId?: StringFilter<"UserClassification"> | string
    createdAt?: DateTimeFilter<"UserClassification"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserClassification"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"UserClassification"> | Date | string | null
  }

  export type TenantCreateWithoutGroupsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutGroupsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutGroupsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutGroupsInput, TenantUncheckedCreateWithoutGroupsInput>
  }

  export type FileAssociationCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    file: FileCreateNestedOneWithoutAssociationsInput
  }

  export type FileAssociationUncheckedCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    fileId: string
  }

  export type FileAssociationCreateOrConnectWithoutGroupInput = {
    where: FileAssociationWhereUniqueInput
    create: XOR<FileAssociationCreateWithoutGroupInput, FileAssociationUncheckedCreateWithoutGroupInput>
  }

  export type FileAssociationCreateManyGroupInputEnvelope = {
    data: FileAssociationCreateManyGroupInput | FileAssociationCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type RoleAssociationCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutAssociationsInput
  }

  export type RoleAssociationUncheckedCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
  }

  export type RoleAssociationCreateOrConnectWithoutGroupInput = {
    where: RoleAssociationWhereUniqueInput
    create: XOR<RoleAssociationCreateWithoutGroupInput, RoleAssociationUncheckedCreateWithoutGroupInput>
  }

  export type RoleAssociationCreateManyGroupInputEnvelope = {
    data: RoleAssociationCreateManyGroupInput | RoleAssociationCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type SpaceAssociationCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    space: SpaceCreateNestedOneWithoutAssociationsInput
  }

  export type SpaceAssociationUncheckedCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    spaceId: string
  }

  export type SpaceAssociationCreateOrConnectWithoutGroupInput = {
    where: SpaceAssociationWhereUniqueInput
    create: XOR<SpaceAssociationCreateWithoutGroupInput, SpaceAssociationUncheckedCreateWithoutGroupInput>
  }

  export type SpaceAssociationCreateManyGroupInputEnvelope = {
    data: SpaceAssociationCreateManyGroupInput | SpaceAssociationCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserAssociationCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAssociationsInput
  }

  export type UserAssociationUncheckedCreateWithoutGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
  }

  export type UserAssociationCreateOrConnectWithoutGroupInput = {
    where: UserAssociationWhereUniqueInput
    create: XOR<UserAssociationCreateWithoutGroupInput, UserAssociationUncheckedCreateWithoutGroupInput>
  }

  export type UserAssociationCreateManyGroupInputEnvelope = {
    data: UserAssociationCreateManyGroupInput | UserAssociationCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutGroupsInput = {
    update: XOR<TenantUpdateWithoutGroupsInput, TenantUncheckedUpdateWithoutGroupsInput>
    create: XOR<TenantCreateWithoutGroupsInput, TenantUncheckedCreateWithoutGroupsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutGroupsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutGroupsInput, TenantUncheckedUpdateWithoutGroupsInput>
  }

  export type TenantUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type FileAssociationUpsertWithWhereUniqueWithoutGroupInput = {
    where: FileAssociationWhereUniqueInput
    update: XOR<FileAssociationUpdateWithoutGroupInput, FileAssociationUncheckedUpdateWithoutGroupInput>
    create: XOR<FileAssociationCreateWithoutGroupInput, FileAssociationUncheckedCreateWithoutGroupInput>
  }

  export type FileAssociationUpdateWithWhereUniqueWithoutGroupInput = {
    where: FileAssociationWhereUniqueInput
    data: XOR<FileAssociationUpdateWithoutGroupInput, FileAssociationUncheckedUpdateWithoutGroupInput>
  }

  export type FileAssociationUpdateManyWithWhereWithoutGroupInput = {
    where: FileAssociationScalarWhereInput
    data: XOR<FileAssociationUpdateManyMutationInput, FileAssociationUncheckedUpdateManyWithoutGroupInput>
  }

  export type FileAssociationScalarWhereInput = {
    AND?: FileAssociationScalarWhereInput | FileAssociationScalarWhereInput[]
    OR?: FileAssociationScalarWhereInput[]
    NOT?: FileAssociationScalarWhereInput | FileAssociationScalarWhereInput[]
    id?: StringFilter<"FileAssociation"> | string
    seq?: IntFilter<"FileAssociation"> | number
    createdAt?: DateTimeFilter<"FileAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FileAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"FileAssociation"> | Date | string | null
    fileId?: StringFilter<"FileAssociation"> | string
    groupId?: StringFilter<"FileAssociation"> | string
  }

  export type RoleAssociationUpsertWithWhereUniqueWithoutGroupInput = {
    where: RoleAssociationWhereUniqueInput
    update: XOR<RoleAssociationUpdateWithoutGroupInput, RoleAssociationUncheckedUpdateWithoutGroupInput>
    create: XOR<RoleAssociationCreateWithoutGroupInput, RoleAssociationUncheckedCreateWithoutGroupInput>
  }

  export type RoleAssociationUpdateWithWhereUniqueWithoutGroupInput = {
    where: RoleAssociationWhereUniqueInput
    data: XOR<RoleAssociationUpdateWithoutGroupInput, RoleAssociationUncheckedUpdateWithoutGroupInput>
  }

  export type RoleAssociationUpdateManyWithWhereWithoutGroupInput = {
    where: RoleAssociationScalarWhereInput
    data: XOR<RoleAssociationUpdateManyMutationInput, RoleAssociationUncheckedUpdateManyWithoutGroupInput>
  }

  export type RoleAssociationScalarWhereInput = {
    AND?: RoleAssociationScalarWhereInput | RoleAssociationScalarWhereInput[]
    OR?: RoleAssociationScalarWhereInput[]
    NOT?: RoleAssociationScalarWhereInput | RoleAssociationScalarWhereInput[]
    id?: StringFilter<"RoleAssociation"> | string
    seq?: IntFilter<"RoleAssociation"> | number
    createdAt?: DateTimeFilter<"RoleAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RoleAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RoleAssociation"> | Date | string | null
    roleId?: StringFilter<"RoleAssociation"> | string
    groupId?: StringFilter<"RoleAssociation"> | string
  }

  export type SpaceAssociationUpsertWithWhereUniqueWithoutGroupInput = {
    where: SpaceAssociationWhereUniqueInput
    update: XOR<SpaceAssociationUpdateWithoutGroupInput, SpaceAssociationUncheckedUpdateWithoutGroupInput>
    create: XOR<SpaceAssociationCreateWithoutGroupInput, SpaceAssociationUncheckedCreateWithoutGroupInput>
  }

  export type SpaceAssociationUpdateWithWhereUniqueWithoutGroupInput = {
    where: SpaceAssociationWhereUniqueInput
    data: XOR<SpaceAssociationUpdateWithoutGroupInput, SpaceAssociationUncheckedUpdateWithoutGroupInput>
  }

  export type SpaceAssociationUpdateManyWithWhereWithoutGroupInput = {
    where: SpaceAssociationScalarWhereInput
    data: XOR<SpaceAssociationUpdateManyMutationInput, SpaceAssociationUncheckedUpdateManyWithoutGroupInput>
  }

  export type SpaceAssociationScalarWhereInput = {
    AND?: SpaceAssociationScalarWhereInput | SpaceAssociationScalarWhereInput[]
    OR?: SpaceAssociationScalarWhereInput[]
    NOT?: SpaceAssociationScalarWhereInput | SpaceAssociationScalarWhereInput[]
    id?: StringFilter<"SpaceAssociation"> | string
    seq?: IntFilter<"SpaceAssociation"> | number
    createdAt?: DateTimeFilter<"SpaceAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SpaceAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"SpaceAssociation"> | Date | string | null
    spaceId?: StringFilter<"SpaceAssociation"> | string
    groupId?: StringFilter<"SpaceAssociation"> | string
  }

  export type UserAssociationUpsertWithWhereUniqueWithoutGroupInput = {
    where: UserAssociationWhereUniqueInput
    update: XOR<UserAssociationUpdateWithoutGroupInput, UserAssociationUncheckedUpdateWithoutGroupInput>
    create: XOR<UserAssociationCreateWithoutGroupInput, UserAssociationUncheckedCreateWithoutGroupInput>
  }

  export type UserAssociationUpdateWithWhereUniqueWithoutGroupInput = {
    where: UserAssociationWhereUniqueInput
    data: XOR<UserAssociationUpdateWithoutGroupInput, UserAssociationUncheckedUpdateWithoutGroupInput>
  }

  export type UserAssociationUpdateManyWithWhereWithoutGroupInput = {
    where: UserAssociationScalarWhereInput
    data: XOR<UserAssociationUpdateManyMutationInput, UserAssociationUncheckedUpdateManyWithoutGroupInput>
  }

  export type UserAssociationScalarWhereInput = {
    AND?: UserAssociationScalarWhereInput | UserAssociationScalarWhereInput[]
    OR?: UserAssociationScalarWhereInput[]
    NOT?: UserAssociationScalarWhereInput | UserAssociationScalarWhereInput[]
    id?: StringFilter<"UserAssociation"> | string
    seq?: IntFilter<"UserAssociation"> | number
    createdAt?: DateTimeFilter<"UserAssociation"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserAssociation"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"UserAssociation"> | Date | string | null
    userId?: StringFilter<"UserAssociation"> | string
    groupId?: StringFilter<"UserAssociation"> | string
  }

  export type TaskCreateWithoutExerciseInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
  }

  export type TaskUncheckedCreateWithoutExerciseInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
  }

  export type TaskCreateOrConnectWithoutExerciseInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutExerciseInput, TaskUncheckedCreateWithoutExerciseInput>
  }

  export type TaskUpsertWithoutExerciseInput = {
    update: XOR<TaskUpdateWithoutExerciseInput, TaskUncheckedUpdateWithoutExerciseInput>
    create: XOR<TaskCreateWithoutExerciseInput, TaskUncheckedCreateWithoutExerciseInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutExerciseInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutExerciseInput, TaskUncheckedUpdateWithoutExerciseInput>
  }

  export type TaskUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    role: RoleCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
  }

  export type AssignmentCreateOrConnectWithoutTenantInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutTenantInput, AssignmentUncheckedCreateWithoutTenantInput>
  }

  export type AssignmentCreateManyTenantInputEnvelope = {
    data: AssignmentCreateManyTenantInput | AssignmentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    fileClassifications?: FileClassificationCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    fileClassifications?: FileClassificationUncheckedCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput>
  }

  export type CategoryCreateManyTenantInputEnvelope = {
    data: CategoryCreateManyTenantInput | CategoryCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ContentCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
    posts?: PostCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutTenantInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutTenantInput, ContentUncheckedCreateWithoutTenantInput>
  }

  export type ContentCreateManyTenantInputEnvelope = {
    data: ContentCreateManyTenantInput | ContentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutTenantInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    parent?: FileCreateNestedOneWithoutChildrenInput
    children?: FileCreateNestedManyWithoutParentInput
    associations?: FileAssociationCreateNestedManyWithoutFileInput
    classification?: FileClassificationCreateNestedOneWithoutFileInput
  }

  export type FileUncheckedCreateWithoutTenantInput = {
    id?: string
    seq?: number
    name: string
    size: number
    parentId?: string | null
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    children?: FileUncheckedCreateNestedManyWithoutParentInput
    associations?: FileAssociationUncheckedCreateNestedManyWithoutFileInput
    classification?: FileClassificationUncheckedCreateNestedOneWithoutFileInput
  }

  export type FileCreateOrConnectWithoutTenantInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput>
  }

  export type FileCreateManyTenantInputEnvelope = {
    data: FileCreateManyTenantInput | FileCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    fileAssociations?: FileAssociationCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    fileAssociations?: FileAssociationUncheckedCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationUncheckedCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationUncheckedCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutTenantInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutTenantInput, GroupUncheckedCreateWithoutTenantInput>
  }

  export type GroupCreateManyTenantInputEnvelope = {
    data: GroupCreateManyTenantInput | GroupCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutTenantsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityCreateNestedManyWithoutRoleInput
    assignments?: AssignmentCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationCreateNestedOneWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutTenantsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityUncheckedCreateNestedManyWithoutRoleInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationUncheckedCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationUncheckedCreateNestedOneWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutTenantsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutTenantsInput, RoleUncheckedCreateWithoutTenantsInput>
  }

  export type SpaceCreateWithoutTenantsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundCreateNestedOneWithoutSpaceInput
    associations?: SpaceAssociationCreateNestedManyWithoutSpaceInput
    classification?: SpaceClassificationCreateNestedOneWithoutSpaceInput
  }

  export type SpaceUncheckedCreateWithoutTenantsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundUncheckedCreateNestedOneWithoutSpaceInput
    associations?: SpaceAssociationUncheckedCreateNestedManyWithoutSpaceInput
    classification?: SpaceClassificationUncheckedCreateNestedOneWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutTenantsInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutTenantsInput, SpaceUncheckedCreateWithoutTenantsInput>
  }

  export type UserCreateWithoutTenantsInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileCreateNestedManyWithoutUserInput
    classification?: UserClassificationCreateNestedOneWithoutUserInput
    associations?: UserAssociationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantsInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileUncheckedCreateNestedManyWithoutUserInput
    classification?: UserClassificationUncheckedCreateNestedOneWithoutUserInput
    associations?: UserAssociationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
  }

  export type TimelineCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutTimelineInput
  }

  export type TimelineUncheckedCreateWithoutTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutTimelineInput
  }

  export type TimelineCreateOrConnectWithoutTenantInput = {
    where: TimelineWhereUniqueInput
    create: XOR<TimelineCreateWithoutTenantInput, TimelineUncheckedCreateWithoutTenantInput>
  }

  export type TimelineCreateManyTenantInputEnvelope = {
    data: TimelineCreateManyTenantInput | TimelineCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutTenantInput, AssignmentUncheckedUpdateWithoutTenantInput>
    create: XOR<AssignmentCreateWithoutTenantInput, AssignmentUncheckedCreateWithoutTenantInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutTenantInput, AssignmentUncheckedUpdateWithoutTenantInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutTenantInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: StringFilter<"Assignment"> | string
    seq?: IntFilter<"Assignment"> | number
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    roleId?: StringFilter<"Assignment"> | string
    tenantId?: StringFilter<"Assignment"> | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutTenantInput, CategoryUncheckedUpdateWithoutTenantInput>
    create: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutTenantInput, CategoryUncheckedUpdateWithoutTenantInput>
  }

  export type CategoryUpdateManyWithWhereWithoutTenantInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutTenantInput>
  }

  export type ContentUpsertWithWhereUniqueWithoutTenantInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutTenantInput, ContentUncheckedUpdateWithoutTenantInput>
    create: XOR<ContentCreateWithoutTenantInput, ContentUncheckedCreateWithoutTenantInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutTenantInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutTenantInput, ContentUncheckedUpdateWithoutTenantInput>
  }

  export type ContentUpdateManyWithWhereWithoutTenantInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutTenantInput>
  }

  export type ContentScalarWhereInput = {
    AND?: ContentScalarWhereInput | ContentScalarWhereInput[]
    OR?: ContentScalarWhereInput[]
    NOT?: ContentScalarWhereInput | ContentScalarWhereInput[]
    id?: StringFilter<"Content"> | string
    seq?: IntFilter<"Content"> | number
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    title?: StringNullableFilter<"Content"> | string | null
    description?: StringNullableFilter<"Content"> | string | null
    type?: EnumTextTypesFilter<"Content"> | $Enums.TextTypes
    text?: StringNullableFilter<"Content"> | string | null
    fileId?: StringNullableFilter<"Content"> | string | null
    tenantId?: StringFilter<"Content"> | string
  }

  export type FileUpsertWithWhereUniqueWithoutTenantInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutTenantInput, FileUncheckedUpdateWithoutTenantInput>
    create: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput>
  }

  export type FileUpdateWithWhereUniqueWithoutTenantInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutTenantInput, FileUncheckedUpdateWithoutTenantInput>
  }

  export type FileUpdateManyWithWhereWithoutTenantInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutTenantInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    seq?: IntFilter<"File"> | number
    name?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    parentId?: StringNullableFilter<"File"> | string | null
    mimeType?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    tenantId?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"File"> | Date | string | null
  }

  export type GroupUpsertWithWhereUniqueWithoutTenantInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutTenantInput, GroupUncheckedUpdateWithoutTenantInput>
    create: XOR<GroupCreateWithoutTenantInput, GroupUncheckedCreateWithoutTenantInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutTenantInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutTenantInput, GroupUncheckedUpdateWithoutTenantInput>
  }

  export type GroupUpdateManyWithWhereWithoutTenantInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutTenantInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    seq?: IntFilter<"Group"> | number
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Group"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Group"> | Date | string | null
    name?: StringFilter<"Group"> | string
    type?: EnumGroupTypesFilter<"Group"> | $Enums.GroupTypes
    label?: StringNullableFilter<"Group"> | string | null
    tenantId?: StringFilter<"Group"> | string
  }

  export type RoleUpsertWithoutTenantsInput = {
    update: XOR<RoleUpdateWithoutTenantsInput, RoleUncheckedUpdateWithoutTenantsInput>
    create: XOR<RoleCreateWithoutTenantsInput, RoleUncheckedCreateWithoutTenantsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutTenantsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutTenantsInput, RoleUncheckedUpdateWithoutTenantsInput>
  }

  export type RoleUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUpdateOneWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUncheckedUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUncheckedUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUncheckedUpdateOneWithoutRoleNestedInput
  }

  export type SpaceUpsertWithoutTenantsInput = {
    update: XOR<SpaceUpdateWithoutTenantsInput, SpaceUncheckedUpdateWithoutTenantsInput>
    create: XOR<SpaceCreateWithoutTenantsInput, SpaceUncheckedCreateWithoutTenantsInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutTenantsInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutTenantsInput, SpaceUncheckedUpdateWithoutTenantsInput>
  }

  export type SpaceUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUpdateOneWithoutSpaceNestedInput
    associations?: SpaceAssociationUpdateManyWithoutSpaceNestedInput
    classification?: SpaceClassificationUpdateOneWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUncheckedUpdateOneWithoutSpaceNestedInput
    associations?: SpaceAssociationUncheckedUpdateManyWithoutSpaceNestedInput
    classification?: SpaceClassificationUncheckedUpdateOneWithoutSpaceNestedInput
  }

  export type UserUpsertWithoutTenantsInput = {
    update: XOR<UserUpdateWithoutTenantsInput, UserUncheckedUpdateWithoutTenantsInput>
    create: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTenantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTenantsInput, UserUncheckedUpdateWithoutTenantsInput>
  }

  export type UserUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUpdateOneWithoutUserNestedInput
    associations?: UserAssociationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUncheckedUpdateOneWithoutUserNestedInput
    associations?: UserAssociationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TimelineUpsertWithWhereUniqueWithoutTenantInput = {
    where: TimelineWhereUniqueInput
    update: XOR<TimelineUpdateWithoutTenantInput, TimelineUncheckedUpdateWithoutTenantInput>
    create: XOR<TimelineCreateWithoutTenantInput, TimelineUncheckedCreateWithoutTenantInput>
  }

  export type TimelineUpdateWithWhereUniqueWithoutTenantInput = {
    where: TimelineWhereUniqueInput
    data: XOR<TimelineUpdateWithoutTenantInput, TimelineUncheckedUpdateWithoutTenantInput>
  }

  export type TimelineUpdateManyWithWhereWithoutTenantInput = {
    where: TimelineScalarWhereInput
    data: XOR<TimelineUpdateManyMutationInput, TimelineUncheckedUpdateManyWithoutTenantInput>
  }

  export type TimelineScalarWhereInput = {
    AND?: TimelineScalarWhereInput | TimelineScalarWhereInput[]
    OR?: TimelineScalarWhereInput[]
    NOT?: TimelineScalarWhereInput | TimelineScalarWhereInput[]
    id?: StringFilter<"Timeline"> | string
    seq?: IntFilter<"Timeline"> | number
    createdAt?: DateTimeFilter<"Timeline"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Timeline"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Timeline"> | Date | string | null
    tenantId?: StringFilter<"Timeline"> | string
  }

  export type SessionCreateWithoutTimelineInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    label: string
    name: string
    program?: ProgramCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutTimelineInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    label: string
    name: string
    program?: ProgramUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutTimelineInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutTimelineInput, SessionUncheckedCreateWithoutTimelineInput>
  }

  export type SessionCreateManyTimelineInputEnvelope = {
    data: SessionCreateManyTimelineInput | SessionCreateManyTimelineInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutTimelinesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
  }

  export type TenantUncheckedCreateWithoutTimelinesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTimelinesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTimelinesInput, TenantUncheckedCreateWithoutTimelinesInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutTimelineInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutTimelineInput, SessionUncheckedUpdateWithoutTimelineInput>
    create: XOR<SessionCreateWithoutTimelineInput, SessionUncheckedCreateWithoutTimelineInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutTimelineInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutTimelineInput, SessionUncheckedUpdateWithoutTimelineInput>
  }

  export type SessionUpdateManyWithWhereWithoutTimelineInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutTimelineInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    seq?: IntFilter<"Session"> | number
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    type?: EnumSessionTypesFilter<"Session"> | $Enums.SessionTypes
    repeatCycleType?: EnumRepeatCycleTypesNullableFilter<"Session"> | $Enums.RepeatCycleTypes | null
    startDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    endDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    recurringDayOfWeek?: EnumRecurringDayOfWeekNullableFilter<"Session"> | $Enums.RecurringDayOfWeek | null
    recurringMonth?: IntNullableFilter<"Session"> | number | null
    timelineId?: StringFilter<"Session"> | string
    label?: StringFilter<"Session"> | string
    name?: StringFilter<"Session"> | string
  }

  export type TenantUpsertWithoutTimelinesInput = {
    update: XOR<TenantUpdateWithoutTimelinesInput, TenantUncheckedUpdateWithoutTimelinesInput>
    create: XOR<TenantCreateWithoutTimelinesInput, TenantUncheckedCreateWithoutTimelinesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTimelinesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTimelinesInput, TenantUncheckedUpdateWithoutTimelinesInput>
  }

  export type TenantUpdateWithoutTimelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
  }

  export type TenantUncheckedUpdateWithoutTimelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProgramCreateWithoutSessionInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    instructorId: string
    capacity: number
    routine: RoutineCreateNestedOneWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutSessionInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    routineId: string
    instructorId: string
    capacity: number
  }

  export type ProgramCreateOrConnectWithoutSessionInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutSessionInput, ProgramUncheckedCreateWithoutSessionInput>
  }

  export type TimelineCreateWithoutSessionsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutTimelinesInput
  }

  export type TimelineUncheckedCreateWithoutSessionsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
  }

  export type TimelineCreateOrConnectWithoutSessionsInput = {
    where: TimelineWhereUniqueInput
    create: XOR<TimelineCreateWithoutSessionsInput, TimelineUncheckedCreateWithoutSessionsInput>
  }

  export type ProgramUpsertWithoutSessionInput = {
    update: XOR<ProgramUpdateWithoutSessionInput, ProgramUncheckedUpdateWithoutSessionInput>
    create: XOR<ProgramCreateWithoutSessionInput, ProgramUncheckedCreateWithoutSessionInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutSessionInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutSessionInput, ProgramUncheckedUpdateWithoutSessionInput>
  }

  export type ProgramUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    routine?: RoutineUpdateOneRequiredWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    routineId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type TimelineUpsertWithoutSessionsInput = {
    update: XOR<TimelineUpdateWithoutSessionsInput, TimelineUncheckedUpdateWithoutSessionsInput>
    create: XOR<TimelineCreateWithoutSessionsInput, TimelineUncheckedCreateWithoutSessionsInput>
    where?: TimelineWhereInput
  }

  export type TimelineUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TimelineWhereInput
    data: XOR<TimelineUpdateWithoutSessionsInput, TimelineUncheckedUpdateWithoutSessionsInput>
  }

  export type TimelineUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutTimelinesNestedInput
  }

  export type TimelineUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type RoutineCreateWithoutProgramInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label: string
  }

  export type RoutineUncheckedCreateWithoutProgramInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label: string
  }

  export type RoutineCreateOrConnectWithoutProgramInput = {
    where: RoutineWhereUniqueInput
    create: XOR<RoutineCreateWithoutProgramInput, RoutineUncheckedCreateWithoutProgramInput>
  }

  export type SessionCreateWithoutProgramInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    label: string
    name: string
    timeline: TimelineCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutProgramInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    timelineId: string
    label: string
    name: string
  }

  export type SessionCreateOrConnectWithoutProgramInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
  }

  export type RoutineUpsertWithoutProgramInput = {
    update: XOR<RoutineUpdateWithoutProgramInput, RoutineUncheckedUpdateWithoutProgramInput>
    create: XOR<RoutineCreateWithoutProgramInput, RoutineUncheckedCreateWithoutProgramInput>
    where?: RoutineWhereInput
  }

  export type RoutineUpdateToOneWithWhereWithoutProgramInput = {
    where?: RoutineWhereInput
    data: XOR<RoutineUpdateWithoutProgramInput, RoutineUncheckedUpdateWithoutProgramInput>
  }

  export type RoutineUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type RoutineUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUpsertWithoutProgramInput = {
    update: XOR<SessionUpdateWithoutProgramInput, SessionUncheckedUpdateWithoutProgramInput>
    create: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutProgramInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutProgramInput, SessionUncheckedUpdateWithoutProgramInput>
  }

  export type SessionUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timeline?: TimelineUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    timelineId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramCreateWithoutRoutineInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    instructorId: string
    capacity: number
    session: SessionCreateNestedOneWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutRoutineInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    sessionId: string
    instructorId: string
    capacity: number
  }

  export type ProgramCreateOrConnectWithoutRoutineInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutRoutineInput, ProgramUncheckedCreateWithoutRoutineInput>
  }

  export type ProgramUpsertWithoutRoutineInput = {
    update: XOR<ProgramUpdateWithoutRoutineInput, ProgramUncheckedUpdateWithoutRoutineInput>
    create: XOR<ProgramCreateWithoutRoutineInput, ProgramUncheckedCreateWithoutRoutineInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutRoutineInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutRoutineInput, ProgramUncheckedUpdateWithoutRoutineInput>
  }

  export type ProgramUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    session?: SessionUpdateOneRequiredWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type ExerciseCreateWithoutTaskInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    duration: number
    count: number
    description?: string | null
    imageFileId?: string | null
    videoFileId?: string | null
    name: string
  }

  export type ExerciseUncheckedCreateWithoutTaskInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    duration: number
    count: number
    description?: string | null
    imageFileId?: string | null
    videoFileId?: string | null
    name: string
  }

  export type ExerciseCreateOrConnectWithoutTaskInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutTaskInput, ExerciseUncheckedCreateWithoutTaskInput>
  }

  export type ExerciseUpsertWithoutTaskInput = {
    update: XOR<ExerciseUpdateWithoutTaskInput, ExerciseUncheckedUpdateWithoutTaskInput>
    create: XOR<ExerciseCreateWithoutTaskInput, ExerciseUncheckedCreateWithoutTaskInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutTaskInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutTaskInput, ExerciseUncheckedUpdateWithoutTaskInput>
  }

  export type ExerciseUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoFileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoFileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateWithoutAssignmentsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationCreateNestedOneWithoutRoleInput
    tenants?: TenantCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityUncheckedCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationUncheckedCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationUncheckedCreateNestedOneWithoutRoleInput
    tenants?: TenantUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutAssignmentsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutAssignmentsInput, RoleUncheckedCreateWithoutAssignmentsInput>
  }

  export type TenantCreateWithoutAssignmentsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAssignmentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAssignmentsInput, TenantUncheckedCreateWithoutAssignmentsInput>
  }

  export type RoleUpsertWithoutAssignmentsInput = {
    update: XOR<RoleUpdateWithoutAssignmentsInput, RoleUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<RoleCreateWithoutAssignmentsInput, RoleUncheckedCreateWithoutAssignmentsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutAssignmentsInput, RoleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type RoleUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUpdateOneWithoutRoleNestedInput
    tenants?: TenantUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUncheckedUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUncheckedUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUncheckedUpdateOneWithoutRoleNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type TenantUpsertWithoutAssignmentsInput = {
    update: XOR<TenantUpdateWithoutAssignmentsInput, TenantUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<TenantCreateWithoutAssignmentsInput, TenantUncheckedCreateWithoutAssignmentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAssignmentsInput, TenantUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TenantUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RoleCreateWithoutAbilitiesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    assignments?: AssignmentCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationCreateNestedOneWithoutRoleInput
    tenants?: TenantCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutAbilitiesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    assignments?: AssignmentUncheckedCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationUncheckedCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationUncheckedCreateNestedOneWithoutRoleInput
    tenants?: TenantUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutAbilitiesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutAbilitiesInput, RoleUncheckedCreateWithoutAbilitiesInput>
  }

  export type RoleUpsertWithoutAbilitiesInput = {
    update: XOR<RoleUpdateWithoutAbilitiesInput, RoleUncheckedUpdateWithoutAbilitiesInput>
    create: XOR<RoleCreateWithoutAbilitiesInput, RoleUncheckedCreateWithoutAbilitiesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutAbilitiesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutAbilitiesInput, RoleUncheckedUpdateWithoutAbilitiesInput>
  }

  export type RoleUpdateWithoutAbilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    assignments?: AssignmentUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUpdateOneWithoutRoleNestedInput
    tenants?: TenantUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutAbilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    assignments?: AssignmentUncheckedUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUncheckedUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUncheckedUpdateOneWithoutRoleNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ContentCreateWithoutPostsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
    tenant: TenantCreateNestedOneWithoutContentsInput
  }

  export type ContentUncheckedCreateWithoutPostsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
    tenantId: string
  }

  export type ContentCreateOrConnectWithoutPostsInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutPostsInput, ContentUncheckedCreateWithoutPostsInput>
  }

  export type ContentUpsertWithoutPostsInput = {
    update: XOR<ContentUpdateWithoutPostsInput, ContentUncheckedUpdateWithoutPostsInput>
    create: XOR<ContentCreateWithoutPostsInput, ContentUncheckedCreateWithoutPostsInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutPostsInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutPostsInput, ContentUncheckedUpdateWithoutPostsInput>
  }

  export type ContentUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutContentsNestedInput
  }

  export type ContentUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantCreateWithoutContentsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutContentsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutContentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutContentsInput, TenantUncheckedCreateWithoutContentsInput>
  }

  export type PostCreateWithoutContentInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type PostUncheckedCreateWithoutContentInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type PostCreateOrConnectWithoutContentInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutContentInput, PostUncheckedCreateWithoutContentInput>
  }

  export type PostCreateManyContentInputEnvelope = {
    data: PostCreateManyContentInput | PostCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutContentsInput = {
    update: XOR<TenantUpdateWithoutContentsInput, TenantUncheckedUpdateWithoutContentsInput>
    create: XOR<TenantCreateWithoutContentsInput, TenantUncheckedCreateWithoutContentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutContentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutContentsInput, TenantUncheckedUpdateWithoutContentsInput>
  }

  export type TenantUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutContentInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutContentInput, PostUncheckedUpdateWithoutContentInput>
    create: XOR<PostCreateWithoutContentInput, PostUncheckedCreateWithoutContentInput>
  }

  export type PostUpdateWithWhereUniqueWithoutContentInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutContentInput, PostUncheckedUpdateWithoutContentInput>
  }

  export type PostUpdateManyWithWhereWithoutContentInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutContentInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    seq?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    contentId?: StringFilter<"Post"> | string
  }

  export type FileCreateWithoutChildrenInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    parent?: FileCreateNestedOneWithoutChildrenInput
    tenant: TenantCreateNestedOneWithoutFilesInput
    associations?: FileAssociationCreateNestedManyWithoutFileInput
    classification?: FileClassificationCreateNestedOneWithoutFileInput
  }

  export type FileUncheckedCreateWithoutChildrenInput = {
    id?: string
    seq?: number
    name: string
    size: number
    parentId?: string | null
    mimeType: string
    url: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    associations?: FileAssociationUncheckedCreateNestedManyWithoutFileInput
    classification?: FileClassificationUncheckedCreateNestedOneWithoutFileInput
  }

  export type FileCreateOrConnectWithoutChildrenInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutChildrenInput, FileUncheckedCreateWithoutChildrenInput>
  }

  export type FileCreateWithoutParentInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    children?: FileCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutFilesInput
    associations?: FileAssociationCreateNestedManyWithoutFileInput
    classification?: FileClassificationCreateNestedOneWithoutFileInput
  }

  export type FileUncheckedCreateWithoutParentInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    children?: FileUncheckedCreateNestedManyWithoutParentInput
    associations?: FileAssociationUncheckedCreateNestedManyWithoutFileInput
    classification?: FileClassificationUncheckedCreateNestedOneWithoutFileInput
  }

  export type FileCreateOrConnectWithoutParentInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutParentInput, FileUncheckedCreateWithoutParentInput>
  }

  export type FileCreateManyParentInputEnvelope = {
    data: FileCreateManyParentInput | FileCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutFilesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutFilesInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutFilesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
  }

  export type FileAssociationCreateWithoutFileInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutFileAssociationsInput
  }

  export type FileAssociationUncheckedCreateWithoutFileInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type FileAssociationCreateOrConnectWithoutFileInput = {
    where: FileAssociationWhereUniqueInput
    create: XOR<FileAssociationCreateWithoutFileInput, FileAssociationUncheckedCreateWithoutFileInput>
  }

  export type FileAssociationCreateManyFileInputEnvelope = {
    data: FileAssociationCreateManyFileInput | FileAssociationCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type FileClassificationCreateWithoutFileInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutFileClassificationsInput
  }

  export type FileClassificationUncheckedCreateWithoutFileInput = {
    id?: string
    seq?: number
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type FileClassificationCreateOrConnectWithoutFileInput = {
    where: FileClassificationWhereUniqueInput
    create: XOR<FileClassificationCreateWithoutFileInput, FileClassificationUncheckedCreateWithoutFileInput>
  }

  export type FileUpsertWithoutChildrenInput = {
    update: XOR<FileUpdateWithoutChildrenInput, FileUncheckedUpdateWithoutChildrenInput>
    create: XOR<FileCreateWithoutChildrenInput, FileUncheckedCreateWithoutChildrenInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutChildrenInput, FileUncheckedUpdateWithoutChildrenInput>
  }

  export type FileUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: FileUpdateOneWithoutChildrenNestedInput
    tenant?: TenantUpdateOneRequiredWithoutFilesNestedInput
    associations?: FileAssociationUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUpdateOneWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    associations?: FileAssociationUncheckedUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUncheckedUpdateOneWithoutFileNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutParentInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutParentInput, FileUncheckedUpdateWithoutParentInput>
    create: XOR<FileCreateWithoutParentInput, FileUncheckedCreateWithoutParentInput>
  }

  export type FileUpdateWithWhereUniqueWithoutParentInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutParentInput, FileUncheckedUpdateWithoutParentInput>
  }

  export type FileUpdateManyWithWhereWithoutParentInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutParentInput>
  }

  export type TenantUpsertWithoutFilesInput = {
    update: XOR<TenantUpdateWithoutFilesInput, TenantUncheckedUpdateWithoutFilesInput>
    create: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutFilesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutFilesInput, TenantUncheckedUpdateWithoutFilesInput>
  }

  export type TenantUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type FileAssociationUpsertWithWhereUniqueWithoutFileInput = {
    where: FileAssociationWhereUniqueInput
    update: XOR<FileAssociationUpdateWithoutFileInput, FileAssociationUncheckedUpdateWithoutFileInput>
    create: XOR<FileAssociationCreateWithoutFileInput, FileAssociationUncheckedCreateWithoutFileInput>
  }

  export type FileAssociationUpdateWithWhereUniqueWithoutFileInput = {
    where: FileAssociationWhereUniqueInput
    data: XOR<FileAssociationUpdateWithoutFileInput, FileAssociationUncheckedUpdateWithoutFileInput>
  }

  export type FileAssociationUpdateManyWithWhereWithoutFileInput = {
    where: FileAssociationScalarWhereInput
    data: XOR<FileAssociationUpdateManyMutationInput, FileAssociationUncheckedUpdateManyWithoutFileInput>
  }

  export type FileClassificationUpsertWithoutFileInput = {
    update: XOR<FileClassificationUpdateWithoutFileInput, FileClassificationUncheckedUpdateWithoutFileInput>
    create: XOR<FileClassificationCreateWithoutFileInput, FileClassificationUncheckedCreateWithoutFileInput>
    where?: FileClassificationWhereInput
  }

  export type FileClassificationUpdateToOneWithWhereWithoutFileInput = {
    where?: FileClassificationWhereInput
    data: XOR<FileClassificationUpdateWithoutFileInput, FileClassificationUncheckedUpdateWithoutFileInput>
  }

  export type FileClassificationUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutFileClassificationsNestedInput
  }

  export type FileClassificationUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateWithoutFileClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    roleClassifications?: RoleClassificationCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutFileClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    tenantId: string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    roleClassifications?: RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutFileClassificationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutFileClassificationsInput, CategoryUncheckedCreateWithoutFileClassificationsInput>
  }

  export type FileCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    parent?: FileCreateNestedOneWithoutChildrenInput
    children?: FileCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutFilesInput
    associations?: FileAssociationCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    name: string
    size: number
    parentId?: string | null
    mimeType: string
    url: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    children?: FileUncheckedCreateNestedManyWithoutParentInput
    associations?: FileAssociationUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutClassificationInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutClassificationInput, FileUncheckedCreateWithoutClassificationInput>
  }

  export type CategoryUpsertWithoutFileClassificationsInput = {
    update: XOR<CategoryUpdateWithoutFileClassificationsInput, CategoryUncheckedUpdateWithoutFileClassificationsInput>
    create: XOR<CategoryCreateWithoutFileClassificationsInput, CategoryUncheckedCreateWithoutFileClassificationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutFileClassificationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutFileClassificationsInput, CategoryUncheckedUpdateWithoutFileClassificationsInput>
  }

  export type CategoryUpdateWithoutFileClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    roleClassifications?: RoleClassificationUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutFileClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    roleClassifications?: RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type FileUpsertWithoutClassificationInput = {
    update: XOR<FileUpdateWithoutClassificationInput, FileUncheckedUpdateWithoutClassificationInput>
    create: XOR<FileCreateWithoutClassificationInput, FileUncheckedCreateWithoutClassificationInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutClassificationInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutClassificationInput, FileUncheckedUpdateWithoutClassificationInput>
  }

  export type FileUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: FileUpdateOneWithoutChildrenNestedInput
    children?: FileUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutFilesNestedInput
    associations?: FileAssociationUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: FileUncheckedUpdateManyWithoutParentNestedInput
    associations?: FileAssociationUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    parent?: FileCreateNestedOneWithoutChildrenInput
    children?: FileCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutFilesInput
    classification?: FileClassificationCreateNestedOneWithoutFileInput
  }

  export type FileUncheckedCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    name: string
    size: number
    parentId?: string | null
    mimeType: string
    url: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    children?: FileUncheckedCreateNestedManyWithoutParentInput
    classification?: FileClassificationUncheckedCreateNestedOneWithoutFileInput
  }

  export type FileCreateOrConnectWithoutAssociationsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutAssociationsInput, FileUncheckedCreateWithoutAssociationsInput>
  }

  export type GroupCreateWithoutFileAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenant: TenantCreateNestedOneWithoutGroupsInput
    roleAssociations?: RoleAssociationCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutFileAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenantId: string
    roleAssociations?: RoleAssociationUncheckedCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationUncheckedCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutFileAssociationsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutFileAssociationsInput, GroupUncheckedCreateWithoutFileAssociationsInput>
  }

  export type FileUpsertWithoutAssociationsInput = {
    update: XOR<FileUpdateWithoutAssociationsInput, FileUncheckedUpdateWithoutAssociationsInput>
    create: XOR<FileCreateWithoutAssociationsInput, FileUncheckedCreateWithoutAssociationsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutAssociationsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutAssociationsInput, FileUncheckedUpdateWithoutAssociationsInput>
  }

  export type FileUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: FileUpdateOneWithoutChildrenNestedInput
    children?: FileUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutFilesNestedInput
    classification?: FileClassificationUpdateOneWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: FileUncheckedUpdateManyWithoutParentNestedInput
    classification?: FileClassificationUncheckedUpdateOneWithoutFileNestedInput
  }

  export type GroupUpsertWithoutFileAssociationsInput = {
    update: XOR<GroupUpdateWithoutFileAssociationsInput, GroupUncheckedUpdateWithoutFileAssociationsInput>
    create: XOR<GroupCreateWithoutFileAssociationsInput, GroupUncheckedCreateWithoutFileAssociationsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutFileAssociationsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutFileAssociationsInput, GroupUncheckedUpdateWithoutFileAssociationsInput>
  }

  export type GroupUpdateWithoutFileAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutGroupsNestedInput
    roleAssociations?: RoleAssociationUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutFileAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    roleAssociations?: RoleAssociationUncheckedUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUncheckedUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type AbilityCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type: $Enums.AbilityTypes
    description?: string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId: string
    tenantId: string
  }

  export type AbilityUncheckedCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type: $Enums.AbilityTypes
    description?: string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId: string
    tenantId: string
  }

  export type AbilityCreateOrConnectWithoutRoleInput = {
    where: AbilityWhereUniqueInput
    create: XOR<AbilityCreateWithoutRoleInput, AbilityUncheckedCreateWithoutRoleInput>
  }

  export type AbilityCreateManyRoleInputEnvelope = {
    data: AbilityCreateManyRoleInput | AbilityCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
  }

  export type AssignmentCreateOrConnectWithoutRoleInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutRoleInput, AssignmentUncheckedCreateWithoutRoleInput>
  }

  export type AssignmentCreateManyRoleInputEnvelope = {
    data: AssignmentCreateManyRoleInput | AssignmentCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RoleAssociationCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutRoleAssociationsInput
  }

  export type RoleAssociationUncheckedCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type RoleAssociationCreateOrConnectWithoutRoleInput = {
    where: RoleAssociationWhereUniqueInput
    create: XOR<RoleAssociationCreateWithoutRoleInput, RoleAssociationUncheckedCreateWithoutRoleInput>
  }

  export type RoleAssociationCreateManyRoleInputEnvelope = {
    data: RoleAssociationCreateManyRoleInput | RoleAssociationCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RoleClassificationCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutRoleClassificationsInput
  }

  export type RoleClassificationUncheckedCreateWithoutRoleInput = {
    id?: string
    seq?: number
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type RoleClassificationCreateOrConnectWithoutRoleInput = {
    where: RoleClassificationWhereUniqueInput
    create: XOR<RoleClassificationCreateWithoutRoleInput, RoleClassificationUncheckedCreateWithoutRoleInput>
  }

  export type TenantCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRoleInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRoleInput, TenantUncheckedCreateWithoutRoleInput>
  }

  export type TenantCreateManyRoleInputEnvelope = {
    data: TenantCreateManyRoleInput | TenantCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type AbilityUpsertWithWhereUniqueWithoutRoleInput = {
    where: AbilityWhereUniqueInput
    update: XOR<AbilityUpdateWithoutRoleInput, AbilityUncheckedUpdateWithoutRoleInput>
    create: XOR<AbilityCreateWithoutRoleInput, AbilityUncheckedCreateWithoutRoleInput>
  }

  export type AbilityUpdateWithWhereUniqueWithoutRoleInput = {
    where: AbilityWhereUniqueInput
    data: XOR<AbilityUpdateWithoutRoleInput, AbilityUncheckedUpdateWithoutRoleInput>
  }

  export type AbilityUpdateManyWithWhereWithoutRoleInput = {
    where: AbilityScalarWhereInput
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyWithoutRoleInput>
  }

  export type AbilityScalarWhereInput = {
    AND?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
    OR?: AbilityScalarWhereInput[]
    NOT?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
    id?: StringFilter<"Ability"> | string
    seq?: IntFilter<"Ability"> | number
    createdAt?: DateTimeFilter<"Ability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Ability"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Ability"> | Date | string | null
    type?: EnumAbilityTypesFilter<"Ability"> | $Enums.AbilityTypes
    roleId?: StringFilter<"Ability"> | string
    description?: StringNullableFilter<"Ability"> | string | null
    conditions?: JsonNullableFilter<"Ability">
    subjectId?: StringFilter<"Ability"> | string
    tenantId?: StringFilter<"Ability"> | string
  }

  export type AssignmentUpsertWithWhereUniqueWithoutRoleInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutRoleInput, AssignmentUncheckedUpdateWithoutRoleInput>
    create: XOR<AssignmentCreateWithoutRoleInput, AssignmentUncheckedCreateWithoutRoleInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutRoleInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutRoleInput, AssignmentUncheckedUpdateWithoutRoleInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutRoleInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleAssociationUpsertWithWhereUniqueWithoutRoleInput = {
    where: RoleAssociationWhereUniqueInput
    update: XOR<RoleAssociationUpdateWithoutRoleInput, RoleAssociationUncheckedUpdateWithoutRoleInput>
    create: XOR<RoleAssociationCreateWithoutRoleInput, RoleAssociationUncheckedCreateWithoutRoleInput>
  }

  export type RoleAssociationUpdateWithWhereUniqueWithoutRoleInput = {
    where: RoleAssociationWhereUniqueInput
    data: XOR<RoleAssociationUpdateWithoutRoleInput, RoleAssociationUncheckedUpdateWithoutRoleInput>
  }

  export type RoleAssociationUpdateManyWithWhereWithoutRoleInput = {
    where: RoleAssociationScalarWhereInput
    data: XOR<RoleAssociationUpdateManyMutationInput, RoleAssociationUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleClassificationUpsertWithoutRoleInput = {
    update: XOR<RoleClassificationUpdateWithoutRoleInput, RoleClassificationUncheckedUpdateWithoutRoleInput>
    create: XOR<RoleClassificationCreateWithoutRoleInput, RoleClassificationUncheckedCreateWithoutRoleInput>
    where?: RoleClassificationWhereInput
  }

  export type RoleClassificationUpdateToOneWithWhereWithoutRoleInput = {
    where?: RoleClassificationWhereInput
    data: XOR<RoleClassificationUpdateWithoutRoleInput, RoleClassificationUncheckedUpdateWithoutRoleInput>
  }

  export type RoleClassificationUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutRoleClassificationsNestedInput
  }

  export type RoleClassificationUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantUpsertWithWhereUniqueWithoutRoleInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutRoleInput, TenantUncheckedUpdateWithoutRoleInput>
    create: XOR<TenantCreateWithoutRoleInput, TenantUncheckedCreateWithoutRoleInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutRoleInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutRoleInput, TenantUncheckedUpdateWithoutRoleInput>
  }

  export type TenantUpdateManyWithWhereWithoutRoleInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutRoleInput>
  }

  export type TenantScalarWhereInput = {
    AND?: TenantScalarWhereInput | TenantScalarWhereInput[]
    OR?: TenantScalarWhereInput[]
    NOT?: TenantScalarWhereInput | TenantScalarWhereInput[]
    id?: StringFilter<"Tenant"> | string
    seq?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    userId?: StringFilter<"Tenant"> | string
    spaceId?: StringFilter<"Tenant"> | string
    roleId?: StringFilter<"Tenant"> | string
    main?: BoolFilter<"Tenant"> | boolean
  }

  export type GroupCreateWithoutRoleAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenant: TenantCreateNestedOneWithoutGroupsInput
    fileAssociations?: FileAssociationCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutRoleAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenantId: string
    fileAssociations?: FileAssociationUncheckedCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationUncheckedCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutRoleAssociationsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutRoleAssociationsInput, GroupUncheckedCreateWithoutRoleAssociationsInput>
  }

  export type RoleCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityCreateNestedManyWithoutRoleInput
    assignments?: AssignmentCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationCreateNestedOneWithoutRoleInput
    tenants?: TenantCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityUncheckedCreateNestedManyWithoutRoleInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutRoleInput
    classification?: RoleClassificationUncheckedCreateNestedOneWithoutRoleInput
    tenants?: TenantUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutAssociationsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutAssociationsInput, RoleUncheckedCreateWithoutAssociationsInput>
  }

  export type GroupUpsertWithoutRoleAssociationsInput = {
    update: XOR<GroupUpdateWithoutRoleAssociationsInput, GroupUncheckedUpdateWithoutRoleAssociationsInput>
    create: XOR<GroupCreateWithoutRoleAssociationsInput, GroupUncheckedCreateWithoutRoleAssociationsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutRoleAssociationsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutRoleAssociationsInput, GroupUncheckedUpdateWithoutRoleAssociationsInput>
  }

  export type GroupUpdateWithoutRoleAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutGroupsNestedInput
    fileAssociations?: FileAssociationUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutRoleAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    fileAssociations?: FileAssociationUncheckedUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUncheckedUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type RoleUpsertWithoutAssociationsInput = {
    update: XOR<RoleUpdateWithoutAssociationsInput, RoleUncheckedUpdateWithoutAssociationsInput>
    create: XOR<RoleCreateWithoutAssociationsInput, RoleUncheckedCreateWithoutAssociationsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutAssociationsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutAssociationsInput, RoleUncheckedUpdateWithoutAssociationsInput>
  }

  export type RoleUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUpdateOneWithoutRoleNestedInput
    tenants?: TenantUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUncheckedUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutRoleNestedInput
    classification?: RoleClassificationUncheckedUpdateOneWithoutRoleNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type CategoryCreateWithoutRoleClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    fileClassifications?: FileClassificationCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutRoleClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    tenantId: string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    fileClassifications?: FileClassificationUncheckedCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutRoleClassificationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutRoleClassificationsInput, CategoryUncheckedCreateWithoutRoleClassificationsInput>
  }

  export type RoleCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityCreateNestedManyWithoutRoleInput
    assignments?: AssignmentCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationCreateNestedManyWithoutRoleInput
    tenants?: TenantCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name?: $Enums.Roles
    abilities?: AbilityUncheckedCreateNestedManyWithoutRoleInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutRoleInput
    associations?: RoleAssociationUncheckedCreateNestedManyWithoutRoleInput
    tenants?: TenantUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutClassificationInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutClassificationInput, RoleUncheckedCreateWithoutClassificationInput>
  }

  export type CategoryUpsertWithoutRoleClassificationsInput = {
    update: XOR<CategoryUpdateWithoutRoleClassificationsInput, CategoryUncheckedUpdateWithoutRoleClassificationsInput>
    create: XOR<CategoryCreateWithoutRoleClassificationsInput, CategoryUncheckedCreateWithoutRoleClassificationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutRoleClassificationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutRoleClassificationsInput, CategoryUncheckedUpdateWithoutRoleClassificationsInput>
  }

  export type CategoryUpdateWithoutRoleClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    fileClassifications?: FileClassificationUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutRoleClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    fileClassifications?: FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type RoleUpsertWithoutClassificationInput = {
    update: XOR<RoleUpdateWithoutClassificationInput, RoleUncheckedUpdateWithoutClassificationInput>
    create: XOR<RoleCreateWithoutClassificationInput, RoleUncheckedCreateWithoutClassificationInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutClassificationInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutClassificationInput, RoleUncheckedUpdateWithoutClassificationInput>
  }

  export type RoleUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUpdateManyWithoutRoleNestedInput
    tenants?: TenantUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    abilities?: AbilityUncheckedUpdateManyWithoutRoleNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutRoleNestedInput
    associations?: RoleAssociationUncheckedUpdateManyWithoutRoleNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type GroundCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label?: string | null
    address: string
    phone: string
    email: string
    businessNo: string
    logoImageFileId?: string | null
    imageFileId?: string | null
  }

  export type GroundUncheckedCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    label?: string | null
    address: string
    phone: string
    email: string
    businessNo: string
    logoImageFileId?: string | null
    imageFileId?: string | null
  }

  export type GroundCreateOrConnectWithoutSpaceInput = {
    where: GroundWhereUniqueInput
    create: XOR<GroundCreateWithoutSpaceInput, GroundUncheckedCreateWithoutSpaceInput>
  }

  export type SpaceAssociationCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutSpaceAssociationsInput
  }

  export type SpaceAssociationUncheckedCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type SpaceAssociationCreateOrConnectWithoutSpaceInput = {
    where: SpaceAssociationWhereUniqueInput
    create: XOR<SpaceAssociationCreateWithoutSpaceInput, SpaceAssociationUncheckedCreateWithoutSpaceInput>
  }

  export type SpaceAssociationCreateManySpaceInputEnvelope = {
    data: SpaceAssociationCreateManySpaceInput | SpaceAssociationCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type SpaceClassificationCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutSpaceClassificationsInput
  }

  export type SpaceClassificationUncheckedCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type SpaceClassificationCreateOrConnectWithoutSpaceInput = {
    where: SpaceClassificationWhereUniqueInput
    create: XOR<SpaceClassificationCreateWithoutSpaceInput, SpaceClassificationUncheckedCreateWithoutSpaceInput>
  }

  export type TenantCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    user: UserCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSpaceInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSpaceInput, TenantUncheckedCreateWithoutSpaceInput>
  }

  export type TenantCreateManySpaceInputEnvelope = {
    data: TenantCreateManySpaceInput | TenantCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type GroundUpsertWithoutSpaceInput = {
    update: XOR<GroundUpdateWithoutSpaceInput, GroundUncheckedUpdateWithoutSpaceInput>
    create: XOR<GroundCreateWithoutSpaceInput, GroundUncheckedCreateWithoutSpaceInput>
    where?: GroundWhereInput
  }

  export type GroundUpdateToOneWithWhereWithoutSpaceInput = {
    where?: GroundWhereInput
    data: XOR<GroundUpdateWithoutSpaceInput, GroundUncheckedUpdateWithoutSpaceInput>
  }

  export type GroundUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    businessNo?: StringFieldUpdateOperationsInput | string
    logoImageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroundUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    businessNo?: StringFieldUpdateOperationsInput | string
    logoImageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpaceAssociationUpsertWithWhereUniqueWithoutSpaceInput = {
    where: SpaceAssociationWhereUniqueInput
    update: XOR<SpaceAssociationUpdateWithoutSpaceInput, SpaceAssociationUncheckedUpdateWithoutSpaceInput>
    create: XOR<SpaceAssociationCreateWithoutSpaceInput, SpaceAssociationUncheckedCreateWithoutSpaceInput>
  }

  export type SpaceAssociationUpdateWithWhereUniqueWithoutSpaceInput = {
    where: SpaceAssociationWhereUniqueInput
    data: XOR<SpaceAssociationUpdateWithoutSpaceInput, SpaceAssociationUncheckedUpdateWithoutSpaceInput>
  }

  export type SpaceAssociationUpdateManyWithWhereWithoutSpaceInput = {
    where: SpaceAssociationScalarWhereInput
    data: XOR<SpaceAssociationUpdateManyMutationInput, SpaceAssociationUncheckedUpdateManyWithoutSpaceInput>
  }

  export type SpaceClassificationUpsertWithoutSpaceInput = {
    update: XOR<SpaceClassificationUpdateWithoutSpaceInput, SpaceClassificationUncheckedUpdateWithoutSpaceInput>
    create: XOR<SpaceClassificationCreateWithoutSpaceInput, SpaceClassificationUncheckedCreateWithoutSpaceInput>
    where?: SpaceClassificationWhereInput
  }

  export type SpaceClassificationUpdateToOneWithWhereWithoutSpaceInput = {
    where?: SpaceClassificationWhereInput
    data: XOR<SpaceClassificationUpdateWithoutSpaceInput, SpaceClassificationUncheckedUpdateWithoutSpaceInput>
  }

  export type SpaceClassificationUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutSpaceClassificationsNestedInput
  }

  export type SpaceClassificationUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantUpsertWithWhereUniqueWithoutSpaceInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutSpaceInput, TenantUncheckedUpdateWithoutSpaceInput>
    create: XOR<TenantCreateWithoutSpaceInput, TenantUncheckedCreateWithoutSpaceInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutSpaceInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutSpaceInput, TenantUncheckedUpdateWithoutSpaceInput>
  }

  export type TenantUpdateManyWithWhereWithoutSpaceInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutSpaceInput>
  }

  export type CategoryCreateWithoutSpaceClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    fileClassifications?: FileClassificationCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSpaceClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    tenantId: string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    fileClassifications?: FileClassificationUncheckedCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput
    userClassifications?: UserClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSpaceClassificationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSpaceClassificationsInput, CategoryUncheckedCreateWithoutSpaceClassificationsInput>
  }

  export type SpaceCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundCreateNestedOneWithoutSpaceInput
    associations?: SpaceAssociationCreateNestedManyWithoutSpaceInput
    tenants?: TenantCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundUncheckedCreateNestedOneWithoutSpaceInput
    associations?: SpaceAssociationUncheckedCreateNestedManyWithoutSpaceInput
    tenants?: TenantUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutClassificationInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutClassificationInput, SpaceUncheckedCreateWithoutClassificationInput>
  }

  export type CategoryUpsertWithoutSpaceClassificationsInput = {
    update: XOR<CategoryUpdateWithoutSpaceClassificationsInput, CategoryUncheckedUpdateWithoutSpaceClassificationsInput>
    create: XOR<CategoryCreateWithoutSpaceClassificationsInput, CategoryUncheckedCreateWithoutSpaceClassificationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSpaceClassificationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSpaceClassificationsInput, CategoryUncheckedUpdateWithoutSpaceClassificationsInput>
  }

  export type CategoryUpdateWithoutSpaceClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    fileClassifications?: FileClassificationUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSpaceClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    fileClassifications?: FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SpaceUpsertWithoutClassificationInput = {
    update: XOR<SpaceUpdateWithoutClassificationInput, SpaceUncheckedUpdateWithoutClassificationInput>
    create: XOR<SpaceCreateWithoutClassificationInput, SpaceUncheckedCreateWithoutClassificationInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutClassificationInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutClassificationInput, SpaceUncheckedUpdateWithoutClassificationInput>
  }

  export type SpaceUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUpdateOneWithoutSpaceNestedInput
    associations?: SpaceAssociationUpdateManyWithoutSpaceNestedInput
    tenants?: TenantUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUncheckedUpdateOneWithoutSpaceNestedInput
    associations?: SpaceAssociationUncheckedUpdateManyWithoutSpaceNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type GroupCreateWithoutSpaceAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenant: TenantCreateNestedOneWithoutGroupsInput
    fileAssociations?: FileAssociationCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutSpaceAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenantId: string
    fileAssociations?: FileAssociationUncheckedCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationUncheckedCreateNestedManyWithoutGroupInput
    userAssociations?: UserAssociationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutSpaceAssociationsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutSpaceAssociationsInput, GroupUncheckedCreateWithoutSpaceAssociationsInput>
  }

  export type SpaceCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundCreateNestedOneWithoutSpaceInput
    classification?: SpaceClassificationCreateNestedOneWithoutSpaceInput
    tenants?: TenantCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    ground?: GroundUncheckedCreateNestedOneWithoutSpaceInput
    classification?: SpaceClassificationUncheckedCreateNestedOneWithoutSpaceInput
    tenants?: TenantUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutAssociationsInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutAssociationsInput, SpaceUncheckedCreateWithoutAssociationsInput>
  }

  export type GroupUpsertWithoutSpaceAssociationsInput = {
    update: XOR<GroupUpdateWithoutSpaceAssociationsInput, GroupUncheckedUpdateWithoutSpaceAssociationsInput>
    create: XOR<GroupCreateWithoutSpaceAssociationsInput, GroupUncheckedCreateWithoutSpaceAssociationsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutSpaceAssociationsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutSpaceAssociationsInput, GroupUncheckedUpdateWithoutSpaceAssociationsInput>
  }

  export type GroupUpdateWithoutSpaceAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutGroupsNestedInput
    fileAssociations?: FileAssociationUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutSpaceAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    fileAssociations?: FileAssociationUncheckedUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUncheckedUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type SpaceUpsertWithoutAssociationsInput = {
    update: XOR<SpaceUpdateWithoutAssociationsInput, SpaceUncheckedUpdateWithoutAssociationsInput>
    create: XOR<SpaceCreateWithoutAssociationsInput, SpaceUncheckedCreateWithoutAssociationsInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutAssociationsInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutAssociationsInput, SpaceUncheckedUpdateWithoutAssociationsInput>
  }

  export type SpaceUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUpdateOneWithoutSpaceNestedInput
    classification?: SpaceClassificationUpdateOneWithoutSpaceNestedInput
    tenants?: TenantUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ground?: GroundUncheckedUpdateOneWithoutSpaceNestedInput
    classification?: SpaceClassificationUncheckedUpdateOneWithoutSpaceNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceCreateWithoutGroundInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    associations?: SpaceAssociationCreateNestedManyWithoutSpaceInput
    classification?: SpaceClassificationCreateNestedOneWithoutSpaceInput
    tenants?: TenantCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateWithoutGroundInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    associations?: SpaceAssociationUncheckedCreateNestedManyWithoutSpaceInput
    classification?: SpaceClassificationUncheckedCreateNestedOneWithoutSpaceInput
    tenants?: TenantUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutGroundInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutGroundInput, SpaceUncheckedCreateWithoutGroundInput>
  }

  export type SpaceUpsertWithoutGroundInput = {
    update: XOR<SpaceUpdateWithoutGroundInput, SpaceUncheckedUpdateWithoutGroundInput>
    create: XOR<SpaceCreateWithoutGroundInput, SpaceUncheckedCreateWithoutGroundInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutGroundInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutGroundInput, SpaceUncheckedUpdateWithoutGroundInput>
  }

  export type SpaceUpdateWithoutGroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    associations?: SpaceAssociationUpdateManyWithoutSpaceNestedInput
    classification?: SpaceClassificationUpdateOneWithoutSpaceNestedInput
    tenants?: TenantUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutGroundInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    associations?: SpaceAssociationUncheckedUpdateManyWithoutSpaceNestedInput
    classification?: SpaceClassificationUncheckedUpdateOneWithoutSpaceNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    nickname: string
    avatarFileId?: string | null
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    nickname: string
    avatarFileId?: string | null
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileCreateManyUserInputEnvelope = {
    data: ProfileCreateManyUserInput | ProfileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    main?: boolean
    assignments?: AssignmentCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    contents?: ContentCreateNestedManyWithoutTenantInput
    files?: FileCreateNestedManyWithoutTenantInput
    groups?: GroupCreateNestedManyWithoutTenantInput
    role: RoleCreateNestedOneWithoutTenantsInput
    space: SpaceCreateNestedOneWithoutTenantsInput
    timelines?: TimelineCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    spaceId: string
    roleId: string
    main?: boolean
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    contents?: ContentUncheckedCreateNestedManyWithoutTenantInput
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    groups?: GroupUncheckedCreateNestedManyWithoutTenantInput
    timelines?: TimelineUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUserInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput>
  }

  export type TenantCreateManyUserInputEnvelope = {
    data: TenantCreateManyUserInput | TenantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserClassificationCreateWithoutUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutUserClassificationsInput
  }

  export type UserClassificationUncheckedCreateWithoutUserInput = {
    id?: string
    seq?: number
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type UserClassificationCreateOrConnectWithoutUserInput = {
    where: UserClassificationWhereUniqueInput
    create: XOR<UserClassificationCreateWithoutUserInput, UserClassificationUncheckedCreateWithoutUserInput>
  }

  export type UserAssociationCreateWithoutUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutUserAssociationsInput
  }

  export type UserAssociationUncheckedCreateWithoutUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type UserAssociationCreateOrConnectWithoutUserInput = {
    where: UserAssociationWhereUniqueInput
    create: XOR<UserAssociationCreateWithoutUserInput, UserAssociationUncheckedCreateWithoutUserInput>
  }

  export type UserAssociationCreateManyUserInputEnvelope = {
    data: UserAssociationCreateManyUserInput | UserAssociationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateManyWithWhereWithoutUserInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: StringFilter<"Profile"> | string
    seq?: IntFilter<"Profile"> | number
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    name?: StringFilter<"Profile"> | string
    nickname?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    avatarFileId?: StringNullableFilter<"Profile"> | string | null
  }

  export type TenantUpsertWithWhereUniqueWithoutUserInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutUserInput, TenantUncheckedUpdateWithoutUserInput>
    create: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutUserInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutUserInput, TenantUncheckedUpdateWithoutUserInput>
  }

  export type TenantUpdateManyWithWhereWithoutUserInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutUserInput>
  }

  export type UserClassificationUpsertWithoutUserInput = {
    update: XOR<UserClassificationUpdateWithoutUserInput, UserClassificationUncheckedUpdateWithoutUserInput>
    create: XOR<UserClassificationCreateWithoutUserInput, UserClassificationUncheckedCreateWithoutUserInput>
    where?: UserClassificationWhereInput
  }

  export type UserClassificationUpdateToOneWithWhereWithoutUserInput = {
    where?: UserClassificationWhereInput
    data: XOR<UserClassificationUpdateWithoutUserInput, UserClassificationUncheckedUpdateWithoutUserInput>
  }

  export type UserClassificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutUserClassificationsNestedInput
  }

  export type UserClassificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAssociationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAssociationWhereUniqueInput
    update: XOR<UserAssociationUpdateWithoutUserInput, UserAssociationUncheckedUpdateWithoutUserInput>
    create: XOR<UserAssociationCreateWithoutUserInput, UserAssociationUncheckedCreateWithoutUserInput>
  }

  export type UserAssociationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAssociationWhereUniqueInput
    data: XOR<UserAssociationUpdateWithoutUserInput, UserAssociationUncheckedUpdateWithoutUserInput>
  }

  export type UserAssociationUpdateManyWithWhereWithoutUserInput = {
    where: UserAssociationScalarWhereInput
    data: XOR<UserAssociationUpdateManyMutationInput, UserAssociationUncheckedUpdateManyWithoutUserInput>
  }

  export type CategoryCreateWithoutUserClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    fileClassifications?: FileClassificationCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutUserClassificationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
    tenantId: string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    fileClassifications?: FileClassificationUncheckedCreateNestedManyWithoutCategoryInput
    roleClassifications?: RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput
    spaceClassifications?: SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutUserClassificationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutUserClassificationsInput, CategoryUncheckedCreateWithoutUserClassificationsInput>
  }

  export type UserCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileCreateNestedManyWithoutUserInput
    tenants?: TenantCreateNestedManyWithoutUserInput
    associations?: UserAssociationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClassificationInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileUncheckedCreateNestedManyWithoutUserInput
    tenants?: TenantUncheckedCreateNestedManyWithoutUserInput
    associations?: UserAssociationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClassificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassificationInput, UserUncheckedCreateWithoutClassificationInput>
  }

  export type CategoryUpsertWithoutUserClassificationsInput = {
    update: XOR<CategoryUpdateWithoutUserClassificationsInput, CategoryUncheckedUpdateWithoutUserClassificationsInput>
    create: XOR<CategoryCreateWithoutUserClassificationsInput, CategoryUncheckedCreateWithoutUserClassificationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutUserClassificationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutUserClassificationsInput, CategoryUncheckedUpdateWithoutUserClassificationsInput>
  }

  export type CategoryUpdateWithoutUserClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    fileClassifications?: FileClassificationUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutUserClassificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    fileClassifications?: FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithoutClassificationInput = {
    update: XOR<UserUpdateWithoutClassificationInput, UserUncheckedUpdateWithoutClassificationInput>
    create: XOR<UserCreateWithoutClassificationInput, UserUncheckedCreateWithoutClassificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassificationInput, UserUncheckedUpdateWithoutClassificationInput>
  }

  export type UserUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUpdateManyWithoutUserNestedInput
    tenants?: TenantUpdateManyWithoutUserNestedInput
    associations?: UserAssociationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutUserNestedInput
    associations?: UserAssociationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupCreateWithoutUserAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenant: TenantCreateNestedOneWithoutGroupsInput
    fileAssociations?: FileAssociationCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutUserAssociationsInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
    tenantId: string
    fileAssociations?: FileAssociationUncheckedCreateNestedManyWithoutGroupInput
    roleAssociations?: RoleAssociationUncheckedCreateNestedManyWithoutGroupInput
    spaceAssociations?: SpaceAssociationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutUserAssociationsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutUserAssociationsInput, GroupUncheckedCreateWithoutUserAssociationsInput>
  }

  export type UserCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileCreateNestedManyWithoutUserInput
    tenants?: TenantCreateNestedManyWithoutUserInput
    classification?: UserClassificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssociationsInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    profiles?: ProfileUncheckedCreateNestedManyWithoutUserInput
    tenants?: TenantUncheckedCreateNestedManyWithoutUserInput
    classification?: UserClassificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssociationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssociationsInput, UserUncheckedCreateWithoutAssociationsInput>
  }

  export type GroupUpsertWithoutUserAssociationsInput = {
    update: XOR<GroupUpdateWithoutUserAssociationsInput, GroupUncheckedUpdateWithoutUserAssociationsInput>
    create: XOR<GroupCreateWithoutUserAssociationsInput, GroupUncheckedCreateWithoutUserAssociationsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutUserAssociationsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutUserAssociationsInput, GroupUncheckedUpdateWithoutUserAssociationsInput>
  }

  export type GroupUpdateWithoutUserAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutGroupsNestedInput
    fileAssociations?: FileAssociationUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutUserAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    fileAssociations?: FileAssociationUncheckedUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUncheckedUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutAssociationsInput = {
    update: XOR<UserUpdateWithoutAssociationsInput, UserUncheckedUpdateWithoutAssociationsInput>
    create: XOR<UserCreateWithoutAssociationsInput, UserUncheckedCreateWithoutAssociationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssociationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssociationsInput, UserUncheckedUpdateWithoutAssociationsInput>
  }

  export type UserUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUpdateManyWithoutUserNestedInput
    tenants?: TenantUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    tenants?: TenantUncheckedUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutProfilesInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    tenants?: TenantCreateNestedManyWithoutUserInput
    classification?: UserClassificationCreateNestedOneWithoutUserInput
    associations?: UserAssociationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfilesInput = {
    id?: string
    seq?: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    removedAt?: Date | string | null
    phone: string
    name: string
    email: string
    password: string
    tenants?: TenantUncheckedCreateNestedManyWithoutUserInput
    classification?: UserClassificationUncheckedCreateNestedOneWithoutUserInput
    associations?: UserAssociationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfilesInput, UserUncheckedCreateWithoutProfilesInput>
  }

  export type UserUpsertWithoutProfilesInput = {
    update: XOR<UserUpdateWithoutProfilesInput, UserUncheckedUpdateWithoutProfilesInput>
    create: XOR<UserCreateWithoutProfilesInput, UserUncheckedCreateWithoutProfilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfilesInput, UserUncheckedUpdateWithoutProfilesInput>
  }

  export type UserUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tenants?: TenantUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUpdateOneWithoutUserNestedInput
    associations?: UserAssociationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tenants?: TenantUncheckedUpdateManyWithoutUserNestedInput
    classification?: UserClassificationUncheckedUpdateOneWithoutUserNestedInput
    associations?: UserAssociationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    tenantId: string
  }

  export type FileClassificationCreateManyCategoryInput = {
    id?: string
    seq?: number
    fileId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type RoleClassificationCreateManyCategoryInput = {
    id?: string
    seq?: number
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type SpaceClassificationCreateManyCategoryInput = {
    id?: string
    seq?: number
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type UserClassificationCreateManyCategoryInput = {
    id?: string
    seq?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    children?: CategoryUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    fileClassifications?: FileClassificationUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    tenantId?: StringFieldUpdateOperationsInput | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    fileClassifications?: FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type FileClassificationUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type FileClassificationUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    fileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileClassificationUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    fileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleClassificationUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type RoleClassificationUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleClassificationUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceClassificationUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    space?: SpaceUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type SpaceClassificationUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceClassificationUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserClassificationUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutClassificationNestedInput
  }

  export type UserClassificationUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserClassificationUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileAssociationCreateManyGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    fileId: string
  }

  export type RoleAssociationCreateManyGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
  }

  export type SpaceAssociationCreateManyGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    spaceId: string
  }

  export type UserAssociationCreateManyGroupInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
  }

  export type FileAssociationUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneRequiredWithoutAssociationsNestedInput
  }

  export type FileAssociationUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileId?: StringFieldUpdateOperationsInput | string
  }

  export type FileAssociationUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleAssociationUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutAssociationsNestedInput
  }

  export type RoleAssociationUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleAssociationUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceAssociationUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    space?: SpaceUpdateOneRequiredWithoutAssociationsNestedInput
  }

  export type SpaceAssociationUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceAssociationUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAssociationUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAssociationsNestedInput
  }

  export type UserAssociationUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAssociationUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentCreateManyTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    roleId: string
  }

  export type CategoryCreateManyTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.CategoryTypes
    parentId?: string | null
  }

  export type ContentCreateManyTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    title?: string | null
    description?: string | null
    type?: $Enums.TextTypes
    text?: string | null
    fileId?: string | null
  }

  export type FileCreateManyTenantInput = {
    id?: string
    seq?: number
    name: string
    size: number
    parentId?: string | null
    mimeType: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type GroupCreateManyTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    type?: $Enums.GroupTypes
    label?: string | null
  }

  export type TimelineCreateManyTenantInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type AssignmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    fileClassifications?: FileClassificationUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    fileClassifications?: FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    roleClassifications?: RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    spaceClassifications?: SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput
    userClassifications?: UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypesFieldUpdateOperationsInput | $Enums.CategoryTypes
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTextTypesFieldUpdateOperationsInput | $Enums.TextTypes
    text?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: FileUpdateOneWithoutChildrenNestedInput
    children?: FileUpdateManyWithoutParentNestedInput
    associations?: FileAssociationUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUpdateOneWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: FileUncheckedUpdateManyWithoutParentNestedInput
    associations?: FileAssociationUncheckedUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUncheckedUpdateOneWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssociations?: FileAssociationUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssociations?: FileAssociationUncheckedUpdateManyWithoutGroupNestedInput
    roleAssociations?: RoleAssociationUncheckedUpdateManyWithoutGroupNestedInput
    spaceAssociations?: SpaceAssociationUncheckedUpdateManyWithoutGroupNestedInput
    userAssociations?: UserAssociationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumGroupTypesFieldUpdateOperationsInput | $Enums.GroupTypes
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimelineUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutTimelineNestedInput
  }

  export type TimelineUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutTimelineNestedInput
  }

  export type TimelineUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyTimelineInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type?: $Enums.SessionTypes
    repeatCycleType?: $Enums.RepeatCycleTypes | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    recurringDayOfWeek?: $Enums.RecurringDayOfWeek | null
    recurringMonth?: number | null
    label: string
    name: string
  }

  export type SessionUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    program?: ProgramUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    program?: ProgramUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumSessionTypesFieldUpdateOperationsInput | $Enums.SessionTypes
    repeatCycleType?: NullableEnumRepeatCycleTypesFieldUpdateOperationsInput | $Enums.RepeatCycleTypes | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringDayOfWeek?: NullableEnumRecurringDayOfWeekFieldUpdateOperationsInput | $Enums.RecurringDayOfWeek | null
    recurringMonth?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateManyContentInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type PostUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileCreateManyParentInput = {
    id?: string
    seq?: number
    name: string
    size: number
    mimeType: string
    url: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
  }

  export type FileAssociationCreateManyFileInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type FileUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: FileUpdateManyWithoutParentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutFilesNestedInput
    associations?: FileAssociationUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUpdateOneWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: FileUncheckedUpdateManyWithoutParentNestedInput
    associations?: FileAssociationUncheckedUpdateManyWithoutFileNestedInput
    classification?: FileClassificationUncheckedUpdateOneWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileAssociationUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutFileAssociationsNestedInput
  }

  export type FileAssociationUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type FileAssociationUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityCreateManyRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    type: $Enums.AbilityTypes
    description?: string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId: string
    tenantId: string
  }

  export type AssignmentCreateManyRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    tenantId: string
  }

  export type RoleAssociationCreateManyRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type TenantCreateManyRoleInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    spaceId: string
    main?: boolean
  }

  export type AbilityUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAbilityTypesFieldUpdateOperationsInput | $Enums.AbilityTypes
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAbilityTypesFieldUpdateOperationsInput | $Enums.AbilityTypes
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumAbilityTypesFieldUpdateOperationsInput | $Enums.AbilityTypes
    description?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableJsonNullValueInput | InputJsonValue
    subjectId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleAssociationUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutRoleAssociationsNestedInput
  }

  export type RoleAssociationUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleAssociationUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpaceAssociationCreateManySpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type TenantCreateManySpaceInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    userId: string
    roleId: string
    main?: boolean
  }

  export type SpaceAssociationUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutSpaceAssociationsNestedInput
  }

  export type SpaceAssociationUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceAssociationUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileCreateManyUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    name: string
    nickname: string
    avatarFileId?: string | null
  }

  export type TenantCreateManyUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    spaceId: string
    roleId: string
    main?: boolean
  }

  export type UserAssociationCreateManyUserInput = {
    id?: string
    seq?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    removedAt?: Date | string | null
    groupId: string
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    contents?: ContentUpdateManyWithoutTenantNestedInput
    files?: FileUpdateManyWithoutTenantNestedInput
    groups?: GroupUpdateManyWithoutTenantNestedInput
    role?: RoleUpdateOneRequiredWithoutTenantsNestedInput
    space?: SpaceUpdateOneRequiredWithoutTenantsNestedInput
    timelines?: TimelineUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
    assignments?: AssignmentUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    contents?: ContentUncheckedUpdateManyWithoutTenantNestedInput
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    groups?: GroupUncheckedUpdateManyWithoutTenantNestedInput
    timelines?: TimelineUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    main?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAssociationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutUserAssociationsNestedInput
  }

  export type UserAssociationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAssociationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    groupId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}